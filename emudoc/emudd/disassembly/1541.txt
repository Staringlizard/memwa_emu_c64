                                                                  s$$$$$$s
 All_About_Your_1541-Online Help V0.23              s$$$$$$p     $$$S  S$$
 (c) by Ninja/The Dreams in 1995-2006               $$$S   S$$   $$$S  S$J
 HQ - [http://www.the-dreams.de]                    $$$S   S$$   $$$$$$l
                                                    $$$S   S$$   $$$$  $$l
 1541 Zeropage                                      $$$S   S$$   $$$P   $$l
 1541 ROM-Listing                                   Y$$$$$$$P

 Job Codes                                                            d$$$b
 Error Messages                                         s$$$$$$b    d$$$  $$b
                                                        $$$$        $$$$  $$$
 VIA6522 Registers                                      $$$$sss     $$$&%%&$$
                                                        $$$$""'     $$$$   $$
                                                        $$$$        Y$$$   SP
                                                        Y$$$$$$$P

                                                                   o$$$$$Ss
                                                     s$$    $s    S$$S
                                                     $$$$  $$$     S$$$
                                                     $$$ $$ $$        S$$s
                                                     $$$ "" $$           $$
                                                     $$$    $$    sS$$$$$$P
                                                     Y$$    $P

  +------------------------------------------------------------------------
  |
  |      VERSATILE INTERFACE ADAPTER (VIA) 6522
  |
  +------------------------------------------------------------------------
  |
  |  Register description:
  |
  |  VIA 1 (Serial Bus):
  |
  |   $1800/6144/VIA1+0       Data Port B (ATN, CLOCK, DATA, Device #)
  |   $1801/6145/VIA1+1       Data Port A (free for parallel cables)
  |   $1802/6146/VIA1+2       Data Direction Register B
  |   $1803/6147/VIA1+3       Data Direction Register A
  |   $1804/6148/VIA1+4       Timer 1 Low-Byte (Timeout Errors)
  |   $1805/6149/VIA1+5       Timer 1 High-Byte (Timeout Errors)
  |   $1806/6150/VIA1+6       Timer 1-Latch Low-Byte (Timeout Errors)
  |   $1807/6151/VIA1+7       Timer 1-Latch High-Byte (Timeout Errors)
  |   $1808/6152/VIA1+8       Timer 2 Low-Byte (unused)
  |   $1809/6153/VIA1+9       Timer 2 High-Byte (unused)
  |   $180A/6154/VIA1+10      Shift Register
  |   $180B/6155/VIA1+11      Auxiliary Control Register
  |   $180C/6156/VIA1+12      Peripheral Control Register
  |   $180D/6157/VIA1+13      Interrupt Flag Register
  |   $180E/6158/VIA1+14      Interrupt Enable Register
  |   $180F/6159/VIA1+15      Data Port A* (no handshake)
  |
  |  VIA 2 (Motor and Head Control):
  |
  |   $1C00/7168/VIA2+0       Data Port B (SYNC, Motors, Bit Rates, LED)
  |   $1C01/7169/VIA2+1       Data Port A (Data to/from head)
  |   $1C02/7170/VIA2+2       Data Direction Register B
  |   $1C03/7171/VIA2+3       Data Direction Register A
  |   $1C04/7172/VIA2+4       Timer 1 Low-Byte (IRQ Timer)
  |   $1C05/7173/VIA2+5       Timer 1 High-Byte (IRQ Timer)
  |   $1C06/7174/VIA2+6       Timer 1-Latch Low-Byte (IRQ Timer)
  |   $1C07/7175/VIA2+7       Timer 1-Latch High-Byte (IRQ Timer)
  |   $1C08/7176/VIA2+8       Timer 2 Low-Byte (unused)
  |   $1C09/7177/VIA2+9       Timer 2 High-Byte (unused)
  |   $1C0A/7178/VIA2+10      Shift Register
  |   $1C0B/7179/VIA2+11      Auxiliary Control Register
  |   $1C0C/7180/VIA2+12      Peripheral Control Register
  |   $1C0D/7181/VIA2+13      Interrupt Flag Register
  |   $1C0E/7182/VIA2+14      Interrupt Enable Register
  |   $1C0F/7183/VIA2+15      Data Port A* (no handshake)
  |
  +------------------------------------------------------------------------



 $1800/6144/VIA1+0:   Data Port B (ATN, CLOCK, DATA, Device #)

   +----------+---------------------------------------------------+
   | Bit  7   |   ATN IN                                          |
   | Bits 6-5 |   Device address preset switches:                 |
   |          |     00 = #8, 01 = #9, 10 = #10, 11 = #11          |
   | Bit  4   |   ATN acknowledge OUT                             |
   | Bit  3   |   CLOCK OUT                                       |
   | Bit  2   |   CLOCK IN                                        |
   | Bit  1   |   DATA OUT                                        |
   | Bit  0   |   DATA IN                                         |
   +----------+---------------------------------------------------+

ROM-Reference:

 BIT $1800  : $E8D2 $E902
 CMP $1800  : $E9C3
 LDA $1800  : $E780 $E78E $E873 $E87B $E8DB $E99C $E9A5 $E9AE $E9B7 $E9C0
              $EA0B $EA5D $EA63 $EB3A $EBE8 $FF20
 STA $1800  : $E878 $E8E0 $E8FF $E9A1 $E9AA $E9B3 $E9BC $EA50 $EBDC $EBED
              $FF15


 $1801/6145/VIA1+1:   Data Port A (free for parallel cables)

   This port is mostly used for extensions using parallel data transfer.
   These lines are then connected to the Userport of a C64.

   See also $180F.

ROM-Reference:

 LDA $1801  : $E853


 $1802/6146/VIA1+2:   Data Direction Register B

   +----------+---------------------------------------------------+
   | Bit  x   |   1 = Pin PBx set to Output, 0 = Input            |
   +----------+---------------------------------------------------+

ROM-Reference:

 STA $1802  : $EBE1 $FF1A


 $1803/6147/VIA1+3:   Data Direction Register A

   +----------+---------------------------------------------------+
   | Bit  x   |   1 = Pin PAx set to Output, 0 = Input            |
   +----------+---------------------------------------------------+

ROM-Reference:

 STX $1803  : $FF10


 $1804/6148/VIA1+4:   Timer 1 Low-Byte (Timeout Errors)

ROM-Reference:

 LDA $1804  : $FB43 $FB64


 $1805/6149/VIA1+5:   Timer 1 High-Byte (Timeout Errors)

ROM-Reference:

 BIT $1805  : $F55D
 LDX $1805  : $EC81
 STA $1805  : $F558 $FB32 $FF29
 STX $1805  : $EC88


 $1806/6150/VIA1+6:   Timer 1-Latch Low-Byte (Timeout Errors)

ROM-Reference:

 STA $1806  : $FB2A


 $1807/6151/VIA1+7:   Timer 1-Latch High-Byte (Timeout Errors)

ROM-Reference:

 STA $1807  : $FB2F


 $1808/6152/VIA1+8:   Timer 2 Low-Byte (unused)


 $1809/6153/VIA1+9:   Timer 2 High-Byte (unused)


 $180A/6154/VIA1+10:   Shift Register


 $180B/6155/VIA1+11:   Auxiliary Control Register

   +----------+---------------------------------------------------------+
   | Bits 7-6 |   Timer 1 Control:                                      |
   |          |     00 = Timed Interrupt when Timer 1 is loaded, no PB7 |
   |          |     01 = Continuous Interrupts, no PB7                  |
   |          |     10 = Timed Interrupt when Timer 1 is loaded,        |
   |          |          one-shot on PB7                                |
   |          |     11 = Continuous Interrupts, square-wave on PB7      |
   | Bit  5   |   Timer 2 Control: 0 = Timed Interrupt                  |
   |          |                    1 = Count Pulses on PB6              |
   | Bits 4-2 |   Shift Register Control:                               |
   |          |     000 = Disabled                                      |
   |          |     001 = Shift in under control of Timer 2             |
   |          |     010 = Shift in under control of Phi2                |
   |          |     011 = Shift in under control of ext. Clock          |
   |          |     100 = Shift out free-running at Timer 2 rate        |
   |          |     101 = Shift out under control of Timer 2            |
   |          |     110 = Shift out under control of Phi2               |
   |          |     111 = Shift out under control of ext. Clock         |
   | Bit  1   |   1 = enable latching PB                                |
   | Bit  0   |   1 = enable latching PA                                |
   +----------+---------------------------------------------------------+

ROM-Reference:

 AND $180B  : $FBDA
 ORA $180B  : $FB22
 STA $180B  : $FB25 $FBDD


 $180C/6156/VIA1+12:   Peripheral Control Register

   +----------+-----------------------------------------------------+
   | Bits 7-5 |   CB2 Control:                                      |
   |          |     000 = Input negative active edge                |
   |          |     001 = Independent interrupt input negative edge |
   |          |     010 = Input positive active edge                |
   |          |     011 = Independent interrupt input positive edge |
   |          |     100 = Handshake output                          |
   |          |     101 = Pulse output                              |
   |          |     110 = Low output                                |
   |          |     111 = High output                               |
   | Bit  4   |   CB1 Interrupt Control: 0 = Negative active edge   |
   |          |                          1 = Positive active edge   |
   | Bit  3-1 |   CA2 Control: see Bits 7-5                         |
   | Bit  0   |   CA1 Interrupt Control: see Bit 4                  |
   +----------+-----------------------------------------------------+

   CA1 (Input): ATN IN (make Interrupt if ATN occurs)

ROM-Reference:

 STA $180C  : $EB2F


 $180D/6157/VIA1+13:   Interrupt Flag Register

   +-------+------------------------------------------------------+
   | Bit 7 |   1 = Interrupt occured                              |
   | Bit 6 |   Timer 1                                            |
   | Bit 5 |   Timer 2                                            |
   | Bit 4 |   CB1                                                |
   | Bit 3 |   CB2                                                |
   | Bit 2 |   Shift Register ($180A)                             |
   | Bit 1 |   CA1                                                |
   | Bit 0 |   CA2                                                |
   +-------+------------------------------------------------------+

ROM-Reference:

 LDA $180D  : $E9E2 $FB4B $FB6C $FE6C
 STA $180D  : $EB34


 $180E/6158/VIA1+14:   Interrupt Enable Register

   +-------+------------------------------------------------------+
   | Bit 7 |   On Read:  Always 1                                 |
   |       |   On Write: 1 = Set Int.-Flags, 0 = Clear Int-.Flags |
   | Bit 6 |   Timer 1                                            |
   | Bit 5 |   Timer 2                                            |
   | Bit 4 |   CB1                                                |
   | Bit 3 |   CB2                                                |
   | Bit 2 |   Shift Register                                     |
   | Bit 1 |   CA1                                                |
   | Bit 0 |   CA2                                                |
   +-------+------------------------------------------------------+

ROM-Reference:

 STA $180E  : $EB37


 $180F/6159/VIA1+15:   Data Port A* (no handshake)

   Same as $1801, except no handshake will be initiated.


 $1C00/7168/VIA2+0:   Data Port B (SYNC, Motors, Bit Rates, LED)

   +----------+---------------------------------------------------+
   | Bit  7   |   0 = SYNC found                                  |
   | Bits 6-5 |   Bit rates (*):                                  |
   |          |     00 = 250000 Bit/s    01 = 266667 Bit/s        |
   |          |     10 = 285714 Bit/s    11 = 307692 Bit/s        |
   | Bit  4   |   Write Protect Sense: 1 = On                     |
   | Bit  3   |   Drive LED: 1 = On                               |
   | Bit  2   |   Drive Motor: 1 = On                             |
   | Bit  1-0 |   Step motor for head movement:                   |
   |          |     Sequence 00/01/10/11/00... moves inwards      |
   |          |     Sequence 00/11/10/01/00... moves outwards     |
   +----------+---------------------------------------------------+
   (*) Usually used: %11 for Tracks  1-17
                     %10 for Tracks 18-24
                     %01 for Tracks 25-30
                     %00 for Tracks 31-35

ROM-Reference:

 AND $1C00  : $C103
 BIT $1C00  : $F562 $FB39 $FB3E $FB46 $FB67
 EOR $1C00  : $D6AE
 LDA $1C00  : $EA86 $EB25 $EC3F $EC77 $F355 $F380 $F57A $F982 $F9A2 $F9E8
              $FA6E $FADB $FB00 $FBBB
 LDX $1C00  : $FA34 $FA65
 ORA $1C00  : $C11B $C13C $D6C8 $EA77
 STA $1C00  : $C113 $C11E $C13F $D6B1 $D6CB $EA8B $EB2A $EC98 $F260 $F35C
              $F385 $F987 $F9ED $FA75 $FAE0 $FEEA


 $1C01/7169/VIA2+1:   Data Port A (Data to/from head)

ROM-Reference:

 EOR $1C01  : $F6AB $F6B8
 LDA $1C01  : $F3C1 $F3CB $F4D7 $F4E4 $F540 $F567 $FD43 $FD6A $FD7A
 STA $1C01  : $F5A7 $F5B9 $F5C4 $FB14 $FCB3 $FCC8 $FCD6 $FCE3 $FCF1 $FCFE
              $FD0C $FDB2 $FE1F


 $1C02/7170/VIA2+2:   Data Direction Register B

   +----------+---------------------------------------------------+
   | Bit  x   |   1 = Pin PBx set to Output, 0 = Input            |
   +----------+---------------------------------------------------+

ROM-Reference:

 STA $1C02  : $F25B $FEED


 $1C03/7171/VIA2+3:   Data Direction Register A

   +----------+---------------------------------------------------+
   | Bit  x   |   1 = Pin PAx set to Output, 0 = Input            |
   +----------+---------------------------------------------------+

ROM-Reference:

 STA $1C03  : $F596 $F5D6 $FDAF $FE0A $FE1A


 $1C04/7172/VIA2+4:   Timer 1 Low-Byte (IRQ Timer)

ROM-Reference:

 LDA $1C04  : $F2B3


 $1C05/7173/VIA2+5:   Timer 1 High-Byte (IRQ Timer)

ROM-Reference:

 STA $1C05  : $F27E $F99F $FA81 $FAAB


 $1C06/7174/VIA2+6:   Timer 1-Latch Low-Byte (IRQ Timer)

ROM-Reference:

 STA $1C06  : $F276


 $1C07/7175/VIA2+7:   Timer 1-Latch High-Byte (IRQ Timer)

ROM-Reference:

 LDA $1C07  : $F99C $FA7C $FAA5
 STA $1C07  : $F27B


 $1C08/7176/VIA2+8:   Timer 2 Low-Byte (unused)


 $1C09/7177/VIA2+9:   Timer 2 High-Byte (unused)


 $1C0A/7178/VIA2+10:   Shift Register


 $1C0B/7179/VIA2+11:   Auxiliary Control Register

   +----------+---------------------------------------------------------+
   | Bits 7-6 |   Timer 1 Control:                                      |
   |          |     00 = Timed Interrupt when Timer 1 is loaded, no PB7 |
   |          |     01 = Continuous Interrupts, no PB7                  |
   |          |     10 = Timed Interrupt when Timer 1 is loaded,        |
   |          |          one-shot on PB7                                |
   |          |     11 = Continuous Interrupts, square-wave on PB7      |
   | Bit  5   |   Timer 2 Control: 0 = Timed Interrupt                  |
   |          |                    1 = Count Pulses on PB6              |
   | Bits 4-2 |   Shift Register Control:                               |
   |          |     000 = Disabled                                      |
   |          |     001 = Shift in under control of Timer 2             |
   |          |     010 = Shift in under control of Phi2                |
   |          |     011 = Shift in under control of ext. Clock          |
   |          |     100 = Shift out free-running at Timer 2 rate        |
   |          |     101 = Shift out under control of Timer 2            |
   |          |     110 = Shift out under control of Phi2               |
   |          |     111 = Shift out under control of ext. Clock         |
   | Bit  1   |   1 = enable latching PB                                |
   | Bit  0   |   1 = enable latching PA                                |
   +----------+---------------------------------------------------------+

ROM-Reference:

 STA $1C0B  : $F271


 $1C0C/7180/VIA2+12:   Peripheral Control Register

   +----------+-----------------------------------------------------+
   | Bits 7-5 |   CB2 Control:                                      |
   |          |     000 = Input negative active edge                |
   |          |     001 = Independent interrupt input negative edge |
   |          |     010 = Input positive active edge                |
   |          |     011 = Independent interrupt input positive edge |
   |          |     100 = Handshake output                          |
   |          |     101 = Pulse output                              |
   |          |     110 = Low output                                |
   |          |     111 = High output                               |
   | Bit  4   |   CB1 Interrupt Control: 0 = Negative active edge   |
   |          |                          1 = Positive active edge   |
   | Bit  3-1 |   CA2 Control: see Bits 7-5                         |
   | Bit  0   |   CA1 Interrupt Control: see Bit 4                  |
   +----------+-----------------------------------------------------+

   CA1 (Input):  BYTE-READY
   CA2 (Output): SOE (High = activate BYTE-READY)
   CB2 (Output): Head Mode (Low = Write, High = Read)

ROM-Reference:

 LDA $1C0C  : $F263 $F2B6 $F599 $F5CC $FABE $FDA3 $FE00 $FE0E
 STA $1C0C  : $F26C $F2BB $F5A0 $F5D1 $FAC3 $FDAA $FE05 $FE15


 $1C0D/7181/VIA2+13:   Interrupt Flag Register

   +-------+------------------------------------------------------+
   | Bit 7 |   1 = Interrupt occured                              |
   | Bit 6 |   Timer 1                                            |
   | Bit 5 |   Timer 2                                            |
   | Bit 4 |   CB1                                                |
   | Bit 3 |   CB2                                                |
   | Bit 2 |   Shift Register                                     |
   | Bit 1 |   CA1                                                |
   | Bit 0 |   CA2                                                |
   +-------+------------------------------------------------------+

ROM-Reference:

 LDA $1C0D  : $FE76
 STA $1C0D  : $F288


 $1C0E/7182/VIA2+14:   Interrupt Enable Register

   +-------+------------------------------------------------------+
   | Bit 7 |   On Read:  Always 1                                 |
   |       |   On Write: 1 = Set Int.-Flags, 0 = Clear Int-.Flags |
   | Bit 6 |   Timer 1                                            |
   | Bit 5 |   Timer 2                                            |
   | Bit 4 |   CB1                                                |
   | Bit 3 |   CB2                                                |
   | Bit 2 |   Shift Register ($1C0A)                             |
   | Bit 1 |   CA1                                                |
   | Bit 0 |   CA2                                                |
   +-------+------------------------------------------------------+

ROM-Reference:

 STA $1C0E  : $F283 $F28B


 $1C0F/7183/VIA2+15:   Data Port A* (no handshake)

   Same as $1C01, except no handshake will be initiated.


  +------------------------------------------------------------------------
  |
  |      DISK-DRIVE 1541: ZEROPAGE AND EXTENDED ZEROPAGE
  |
  +------------------------------------------------------------------------
  |
  | Zeropage:
  |
  |   $00/0                 Command code for buffer 0
  |   $01/1                 Command code for buffer 1
  |   $02/2                 Command code for buffer 2
  |   $03/3                 Command code for buffer 3
  |   $04/4                 Command code for buffer 4
  |   $05/5                 Command code for buffer 5 (unused)
  |   $06-$07/6-7           Track and sector for buffer 0
  |   $08-$09/8-9           Track and sector for buffer 1
  |   $0A-$0B/10-11         Track and sector for buffer 2
  |   $0C-$0D/12-13         Track and sector for buffer 3
  |   $0E-$0F/14-15         Track and sector for buffer 4
  |   $10-$11/16-17         Track and sector for buffer 5 (unused)
  |   $12-$13/18-19         Disk ID, drive 0
  |   $14-$15/20-21         Unused (was: Disk ID, drive 1)
  |   $16-$17/22-23         Header block: ID
  |   $18/24                Header block: Track
  |   $19/25                Header block: Sector
  |   $1A/26                Header block: Parity
  |   $1B/27                Unused
  |   $1C/28                Flag for disk change, drive 0
  |   $1D/29                Unused (was: Flag for disk change, drive 1)
  |   $1E/30                Flag for write protect sense, drive 0
  |   $1F/31                Unused (was: Flag for write protect sense, drive 1)
  |   $20/32                Drive 0 status (disk and step motor)
  |   $21/33                Unused (was: Drive 1 status (disk and step motor))
  |   $22/34                Current track for drive 0
  |   $23/35                Flag for 1541 (0), 1540 (not 0)
  |   $24-$2B/36-43         Scratch pad of GCR conversion
  |   $2C-$2D/44-45         Unused
  |   $2E-$2F/46-47         Pointer for temporary storage
  |   $30-$31/48-49         Buffer pointer for disk controller
  |   $32/50                Pointer: active track
  |   $33/51                Pointer: active sector
  |   $34/52                Pointer to last converted byte
  |   $35/53                Not used (decode error, GCR)?
  |   $36/54                Byte counter for GCR/BIN conversion
  |   $37/55                Unused
  |   $38/56                Constant 7, ID mark for start of data block
  |   $39/57                Constant 8, ID mark for start of block header
  |   $3A/58                Parity for data buffer
  |   $3B-$3C/59-60         Unused
  |   $3D/61                Motor flag
  |   $3E/62                Active drive (FF, if not active)
  |   $3F/63                Buffer number for disk controller
  |   $40/64                Byte counter for GCR conversion
  |   $41/65                Number of next work in queue (0 - 5)
  |   $42/66                Destination track (to move R/W head to)
  |   $43/67                Number of sectors per track for formatting
  |   $44/68                Temp. work area; Scratch pad
  |   $45/69                Work code temp. storage
  |   $46/70                Unused
  |   $47/71                Data block ID char, default 07.
  |   $48/72                Counter for head movement
  |   $49/73                Stack pointer temp. storage [39]
  |   $4A/74                Step counter for head transport
  |   $4B/75                Temp. storage
  |   $4C/76                Last read sector
  |   $4D/77                Next sector
  |   $4E-$4F/78-79         Pointer to buffer for GCR->BIN conversion
  |   $50/80                Flag for GCR format (0=BIN, 1=GCR)
  |   $51/81                Current track number for formatting [FF]
  |   $52-$55/82-85         Storage for 4 BIN bytes for GCR coding
  |   $56-$5D/86-93         Storage for 5 GCR bytes
  |   $5E/94                Number of steps for head motor accel./decl. [04]
  |   $5F/95                Accelerating/decl. factor [04]
  |   $60-$61/96-97         Unused
  |   $62-$63/98-99         Pointer to routine for head movement [FA05]
  |   $64/100               Minimum number of steps [C8]
  |   $65-$66/101-102       UI vector [$EB22]
  |   $67/103               Flag: NMI
  |   $68/104               Flag for disk initialisation
  |   $69/105               Step size for sector division [0A]
  |   $6A/106               Number of read attempts [5]
  |   $6B-$6C/107-108       Pointer: Start of Jump table for U commands [FFEA]
  |   $6D-$6E/109-110       Pointer: Start of bitmap [0400]
  |   $6F-$70/111-112       Pointer to address for M & B commands
  |   $71/113               Temp. work area
  |   $72/114               Temp. work area [FF]
  |   $73/115               Temp. work area
  |   $74/116               Temp. work area
  |   $75-$76/117-118       Indirect pointer [0100]
  |   $77/119               Listener address (Device number + $20) [28]
  |   $78/120               Talker address (Device number + $40) [48]
  |   $79/121               Flag: Active listener
  |   $7A/122               Flag: Active talker
  |   $7B/123               Unused
  |   $7C/124               Flag for ATN from serial bus receiving
  |   $7D/125               Flag for ATN on serial bus active
  |   $7E/126               Last handled program
  |   $7F/127               Drive number (on 1541 always 00)
  |   $80/128               Current Track number
  |   $81/129               Current Sector number
  |   $82/130               Channel number (Logical index)
  |   $83/131               Secondary address
  |   $84/132               Original Secondary address [6F]
  |   $85/133               Current Data byte [3F]
  |   $86-$8A/134-138       Temp Results
  |   $8B-$8E/139-142       Work storage for division
  |   $8F-$93/143-147       Work storage
  |   $94-$95/148-149       Current buffer pointer
  |   $96-$97/150-151       Unused
  |   $98/152               Bit counter for Transmission
  |   $99-$9A/153-154       Pointer: Next byte in buffer 0 [0300]
  |   $9B-$9C/155-156       Pointer: Next byte in buffer 1 [0400]
  |   $9D-$9E/157-158       Pointer: Next byte in buffer 2 [0500]
  |   $9F-$A0/159-160       Pointer: Next byte in buffer 3 [0600]
  |   $A1-$A2/161-162       Pointer: Next byte in buffer 4 [0700]
  |   $A3-$A4/163-164       Pointer: Next byte in command buffer [0200]
  |   $A5-$A6/165-166       Pointer: Next byte in error message buffer [02D6]
  |   $A7-$AD/167-173       Table: Non-active channel numbers for each buffer
  |   $AE-$B4/174-180       Table:
  |   $B5-$BA/181-186       Table: Record # low , block # low
  |   $BB-$C0/187-192       Table: Record # high, block # high
  |   $C1-$C6/193-198       Write pointer for REL file
  |   $C7-$CC/199-204       Table: Record length for REL file
  |   $CD-$D2/205-210       Table: Side sectors
  |   $D3/211               Pointer to first filename
  |   $D4/212               Pointer in record for REL file
  |   $D5/213               Side sector number
  |   $D6/214               Pointer to data block in side sector
  |   $D7/215               Pointer to record in REL file
  |   $D8-$DC/216-220       Directory sectors
  |   $DD-$E1/221-225       Index: Directory
  |   $E2-$E6/226-230       Default disk drive [00]
  |   $E7-$EB/231-235       File type (wild cards, @, closed)
  |   $EC-$F1/236-241       File type (channel)
  |   $F2-$F7/242-247       Channel status
  |   $F8/248               Flag for EOI
  |   $F9/249               Current work (Buffer number)
  |   $FA-$FE/250-254       Last used table
  |   $FF/255               Flag: Drive 0 not ready
  |
  | Extended Zeropage:
  |
  |   $0100/256             Flag: Drive 1 not ready
  |   $0101/257             Format marker, drive 0
  |   $0102/258             Format marker, drive 1
  |   $0103/259             Unused
  |   $0104-$0145/260-325   Stack area
  |   $0146-$01B9/326-441   Unused
  |   $01BA-$01FF/442-511   Buffer for GCR code
  |   $0200-$0229/512-553   Buffer for command string
  |   $022A/554             Command code
  |   $022B/555             Logical index, channel 0
  |   $022C/556             Logical index, channel 1
  |   $022D/557             Logical index, channel 2
  |   $022E-$0243/558-579   Last read/written byte for each channel
  |   $0244-$0249/580-585   Pointer: Last char on channel.
  |   $024A/586             Type of active file
  |   $024B/587             String length
  |   $024C/588             Temp. channel number (secondary address)
  |   $024D/589             Current work with drive number
  |   $024E/590             Work area to find the best sector
  |   $024F-$0250/591-592   Buffer allocated
  |   $0251/593             Flag: BAM changed, drive 0
  |   $0252/594             Flag: BAM changed, drive 1
  |   $0253/595             Flag for directory entry found
  |   $0254/596             Flag for directory output
  |   $0255/597             Flag: Waiting for command
  |   $0256/598             Bitmap of free channels
  |   $0257/599             Last used buffer
  |   $0258/600             Record length
  |   $0259/601             Track of side sector
  |   $025A/602             Sector of side sector
  |   $025B-$025F/603-607   Last work (buffers)
  |   $0260-$0265/608-613   Directory sector (buffers)
  |   $0266-$026B/614-619   File's index in directory (buffers)
  |   $026C/620             Counter for LED flash
  |   $026D/621             Error LED
  |   $026E/622             Drive for last program
  |   $026F/623             sector for last program
  |   $0270/624             Write LINDX
  |   $0271/625             Read LINDX
  |   $0272-$0273/626-627   Number of blocks (temp)
  |   $0274/628             Length of input line
  |   $0275/629             Char to interpret
  |   $0276/630             Index: End of filename in command buffer
  |   $0277/631             Temporary storage
  |   $0278/632             Temporary storage
  |   $0279/633             Temporary storage
  |   $027A-$027F/634-639   Pointer table: Filenames
  |   $0280-$0284/640-644   Track of a file
  |   $0285-$0289/645-649   Sector of a file
  |   $028A/650             Flag: wild cards
  |   $028B/651             Command syntax byte
  |   $028C/652             Number of drive(s) to look for
  |   $028D/653             Flag: Looking for drive
  |   $028E/654             drive with last write/open error, used as default
  |   $028F/655             Flag: Found in directory
  |   $0290/656             Directory sector
  |   $0291/657             Sector for first available file
  |   $0292/658             Index (in directory) for first available file
  |   $0293/659             For the last directory entry 0
  |   $0294/660             Current buffer-index
  |   $0295/661             Counter: Files
  |   $0296/662             Flag: Name matching wild cards
  |   $0297/663             Active operating mode (R or W)
  |   $0298/664             Flag: Work return
  |   $0299/665             Pointer: Re-read error
  |   $029A/666             Total tracks
  |   $029B-$029C/667-668   Pointer: BAM last update
  |   $029D-$02A0/669-672   BAM: image sector (drives 0 and 1)
  |   $02A1-$02B0/673-688   BAM image
  |   $02B1-$02D4/689-724   Buffer for directory output
  |   $02D5-$02F8/725-760   Buffer for error message
  |   $02F9/761             Flag: Don't write BAM
  |   $02FA-$02FB/762-763   Number of free blocks, low byte (drives 0 and 1)
  |   $02FC-$02FD/764-765   Number of free blocks, hi byte (drives 0 and 1)
  |   $02FE-$02FF/766-767   Stepper motor sequence
  |   $0300-$03FF/768-1023  Buffer 0
  |   $0400-$04FF/1024-1279 Buffer 1
  |   $0500-$05FF/1280-1535 Buffer 2
  |   $0600-$06FF/1536-1791 Buffer 3
  |   $0620/1568            Format: number of retries
  |   $0621+$0622/1569+1570 Format: expected track capacity
  |   $0623/1571            Format: number of read attempts
  |   $0624+$0625/1572+1573 Format: measured track capacity(?)
  |   $0626/1574            Format: temporary storage
  |   $0627/1575            Format: number of sectors/track
  |   $0628/1576            Format: current sector, verify counter
  |   $0700-$07FF/1792-2047 Buffer 4
  |   $07FF/2047            End of RAM
  |
  +------------------------------------------------------------------------


 $00/0:   Command code for buffer 0

ROM-Reference:

 CMP $00,X  : $EAB3 $EABC
 INC $00,X  : $EAB7
 LDA $00,X  : $D2A3 $D363 $D5A6 $D62B $D63F $D651 $D672 $D6B9 $EAC2
 LDA $00,Y  : $EC31 $F2C0 $F395 $F5DE
 STA $00,X  : $CBEC $D2A9 $D580 $D64F $D6B7 $EAAD
 STA $00,Y  : $F5E3 $F96B
 STY $00,X  : $EAC0



 $01/1:   Command code for buffer 1



 $02/2:   Command code for buffer 2



 $03/3:   Command code for buffer 3

ROM-Reference:

 LDA $03    : $C8E0
 STA $03    : $C8DE



 $04/4:   Command code for buffer 4



 $05/5:   Command code for buffer 5 (unused)



 $06-$07/6-7:   Track and sector for buffer 0

ROM-Reference:

 LDA $06,X  : $D519 $D556 $E610
 LDA $06,Y  : $DE45
 STA $06,X  : $F101
 STA $06,Y  : $D6D7

 LDA $07,X  : $D514 $D55A $E614
 LDA $07,Y  : $DE4A
 STA $07,X  : $F105
 STA $07,Y  : $D6DC



 $08-$09/8-9:   Track and sector for buffer 1



 $0A-$0B/10-11:   Track and sector for buffer 2



 $0C-$0D/12-13:   Track and sector for buffer 3



 $0E-$0F/14-15:   Track and sector for buffer 4



 $10-$11/16-17:   Track and sector for buffer 5 (unused)



 $12-$13/18-19:   Disk ID, drive 0

ROM-Reference:

 LDA $12,X  : $EE78 $F514 $FC59
 LDA $12,Y  : $F3F6
 STA $12    : $F412
 STA $12,X  : $D057 $EE2F

 LDA $13,X  : $EE7D $F518 $FC53
 LDA $13,Y  : $F3FD
 STA $13    : $F416
 STA $13,X  : $D05B $EE34



 $14-$15/20-21:   Unused (was: Disk ID, drive 1)



 $16-$17/22-23:   Header block: ID

ROM-Reference:

 CMP $16    : $F3F9
 EOR $16    : $F529
 EOR $16,Y  : $F3DC
 LDA $16    : $D055 $F410 $F957
 STA $16    : $F4C1 $F516

 CMP $17    : $F400
 EOR $17    : $F52B
 LDA $17    : $D059 $F414 $F953
 STA $17    : $F4BD $F51A



 $18/24:   Header block: Track

ROM-Reference:

 EOR $18    : $F52D
 LDA $18    : $F3E8 $F94C
 STA $18    : $F4AE $F520



 $19/25:   Header block: Sector

ROM-Reference:

 EOR $19    : $F52F
 LDA $19    : $F427 $F948
 STA $19    : $F4B2 $F525



 $1A/26:   Header block: Parity

ROM-Reference:

 LDA $1A    : $F944
 STA $1A    : $F4B6 $F531



 $1B/27:   Unused



 $1C/28:   Flag for disk change, drive 0

ROM-Reference:

 LDA $1C    : $EC51
 LSR $1C,X  : $C643
 STA $1C    : $EBB8 $F9AF
 STA $1C,X  : $D071



 $1D/29:   Unused (was: Flag for disk change, drive 1)

ROM-Reference:

 LDA $1D    : $EC62
 STA $1D    : $EBBA



 $1E/30:   Flag for write protect sense, drive 0

ROM-Reference:

 CMP $1E    : $F9A7
 STA $1E    : $F9A9



 $1F/31:   Unused (was: Flag for write protect sense, drive 1)



 $20/32:   Drive 0 status (disk and step motor)

   +-------+------------------------------------------------------+
   | Bit 7 | Disk drive ready: 1 = No, 0 = Yes                    |
   | Bit 6 | ReaD/Write head moving: 1 = Yes, 0= No               |
   | Bit 5 | Motor on: 1 = Yes, 0 = No                            |
   | Bit 4 | Switch off motor: 1 = Yes, 0 = No                    |
   +-------+------------------------------------------------------+

ROM-Reference:

 LDA $20    : $F2E9 $F991 $F9CF $FA52
 STA $20    : $F2FB $F317 $F37E $F980 $F995 $F9E2 $F9F6 $FA56
 STA $20,X  : $FACF



 $21/33:   Unused (was: Drive 1 status (disk and step motor))



 $22/34:   Current track for drive 0

ROM-Reference:

 LDA $22    : $F326
 STA $22    : $F31B $F38E
 STA $22,X  : $F3EA $FAD3



 $23/35:   Flag for 1541 (0), 1540 (not 0)

   Not used (track for drive 1)

ROM-Reference:

 LDA $23    : $E979
 STA $23    : $FF0D



 $24-$2B/36-43:   Scratch pad of GCR conversion

   Storage for BIN -> GCR conversions

ROM-Reference:

 CMP $24    : $F3C4
 CMP $24,Y  : $F543
 STA $24    : $F3B9

 STA $25,X  : $F3CE



 $2C-$2D/44-45:   Unused



 $2E-$2F/46-47:   Pointer for temporary storage

ROM-Reference:

 LDA ($2E),Y: $F7AB $F7B0 $F7B5 $F7C1 $F7C8 $F7CD $F7D2 $FE46 $FE4B $FE50
              $FE55
 STA $2E    : $F5F4 $F670 $F793 $F8E4 $FE34
 STA ($2E),Y: $F615 $F61A $F61F $F62B $F630 $F637 $F63C $F67A $F681 $F8FF
              $F904 $F909 $F915 $F91C $F921 $F926

 LDA $2F    : $F76B $F92F $F964
 STA $2F    : $F602 $F674 $F79F $F8F2 $F936 $FE3E



 $30-$31/48-49:   Buffer pointer for disk controller

   Pointer: Active buffer

Jump from $F379

ROM-Reference:

 CMP ($30),Y: $FD46
 EOR ($30),Y: $F5EC
 JMP ($0030): $F379
 LDA $30    : $F497 $FD4F
 LDA ($30),Y: $F5BF $F678 $F67F $F6B3 $F7E8 $F7F1 $F802 $F80D $F814 $F81F
              $F82B $F833 $F840 $F848 $F85A $F866 $FCFC
 STA $30    : $F377 $F49F $F4C7 $F5F6 $F791 $FD2E $FD53 $FE32
 STA ($30),Y: $F4DA $F645 $F64A $F656 $F65B $F660 $F665 $F688 $F6FB $F722
              $F735 $F766 $F779 $FDFA
 STY $30    : $F3AD

 LDA $31    : $F49A $F5FA $F672 $F79D $F8F0 $F934 $FE3C
 STA $31    : $F373 $F3A9 $F47A $F4A3 $F4C4 $F600 $F76D $F7A3 $F7FE $F856
              $F931 $F93A $F966 $FC90 $FCA0 $FD32 $FE42



 $32/50:   Pointer: active track

ROM-Reference:

 CMP ($32),Y: $FAF7
 LDA $32    : $FD12
 LDA ($32),Y: $F319 $F33E $F449 $F458 $F51E $F523
 LDY $32    : $FCC0
 SBC ($32),Y: $F32B
 STA $32    : $F3A3 $FCAC $FD17
 STA ($32),Y: $FAFB



 $33/51:   Pointer: active sector



 $34/52:   Pointer to last converted byte

ROM-Reference:

 LDY $34    : $F6D6 $F7E6
 STA $34    : $F4A7 $F606 $F799 $F8E2 $F93E $FE3A
 STY $34    : $F77C $F86D



 $35/53:   Not used (decode error, GCR)?



 $36/54:   Byte counter for GCR/BIN conversion

ROM-Reference:

 LDY $36    : $F611 $F627 $F652 $F7A9 $F7BF $F8FB $F911 $FE44
 STA $36    : $F608 $F795 $F8E6 $FE36
 STY $36    : $F622 $F63F $F64D $F668 $F7BA $F90C $FE5C



 $37/55:   Unused



 $38/56:   Constant 7, ID mark for start of data block

ROM-Reference:

 LDA $38    : $F4F0
 STA $38    : $F60F $F8F9



 $39/57:   Constant 8, ID mark for start of block header

ROM-Reference:

 LDA $39    : $F940 $FC3F
 STA $39    : $F296



 $3A/58:   Parity for data buffer

ROM-Reference:

 CMP $3A    : $F4FE
 LDA $3A    : $F7D9
 STA $3A    : $F578 $F69B $F92D $FCA5



 $3B-$3C/59-60:   Unused



 $3D/61:   Motor flag

   Disk drive number, on 1541 always 00

ROM-Reference:

 CMP $3D    : $F322
 LDA $3D    : $F2E2 $F510
 LDX $3D    : $F35F $FACB $FC3D
 STA $3D    : $F2D9



 $3E/62:   Active drive (FF, if not active)

ROM-Reference:

 CMP $3E    : $F2DB $F443
 LDA $3E    : $F3F2
 LDX $3E    : $F3E6 $F98F $F9CB
 STA $3E    : $F290 $F2E4 $F9F2



 $3F/63:   Buffer number for disk controller

   Previous work place in queue (0 - 5)

ROM-Reference:

 DEC $3F    : $F306 $F483
 LDA $3F    : $F335 $F36E $F475
 LDY $3F    : $F393 $F5DC $F969
 STX $3F    : $F436 $F48D
 STY $3F    : $F2D1 $F2FF



 $40/64:   Byte counter for GCR conversion

ROM-Reference:

 CMP $40    : $F44B
 STA $40    : $F340



 $41/65:   Number of next work in queue (0 - 5)

ROM-Reference:

 LDY $41    : $F30A
 STA $41    : $F337



 $42/66:   Destination track (to move R/W head to)

ROM-Reference:

 INC $42    : $F333
 LDA $42    : $F30F
 STA $42    : $F331



 $43/67:   Number of sectors per track for formatting

ROM-Reference:

 ADC $43    : $F45F $FC31
 CMP $43    : $F42C $FC80
 LDA $43    : $FD34
 LDX $43    : $FBE5
 SBC $43    : $F430 $FC1A
 STA $43    : $F34B



 $44/68:   Temp. work area; Scratch pad

ROM-Reference:

 ORA $44    : $F35A
 STA $44    : $F353 $F43F



 $45/69:   Work code temp. storage

ROM-Reference:

 LDA $45    : $F361 $F3EC $F44F $F466 $F492
 STA $45    : $F39D



 $46/70:   Unused



 $47/71:   Data block ID char, default 07.

   By changing this value, a data block can be written with different ID.
   The value must be less than 10.

ROM-Reference:

 CMP $47    : $F4F2
 LDA $47    : $F7A5
 STA $47    : $F29A



 $48/72:   Counter for head movement

   Timer: R/W head acceleration

ROM-Reference:

 DEC $48    : $F9D9
 STA $48    : $F98C $F999



 $49/73:   Stack pointer temp. storage [39]

ROM-Reference:

 LDX $49    : $F978
 STX $49    : $F2B1



 $4A/74:   Step counter for head transport

   Values 0 - 127 move the head outside and values over 128 move towards
   the centre.

ROM-Reference:

 ASL $4A    : $F313
 DEC $4A    : $FA63
 INC $4A    : $FA32
 LDA $4A    : $FA05 $FA2E $FA3B
 STA $4A    : $F311 $F38A $F9C1 $FAD9



 $4B/75:   Temp. storage

ROM-Reference:

 DEC $4B    : $F407
 ORA $4B    : $FA73
 STA $4B    : $FA6C
 STX $4B    : $F3B3



 $4C/76:   Last read sector

ROM-Reference:

 CMP $4C    : $F461
 STA $4C    : $F425 $F473



 $4D/77:   Next sector

ROM-Reference:

 SBC $4D    : $F45A
 STA $4D    : $F432



 $4E-$4F/78-79:   Pointer to buffer for GCR->BIN conversion

ROM-Reference:

 LDA $4E    : $F7FC $F854
 STA $4E    : $F5FC $F8EA

 LDY $4F    : $F800 $F858
 STA $4F    : $F5F8 $F8EE



 $50/80:   Flag for GCR format (0=BIN, 1=GCR)

ROM-Reference:

 LDA $50    : $F96E
 STA $50    : $F79B $FD9C
 STX $50    : $F68E
 STY $50    : $FDE0



 $51/81:   Current track number for formatting [FF]

ROM-Reference:

 INC $51    : $FD8B
 LDA $51    : $FAC7 $FC4D $FD8D
 STA $51    : $F292 $FAD5 $FD98
 STY $51    : $FDDD



 $52-$55/82-85:   Storage for 4 BIN bytes for GCR coding

ROM-Reference:

 LDA $52    : $F4BB $F60D $F629 $F654 $F6D8 $F6E9 $F8F7 $F913
 STA $52    : $F7A7 $F7C3 $F879 $F942 $F955 $FE48

 LDA $53    : $F4B4 $F4BF $F613 $F62E $F659 $F6FE $F70F $F8FD $F91A $F92B
 STA $53    : $F7AD $F7CA $F7DB $F885 $F946 $F959 $FE4D

 LDA $54    : $F4B0 $F618 $F635 $F643 $F65E $F725 $F73D $F902 $F91F
 STA $54    : $F7B2 $F7CF $F7DF $F891 $F94A $F95D $FE52

 LDA $55    : $F4AC $F61D $F63A $F648 $F663 $F74D $F76F $F907 $F924
 STA $55    : $F7B7 $F7D4 $F7E1 $F89D $F94E $F95F $FE57



 $56-$5D/86-93:   Storage for 5 GCR bytes

ROM-Reference:

 LDX $56    : $F86F
 ORA $56    : $F6F9
 STA $56    : $F6E7 $F7EF

 LDX $57    : $F874
 ORA $57    : $F70B $F720 $F809
 ROR $57    : $F6F2 $F6F5
 STA $57    : $F6D2 $F70D $F7F7 $F80B

 LDX $58    : $F87B
 ORA $58    : $F733
 STA $58    : $F71B $F812

 LDX $59    : $F880
 ORA $59    : $F749 $F764 $F827
 STA $59    : $F73B $F74B $F81C $F829

 LDX $5A    : $F887
 ORA $5A    : $F777 $F83C
 ROR $5A    : $F75A $F75D $F760
 STA $5A    : $F6D4 $F830 $F83E

 LDX $5B    : $F88C
 STA $5B    : $F846

 LDX $5C    : $F893
 ORA $5C    : $F862
 STA $5C    : $F84F $F864

 LDX $5D    : $F898
 STA $5D    : $F86A



 $5E/94:   Number of steps for head motor accelerating/decl. [04]

ROM-Reference:

 LDA $5E    : $FA22 $FA88
 SBC $5E    : $FA1C $FA1E
 STA $5E    : $F2AA



 $5F/95:   Accelerating/decl. factor [04]

ROM-Reference:

 ADC $5F    : $FAA9
 SBC $5F    : $FA7F
 STA $5F    : $F2AE



 $60-$61/96-97:   Unused

ROM-Reference:

 DEC $60    : $FA4E $FA84 $FAAE
 STA $60    : $FA24 $FA49 $FA8A $FABC

 DEC $61    : $FA97
 STA $61    : $FA20



 $62-$63/98-99:   Pointer to routine for head movement [FA05]

Jump from $FA02

ROM-Reference:

 JMP ($0062): $FA02
 STA $62    : $F29E $FA14 $FA28 $FA41 $FA5A $FA8E $FA9D $FAB4

 STA $63    : $F2A2 $FA18 $FA2C $FA45 $FA5E $FA92 $FAA1 $FAB8



 $64/100:   Minimum number of steps [C8]

ROM-Reference:

 CMP $64    : $FA0E
 STA $64    : $F2A6



 $65-$66/101-102:   UI vector [$EB22]

Jump from $FEE7

ROM-Reference:

 JMP ($0065): $FEE7
 STA $65    : $EBC7

 STA $66    : $EBCB



 $67/103:   Flag: NMI

ROM-Reference:

 STA $67    : $EBFA



 $68/104:   Flag for disk initialisation

   Automatic disk initialisation if ID MISMATCH occurred (1 = no, 0 = yes)

ROM-Reference:

 LDA $68    : $C63D



 $69/105:   Step size for sector division [0A]

   Sector number interleave for SEQ files, default 10 ($0A)

ROM-Reference:

 ADC $69    : $F176
 LDA $69    : $D494
 STA $69    : $D499 $D49F $EBCF



 $6A/106:   Number of read attempts [5]

ROM-Reference:

 BIT $6A    : $D5F4 $D631
 LDA $6A    : $D6A6
 STA $6A    : $EBD3



 $6B-$6C/107-108:   Pointer: Start of Jump table for U commands [FFEA]

ROM-Reference:

 LDA ($6B),Y: $CB78 $CB7D
 STA $6B    : $CB65

 STA $6C    : $CB69



 $6D-$6E/109-110:   Pointer: Start of bitmap [0400]

ROM-Reference:

 ADC ($6D),Y: $D07E
 LDA ($6D),Y: $EF65 $EF72 $EF98 $EFA4 $EFE3 $F136 $F1C7 $F1E2 $F22D $F23C
 STA $6D    : $EF26 $EF4A $F04A
 STA ($6D),Y: $EE8F $EEAA $EEBE $EEC2 $EED5 $EEE5 $EF6A $EF76 $EF9D $EFA9
              $F00B

 STA $6E    : $EF46 $F050



 $6F-$70/111-112:   Pointer to address for M & B commands

Jump from $C191, $CB1D, $CC5A, $CDBA

ROM-Reference:

 ADC $6F    : $CB33 $D1CC $EFDB
 ASL $6F    : $C3E4 $C3E6 $C3EB
 BIT $6F    : $CE96 $CEA9
 CMP $6F    : $F23E
 DEC $6F    : $D206 $D21A $F156 $F16D
 INC $6F    : $CB35 $EAC9 $EAEE $F234
 INC $6F,X  : $EC29 $EC39
 JMP ($006F): $C191 $CB1D $CC5A $CDBA
 LDA $6F    : $CB3A $CBBF $CBCD $CCBD $CE5A $D339 $D4D3 $EC4D $F011 $F12D
              $F220
 LDA $6F,X  : $EEE3
 LDA ($6F),Y: $CB20 $DEB9
 LDX $6F    : $D36B $EA71 $F05B
 LDY $6F    : $D373 $EF6F $EFA2
 LDY $6F,X  : $CCD5
 LSR $6F    : $CE50
 ORA $6F    : $C3D6 $C55E $C566
 ROL $6F    : $CBB8 $EEDA
 SBC $6F    : $CEC8
 STA $6F    : $C18A $C3CC $C3DB $C553 $C560 $C7C2 $CB02 $CBB3 $CC58 $CCA3
              $CCC2 $CDAB $CE4E $CE73 $D1C6 $D1E4 $D37B $D492 $D4C8 $DEA8
              $DEC9 $EC0E $EEC9 $EFD3 $F025 $F058 $F123 $F134 $F20B $F225
              $F243
 STA ($6F),Y: $CB53 $DECC
 STX $6F    : $D35E

 ADC $70    : $DF5D
 ASL $70    : $FB9E
 BIT $70    : $DFB4
 CMP $70    : $DDDD $E399
 LDA $70    : $CB3E $CBC6 $CBD5 $CCB9 $DB4D $EC5E $F014 $F03E $F07A $FBA3
 LDX $70    : $E388 $F090
 ROL $70    : $CBBA $EEDC
 STA $70    : $C18F $CB07 $CBB5 $CC53 $CCA5 $CCBF $CDB2 $DB3D $DDD4 $DEAF
              $DEC5 $DF5F $DFB0 $EC10 $EECB $F029 $F055 $F06B $FB82
 STX $70    : $E37C $F034



 $71/113:   Temp. work area

ROM-Reference:

 INC $71    : $DF63
 LDA $71    : $DB51 $E384 $FBAB
 LDA ($71),Y: $D503
 LDX $71    : $DDC2
 LDY $71    : $DC0F
 ROL $71    : $EEDE $FBA0
 SBC $71    : $FB7F
 STA $71    : $CCBB $D4F6 $DB3F $DEAA $EECD $FB88
 STA ($71),Y: $DEBB
 STX $71    : $DDB9 $DDCA $E37E $FB5C
 STY $71    : $DBF0



 $72/114:   Temp. work area [FF]

ROM-Reference:

 DEC $72    : $EC2B
 INC $72    : $CCE0
 LDA $72    : $CCE8 $DF54
 LDX $72    : $EC12
 SBC $72    : $FB85
 STA $72    : $CCA7 $D4FF $DB46 $DEB4 $E372 $EC0A
 STY $72    : $FB5E



 $73/115:   Temp. work area

ROM-Reference:

 INC $73    : $DB39
 LDA $73    : $DF5A
 STA $73    : $E378
 STX $73    : $DB37



 $74/116:   Temp. work area



 $75-$76/117-118:   Indirect pointer [0100]

Jump from $CB81

ROM-Reference:

 ADC ($75),Y: $EAD7
 CMP ($75),Y: $EB09
 EOR ($75),Y: $EB11
 JMP ($0075): $CB81
 STA $75    : $CB7A $EACF
 STA ($75),Y: $EAF6 $EB0F $EB13

 ADC $76    : $EAF4 $EB07
 CMP $76    : $EAE2
 DEC $76    : $EAD5 $EB02
 INC $76    : $EAFB
 STA $76    : $CB7F $EAEC
 STX $76    : $EACB



 $77/119:   Listener address (Device number + $20) [28]

ROM-Reference:

 CMP $77    : $E8A9
 STA $77    : $EB49



 $78/120:   Talker address (Device number + $40) [48]

ROM-Reference:

 CMP $78    : $E89B
 STA $78    : $EB45



 $79/121:   Flag: Active listener

ROM-Reference:

 LDA $79    : $E668 $E8E3
 STA $79    : $E860 $E88D $E8A5 $E8AF



 $7A/122:   Flag: Active talker

ROM-Reference:

 LDA $7A    : $E66C $E8ED
 STA $7A    : $E862 $E897 $E8A1 $E8B3



 $7B/123:   Unused



 $7C/124:   Flag for ATN from serial bus receiving

   ATN interrupt

ROM-Reference:

 LDA $7C    : $EC00
 STA $7C    : $E858 $E85E



 $7D/125:   Flag for ATN on serial bus active

ROM-Reference:

 LDA $7D    : $EA59
 STA $7D    : $E86B $E8D9



 $7E/126:   Last handled program

ROM-Reference:

 LDA $7E    : $D7CB
 STA $7E    : $D9FA



 $7F/127:   Drive number (on 1541 always 00)

ROM-Reference:

 CMP $7F    : $D32D
 INC $7F    : $EC5C
 LDA $7F    : $C107 $C1AD $C38F $C4EC $C8DA $CBEA $D2A7 $D5C8 $D5ED $D6DF
              $D7AF $D80E $D9FC $DAB2 $DE86 $EC45 $ECB7 $EE20 $EF0F $F060
              $F0D1
 LDX $7F    : $C641 $C65F $C669 $C7C4 $D04B $D06A $D091 $EE49 $EE6D $EF4D
              $EF88 $F017 $F040 $F111
 LDY $7F    : $D695 $EEFF
 ORA $7F    : $C56E $D466 $D58C $D63A $D64D $D661 $D7E9 $DC3B $DC53 $DCEF
              $DF2D
 STA $7F    : $C14E $C38A $C395 $C402 $C944 $C9AE $CA01 $CAA3 $CB87 $CDFC
              $D1DC $D5D0 $D66E $D6FF $D7D4 $D823 $D9E7 $DBBC $DF2A $E22C
              $EC4B $EC6F $EE1B $EEFD



 $80/128:   Current Track number

ROM-Reference:

 CMP $80    : $E2D7
 DEC $80    : $F15F
 INC $80    : $CD1E $EF2B $F143
 LDA $80    : $C8A3 $CD20 $CF31 $D0B2 $D1AE $D4A6 $D55F $D6D5 $D6ED $D921
              $D9F8 $DC5C $DD20 $DD4B $DD5D $DE00 $E06E $E2B0 $E3DA $E3E6
              $E48A $E4C5 $E6E8 $EDFD $EF1D $EF2D $EF78 $EFAB $F02C $F074
              $F092 $F13A $F145 $F17A $F202
 STA $80    : $C5B8 $C607 $C84B $C861 $C874 $C89C $CA06 $CE06 $CF43 $CF61
              $CF6A $D0A7 $D179 $D558 $D7CF $D805 $D9C9 $DBC1 $DBEE $DBFC
              $DE11 $DE48 $DE9D $DF34 $E2C6 $E405 $E612 $E7CC $EDA3 $EDC1
              $EDCF $EDF6 $EE3B $EE94 $EF22 $EF35 $F1BE $F1D1
 STX $80    : $D038 $F150 $F167
 STY $80    : $C1A1 $C1CA $DC88 $E6C3



 $81/129:   Current Sector number

ROM-Reference:

 CMP $81    : $CD0F $D56B $D71A $E2DF $F185
 DEC $81    : $EEAF $F193
 INC $81    : $F219
 LDA $81    : $C547 $C5EB $C637 $CD06 $CF34 $D1B3 $D4AB $D6DA $D6EA $D733
              $D926 $DA01 $DC60 $DD25 $DD50 $DD62 $DE05 $E3DD $E3E3 $E491
              $E4CA $E6F2 $EFD5 $EFDE $F173 $F18A $F20D
 LDX $81    : $DA37
 STA $81    : $C5BC $C60C $C850 $C866 $C8A1 $CA0A $CAA7 $CD1C $CE01 $CF3C
              $CF5E $CF67 $D0AC $D17E $D55C $D71E $D7DF $D809 $D9CE $DBB0
              $DBFF $DC16 $DE16 $DE4D $DEA2 $DF39 $E2CB $E402 $E616 $E7D1
              $ED9E $EDC6 $EDCC $EDFB $EE9B $F154 $F16B $F178 $F18F $F19F
              $F1EB
 STX $81    : $D033
 STY $81    : $C1A3 $C1CC $DC8D $E6C5



 $82/130:   Channel number (Logical index)

ROM-Reference:

 CMP $82    : $CF12
 LDA $82    : $C6D1 $D6E7 $D905
 LDX $82    : $CA3E $CBE2 $CE31 $CF0B $CF8C $D125 $D240 $D249 $D25A $D26B
              $D27C $D2DA $D3A4 $D3AA $D403 $D7EB $DA45 $DAAD $DB4B $DB62
              $DB80 $DBA5 $DC5A $DC81 $DC98 $DCAC $DCB6 $DCE8 $DD16 $DD2A
              $DD72 $DD8E $DD97 $DD9D $DDA6 $DE21 $DE78 $DEDE $DEFF $DF45
              $DF93 $DF9E $DFB7 $DFC2 $DFDC $DFE4 $DFED $DFF6 $E02D $E035
              $E15E $E16E $E185 $E195 $E1AC $E1E8 $E238 $E27D $E304 $E3A5
              $E45E $E4AC $E4B4 $E4D4 $E90F $E92F $E963 $ECAC $ED4E
 LDY $82    : $CBFB $CFD3 $D134 $D195 $D9D3 $E08D $E097 $E33E $ED18 $ED6F
 ORA $82    : $DA4D
 STA $82    : $C6D8 $CFDA $D102 $D11C $D1EC $D239 $D322 $D794 $DB0E $E67B
              $EC1D



 $83/131:   Secondary address

ROM-Reference:

 DEC $83    : $D30E $D334 $DAF3
 LDA $83    : $C6CE $CB89 $CFAF $D0EB $D107 $D227 $D3B4 $D3D3 $D6E4 $D7B4
              $D980 $D9EF $DAC5 $DADB $DBAA
 LDX $83    : $CBF1 $D1EE $D22E $D317 $DA4F $DB02 $E670
 LDY $83    : $DC6A $DCFD
 STA $83    : $C6DB $C6E0 $C989 $C9C1 $C9F5 $CA37 $CA61 $CB90 $CDE5 $D309
              $D315 $D47C $D488 $D4DC $D4E3 $D6F2 $D798 $D90C $D985 $D98E
              $DAEE $DC41 $E20D $E661 $E8C3 $ECA0
 STX $83    : $CF9D $D879



 $84/132:   Original Secondary address [6F]

ROM-Reference:

 LDA $84    : $C153 $CFB7 $E65D $E8C5 $EA39
 STA $84    : $E8BF



 $85/133:   Current Data byte [3F]

ROM-Reference:

 LDA $85    : $CFC4 $CFCE $CFE3 $D167 $D18F $D19A $D447 $E084 $E0B2 $E0E2
              $E159 $E81E $E848 $EA2B $ED20 $ED7B
 ROR $85    : $EA18
 STA $85    : $CA3C $CB22 $D15B $D423 $D436 $DFFF $E027 $E0E9 $E0FC $ED6D



 $86-$8A/134-138:   Temp Results

Jump from $E836

ROM-Reference:

 ADC $86    : $F1CF
 CMP $86    : $E731
 CMP ($86,X): $E718
 INC $86    : $C86B $E3F7 $E767 $E778 $F1D3
 LDA $86    : $C872 $E409 $E707 $E7EC $EC6D $F1B1
 LDA ($86),Y: $DBD8 $DBE5 $DBEC $DBF4 $DBF8 $DC14 $DC21
 LDA ($86,X): $E76D $E770
 SBC $86    : $E376 $F1BC
 STA $86    : $C82E $CA75 $DBD6 $E32E $E70F $E751 $E7B6 $E7F8 $EC47 $F1B6
              $F1E7
 STA ($86),Y: $DBE9 $DC09 $DC0C $DC11 $DC19 $DC27 $DC30 $DC35

 ADC $87    : $E84C
 CMP $87    : $E187 $E820
 DEC $87    : $E174
 INC $87    : $E76B $E77C
 LDA $87    : $E355 $E4E4 $E70A $E727
 LDY $87    : $E1B5
 SBC $87    : $E36B
 STA $87    : $CA71 $DBD1 $E172 $E17C $E1A2 $E32A $E48C $E713 $E74E $E7DA
              $E850

 DEC $88    : $E1C0 $E1C4
 INC $88    : $E38D
 JMP ($0088): $E836
 LDA $88    : $E3AF $E4E9 $E7F0 $E80C
 STA $88    : $CA79 $E180 $E332 $E493 $E7DF $E811 $E834
 STA ($88),Y: $E807

 INC $89    : $E815
 LDA $89    : $E7F3
 LDA ($89),Y: $E2C4 $E2C9 $E2D5 $E2DD
 LDY $89    : $E4E2
 STA $89    : $E29E $E482 $E7E7 $E831

 DEC $8A    : $E4DE $E4E0 $E817
 LDA $8A,X  : $CE7A
 LDY $8A    : $E4F3
 STA $8A    : $E2A2 $E488 $E7FD
 STA $8A,X  : $CE7F



 $8B-$8E/139-142:   Work storage for division

   Result, Multiply and divide

ROM-Reference:

 ADC $8B    : $CE61
 INC $8B    : $CECC
 LDA $8B    : $CE1F
 STA $8B    : $CE63 $CEDB

 INC $8C    : $CE67 $CED0
 STA $8C    : $CEDD

 INC $8D    : $CE6B $CED4
 STA $8D    : $CEDF

 LDA $8E,X  : $CEF0
 STA $8E,X  : $CEF4



 $8F-$93/143-147:   Work storage

ROM-Reference:

 ASL $8F    : $CE9A
 LDA $8F    : $CEB0
 LDA $8F,X  : $CE77
 LSR $8F    : $CE9D
 STA $8F,X  : $CE7C $CE8B

 ADC $90    : $CEB3
 LDA $90    : $CE14 $CE23 $CE3D $CE41 $CEC5
 LDA $90,X  : $CE89
 ROL $90    : $CEE6
 STA $90    : $CE35 $CE46 $CEB5 $CED6

 DEC $91    : $CE4A
 INC $91    : $CEB9
 ORA $91    : $CEC1
 ROL $91    : $CEE8
 STA $91    : $CE39

 INC $92    : $CEBD
 LDA $92    : $CEBF
 ROL $92    : $CEEA
 STA $92    : $CE2F $CE94

 ADC $93,X  : $CEF2



 $94-$95/148-149:   Current buffer pointer

   Pointer: Directory buffer (0204)

ROM-Reference:

 CMP ($94),Y: $C50D
 LDA $94    : $C5F0 $C62F $E29C
 LDA ($94),Y: $C515 $C52F $C54D $C572 $C578 $C584 $C5DF $C71F $C729 $C73F
              $C773 $C7DC $C7E5 $C83C $C847 $C84E $D919 $D97A $D9A2 $D9A8
              $D9AE $DE0F $DE14 $DED9 $DF32 $DF37 $DF6F $DF87 $E1B7 $E1DC
              $E1F3 $E1F8 $E471 $EDB4 $EDB8 $EDBD $EDC4 $EDDB
 STA $94    : $C68E $C7D8 $D1D0 $D4D7 $D4F3 $DE36 $DEDC $DF85 $E1D2
 STA ($94),Y: $C681 $C69A $C8B9 $D76F $D782 $D788 $D78E $D91D $D923 $D928
              $D97E $DE02 $DE07 $DE1E $DE28 $E2E9 $E2F6 $E424 $E42B $E47D
              $E48E $E495 $E49A $E49F $E4C7 $E4CC $E4E6 $E4EB $EE7A $EE7F
              $EE85 $EE8B
 STY $94    : $E1F1

 LDA $95    : $D41B $E2A0
 STA $95    : $C693 $C7D3 $D4D1 $D4EF $DE32 $DEE6



 $96-$97/150-151:   Unused



 $98/152:   Bit counter for Transmission

ROM-Reference:

 DEC $98    : $E983 $EA24
 STA $98    : $E95A $E9CB



 $99-$9A/153-154:   Pointer: Next byte in buffer 0 [0300]

ROM-Reference:

 DEC $99,X  : $D45A $ECE1 $ECE3 $ED37 $ED39
 INC $99,X  : $D002 $D14E $D153 $D3EC $E0A3 $E131 $F088 $F0C8
 LDA $99,X  : $D142 $D3E1 $D3F3 $D4F1 $E020 $E12A $E145
 LDA $99,Y  : $C68B $ED4B
 LDA ($99,X): $CD3F $D068 $D13F $D151 $D3EE $D456 $DFFD $E13B $F07F
 LDY $99,X  : $E088
 STA $99,X  : $CC11 $CDC7 $D066 $D0D9 $D14B $D1CE $D3EA $D454 $D4D5 $DEF5
              $EB51 $EB57 $EB61 $EB66 $EB6B $EB70 $ED14 $EE61 $F078 $F0B8
 STA $99,Y  : $D2B3 $DCBE $DCCB
 STA ($99,X): $D000 $E086 $F086 $F0C1

 LDA $9A,X  : $D4CF $D4ED $DE30
 LDA $9A,Y  : $C690
 STA $9A,X  : $D441 $DEF2



 $9B-$9C/155-156:   Pointer: Next byte in buffer 1 [0400]



 $9D-$9E/157-158:   Pointer: Next byte in buffer 2 [0500]



 $9F-$A0/159-160:   Pointer: Next byte in buffer 3 [0600]



 $A1-$A2/161-162:   Pointer: Next byte in buffer 4 [0700]



 $A3-$A4/163-164:   Pointer: Next byte in command buffer [0200]

ROM-Reference:

 LDA ($A3),Y: $C163 $C270 $C370 $C3AC
 LDY $A3    : $C2B3
 STA $A3    : $C2DF $DABD $E658
 STY $A3    : $C1A5



 $A5-$A6/165-166:   Pointer: Next byte in error message buffer [02D6]

ROM-Reference:

 DEC $A5    : $D42D
 INC $A5    : $E6FF
 STA $A5    : $CB3C
 STA ($A5),Y: $E6B8 $E6D6 $E6E5 $E6EF $E75B $E763
 STX $A5    : $E6CB

 STA $A6    : $CB40
 STX $A6    : $E6CF



 $A7-$AD/167-173:   Table: Non-active channel numbers for each buffer

ROM-Reference:

 LDA $A7,X  : $C886 $CF8E $D25C $D2DC $D2E5 $D340 $D34D $DCB8 $DF95 $DFA3
              $DFB9 $F0DF
 LDA $A7,Y  : $CC07
 LDX $A7,Y  : $D012
 LDY $A7,X  : $DFC6
 STA $A7,X  : $C8FD $CBE7 $CF92 $D265 $D2F0 $DFCA $E112 $E11D $E4BC $EB7E
 STA $A7,Y  : $D029 $D1FD $D217 $D377 $F0F9

 STA $AB    : $EB89

 STA $AC    : $EB8D

 STA $AD    : $EB91



 $AE-$B4/174-180:   Table:

ROM-Reference:

 LDA $AE,X  : $CF94 $D26D $DCC1 $DF99 $DFAE $DFBD
 STA $AE,X  : $CF98 $D276 $DCC5 $DFCD $EB80
 STA $AE,Y  : $D200 $D223

 STA $B4    : $EB93



 $B5-$BA/181-186:   Table: Record # low , block # low

ROM-Reference:

 DEC $B5,X  : $DB88
 INC $B5,X  : $D0E2 $DFDE
 LDA $B5,X  : $CE33 $DB64 $DB82 $DC2E
 STA $B5,X  : $DB4F $DCD0 $E231



 $BB-$C0/187-192:   Table: Record # high, block # high

ROM-Reference:

 DEC $BB,X  : $DB86
 INC $BB,X  : $D0E6 $DFE2
 LDA $BB,X  : $CE37 $DC33
 ORA $BB,X  : $DB66
 STA $BB,X  : $DB53 $DCD2 $E236



 $C1-$C6/193-198:   Write pointer for REL file

   Table: next record numbers

ROM-Reference:

 CMP $C1,X  : $DFEF
 CMP $C1,Y  : $E099
 LDA $C1,X  : $DE23 $DFE6 $DFF8 $E170 $E306
 LDA $C1,Y  : $E08F
 STA $C1,X  : $DC9C $DD79 $E031 $E037 $E2F1 $E301 $E3A7



 $C7-$CC/199-204:   Table: Record length for REL file

ROM-Reference:

 ADC $C7,X  : $E30C
 CMP $C7,X  : $E248
 LDA $C7,X  : $CE4C $E17E $E27F
 LDX $C7,Y  : $E340
 SBC $C7,X  : $DD77
 STA $C7,X  : $DC77 $DD0C



 $CD-$D2/205-210:   Table: Side sectors

ROM-Reference:

 LDA $CD,X  : $D27E $DD2C $DD90 $DE7A $DEE0 $DF01 $DF47 $E1EA $E460 $E4AE
 STA $CD,X  : $D287 $DC83 $DD18 $E4B6 $EB82
 STA $CD,Y  : $D203



 $D3/211:   Pointer to first filename

ROM-Reference:

 INC $D3    : $CDD4
 LDX $D3    : $C32D $CDD2 $CDF5
 STA $D3    : $C2EA
 STX $D3    : $C325



 $D4/212:   Pointer in record for REL file

ROM-Reference:

 LDA $D4    : $CE5E
 SBC $D4    : $E282
 STA $D4    : $CA7B $E253 $E336



 $D5/213:   Side sector number

ROM-Reference:

 CMP $D5    : $DF69 $E1E2 $E40B
 INC $D5    : $E34F
 LDA $D5    : $CA5C $CA73 $DF7B $E32C $E35D $E374
 LDX $D5    : $DB35
 STA $D5    : $CA80 $CE21 $E1CE $E1E6



 $D6/214:   Pointer to data block in side sector

ROM-Reference:

 CMP $D6    : $E412
 INC $D6    : $E349 $E34B
 LDA $D6    : $CA59 $CA6F $DB41 $DF12 $E328 $E368
 LDY $D6    : $DF6D
 STA $D6    : $CA83 $CE29 $E353
 STY $D6    : $E1FC



 $D7/215:   Pointer to record in REL file

ROM-Reference:

 ADC $D7    : $E28A $E345
 INC $D7    : $CE1B $CE1D
 LDA $D7    : $E278
 STA $D7    : $CA7D $CE16
 STA $D7,X  : $C300



 $D8-$DC/216-220:   Directory sectors

ROM-Reference:

 CMP $D8,X  : $DDE4
 LDA $D8    : $C968 $D92D
 LDA $D8,X  : $CA08 $D9D8
 STA $D8    : $D79D
 STA $D8,X  : $C549

 CMP $D9    : $C96A
 LDA $D9    : $CAA5

 STA $DC,X  : $C302



 $DD-$E1/221-225:   Index: Directory

ROM-Reference:

 CMP $DD,X  : $DDEB
 LDA $DD    : $C962 $D932
 LDA $DD,X  : $CA12 $D9DD
 STA $DD    : $D7A5
 STA $DD,X  : $C545

 CMP $DE    : $C964
 LDA $DE    : $CAAF

 STA $E1,X  : $C304



 $E2-$E6/226-230:   Default disk drive [00]

ROM-Reference:

 CMP $E2    : $CA91
 EOR $E2,X  : $C4EE
 LDA $E2    : $C3FE $C95C $C9AA $D6FB $D9E3 $EE10
 LDA $E2,X  : $C3E0 $C56A $C9FD $DDD9
 STA $E2    : $CA97 $D7B1 $D7D6 $DA6D
 STA $E2,X  : $C333 $C570

 CMP $E3    : $C95E
 LDA $E3    : $C940 $CA8B $CA9F
 STA $E3    : $CA8F

 STA $E6,X  : $C306



 $E7-$EB/231-235:   File type (wild cards, @, closed)

ROM-Reference:

 AND $E7,X  : $C564 $C85A
 BIT $E7    : $D8CF $D953
 LDA $E7    : $D896 $D8C6 $D8F5 $D95C
 LDA $E7,X  : $C4CE $C53B $C59D $CA1A
 STA $E7    : $D7AD $D7DA $DA7A
 STA $E7,X  : $C294 $C2AF $C568

 LDA $E8    : $CACC



 $EC-$F1/236-241:   File type (channel)

ROM-Reference:

 AND $EC,X  : $DDA1 $DDA8
 LDA $EC,X  : $D127 $DBB8 $DF26 $E228
 LDA $EC,Y  : $DDCF
 ORA $EC,X  : $DD99
 STA $EC,X  : $DAB9 $DC55 $DCF1 $DDA3
 STA $EC,Y  : $CC15 $D7ED



 $F2-$F7/242-247:   Channel status

ROM-Reference:

 LDA $F2,X  : $CA40 $D3BA $E911 $E931 $EA34
 STA $F2,X  : $D244 $D3C9 $D3D0 $DA49 $DCB3 $DCFA $E167 $E23C
 STA $F2,Y  : $CC04 $CD52 $D164 $D3FC $E142 $E14F $ED1D $ED78

 STA $F6    : $EBA6

 STA $F7    : $D445 $E703 $EBAA



 $F8/248:   Flag for EOI

ROM-Reference:

 LDA $F8    : $CFE8 $E0B7 $E0DD $E82C $E83C
 STA $F8    : $C9D0 $CA44 $E869 $EA09



 $F9/249:   Current work (Buffer number)

ROM-Reference:

 LDA $F9    : $CDC0 $D060 $D46B $D552 $DF3B $EE59 $F070 $F0B1
 LDX $F9    : $C7CE $CDAD $D470 $D57A $D58E $D701 $DF40 $EF41
 STA $F9    : $CDEF $D02F $DBC7 $DE41 $DF1B $DF21 $F10C
 STX $F9    : $D50F $E60B $F0F2



 $FA-$FE/250-254:   Last used table

ROM-Reference:

 LDA $FA,Y  : $CF0D
 LDX $FA,Y  : $D33E
 STA $FA,X  : $CEFD $CF06
 STX $FA,Y  : $CF10



 $FF/255:   Flag: Drive 0 not ready

   $FF = Not Ready (No disk), $00 = Ready

ROM-Reference:

 LDA $FF,X  : $C66B $F019
 STA $FF,X  : $C1B5 $C662 $D073



 $0100/256:   Flag: Drive 1 not ready

   $FF = Not Ready (No disk), $00 = Ready

ROM-Reference:

 CMP $0100,Y: $FD6D
 LDA $0100,X: $F685 $FCEE
 LDA $0100,Y: $F5B3 $F6A5
 STA $0100,Y: $F4E7



 $0101/257:   Format marker, drive 0

   DOS version (from track 18 sector 0)

ROM-Reference:

 LDA $0101  : $D530
 LDA $0101,X: $EE4B
 STA $0101,X: $D06C $EE72



 $0102/258:   Format marker, drive 1

   DOS version (from track 18 sector 0)

ROM-Reference:

 LDA $0102  : $D535



 $0103/259:   Unused



 $0104-$0145/260-325:   Stack area



 $0146-$01B9/326-441:   Unused



 $01BA-$01FF/442-511:   Buffer for GCR code

ROM-Reference:

 LDA $01BB,Y: $FDF7



 $0200-$0229/512-553:   Buffer for command string

ROM-Reference:

 CMP $0200,X: $C346
 LDA $0200  : $D8E1
 LDA $0200,X: $C352 $C50A $C522 $C697 $C6AD $C91C
 LDA $0200,Y: $C2BA $C2C2 $CC35 $CC7C $CCAB $D8B4 $DA0C $EE2C
 LDX $0200  : $D7BF
 STA $0200  : $DA7E $E79D
 STA $0200,Y: $C1C1

 CMP $0201,X: $C341
 LDA $0201  : $CAF8 $DA65 $E20A
 LDA $0201,Y: $EE31
 LDY $0201  : $CB5C
 STA $0201  : $DA81

 LDA $0202  : $CB0B $E22E $FF01

 LDA $0203  : $CAFF $E233

 LDA $0204  : $CB04 $E23E

 CPY $0205  : $CB56
 LDX $0205  : $CB2B

 LDA $0206,Y: $CB50



 $022A/554:   Command code

ROM-Reference:

 LDA $022A  : $CC4B $E62E
 LDX $022A  : $C184 $C257
 STA $022A  : $CC45 $DA57 $E637
 STX $022A  : $C17A $D7BC
 STY $022A  : $C2D4



 $022B/555:   Logical index, channel 0

   Possible values:

        $FF = Inactive
        $81 = Opened for Writing
        $41 = ReaD/Write
        $01 = Opened for Reading

ROM-Reference:

 LDA $022B,X: $CBF3 $D0FB $D110 $D230 $D319 $DB04 $DDBB $E672 $EC14
 LDA $022B,Y: $DC6C $DCFF
 STA $022B,X: $CBF8 $D1F5 $D23D $DA51 $EB76
 STA $022B,Y: $DC71 $DD06



 $022C/556:   Logical index, channel 1

   Possible values:

        $FF = Inactive
        $81 = Opened for Writing
        $41 = ReaD/Write
        $01 = Opened for Reading



 $022D/557:   Logical index, channel 2

   Possible values:

        $FF = Inactive
        $81 = Opened for Writing
        $41 = ReaD/Write
        $01 = Opened for Reading



 $022E-$0243/558-579:   Last read/written byte for each channel

ROM-Reference:

 STA $023A  : $EB9C

 STA $023B  : $EB97

 LDA $023C  : $C98B
 STA $023C  : $C993

 STA $023D  : $C98E

 LDA $023E,X: $D3A6 $E965
 STA $023E,X: $D405 $DAAF $DCAE $E162 $E969
 STA $023E,Y: $CC0A $CD68 $D3F0 $E13D

 STA $0243  : $D449 $E6DC



 $0244-$0249/580-585:   Pointer: Last char on channel.

   Points to the last character read/written in buffer.

ROM-Reference:

 CMP $0244,Y: $D144 $D3E3 $D3F5 $E12C $E147
 DEC $0244,X: $ED53
 LDA $0244,Y: $CD65 $D13A $D15D $ED71
 STA $0244,X: $DC62 $DCD6 $E197 $E1AE $ECB0 $ED50
 STA $0244,Y: $CBFF $CD4D $CD6D $D197 $E022

 STA $0249  : $CB37 $E6FC



 $024A/586:   Type of active file

ROM-Reference:

 CMP $024A  : $D8F9 $D960
 LDA $024A  : $D6F7 $D776 $D7AA $D887 $D891 $DC4E $DCEA
 STA $024A  : $C2E4 $CA1E $CAD0 $D477 $D744 $D88E $D89A $D8A4
 STX $024A  : $D85D
 STY $024A  : $DA26



 $024B/587:   String length

ROM-Reference:

 CMP $024B  : $C6BE
 INC $024B  : $C6B8
 SBC $024B  : $C677
 STA $024B  : $C6A8



 $024C/588:   Temp. channel number (secondary address)

ROM-Reference:

 LDA $024C  : $D7C2 $D7F7
 LDX $024C  : $D876
 STA $024C  : $D7B6



 $024D/589:   Current work with drive number

ROM-Reference:

 CMP $024D  : $D543
 LDA $024D  : $D593
 ORA $024D  : $D50B
 STA $024D  : $D0C9 $D468 $D516 $D57D $D590 $DE52 $DE59 $DE60 $DE67 $DE6E
              $DE75 $DF2F $F182



 $024E/590:   Work area to find the best sector

ROM-Reference:

 CMP $024E  : $F20F
 SBC $024E  : $F18C
 STA $024E  : $F17F $F207



 $024F-$0250/591-592:   Buffer allocated

ROM-Reference:

 AND $024F  : $CBC1
 LDA $024F,Y: $D2BC $D2C8
 ORA $024F  : $CBCF
 ROR $024F  : $D2FC
 STA $024F  : $C8F2 $CBD2 $EBAE
 STA $024F,Y: $D2CE

 AND $0250  : $CBC8
 ORA $0250  : $CBD7
 ROR $0250  : $D2F9
 STA $0250  : $CBDA $EBB3



 $0251/593:   Flag: BAM changed, drive 0

ROM-Reference:

 LDA $0251,Y: $EF01
 STA $0251,X: $D04F $EF8C
 STA $0251,Y: $EF09



 $0252/594:   Flag: BAM changed, drive 1



 $0253/595:   Flag for directory entry found

   $FF = Not found, $00 = Found

ROM-Reference:

 LDA $0253  : $C47E $C6E8
 LDX $0253  : $C4BD $C855 $DDD6
 STA $0253  : $C619
 STX $0253  : $C4DA $C538
 STY $0253  : $C5B2



 $0254/596:   Flag for directory output

ROM-Reference:

 LDA $0254  : $D409
 STA $0254  : $DACB $ED1A



 $0255/597:   Flag: Waiting for command

ROM-Reference:

 INC $0255  : $CFED
 LDA $0255  : $EBF0
 STA $0255  : $EBF7



 $0256/598:   Bitmap of free channels

   Bit = 1: Channel free
   Bit = 0: Channel used

ROM-Reference:

 AND $0256  : $D393
 BIT $0256  : $D383
 ORA $0256  : $D253
 STA $0256  : $C901 $D256 $D396 $EBA1



 $0257/599:   Last used buffer

ROM-Reference:

 LDX $0257  : $E10F $E11A $E4B9
 STA $0257  : $DFAB
 STX $0257  : $DFA0



 $0258/600:   Record length

ROM-Reference:

 CMP $0258  : $D9B9
 LDA $0258  : $C57D $D78B $DC74 $DD09 $DD45
 LDX $0258  : $D9B0
 STA $0258  : $C2E1 $C586 $C934 $CA23 $D8B7 $D9B3
 STX $0258  : $D857



 $0259/601:   Track of side sector

ROM-Reference:

 LDA $0259  : $D77F
 LDY $0259  : $DC85
 STA $0259  : $D9A4 $DD22



 $025A/602:   Sector of side sector

ROM-Reference:

 LDA $025A  : $D785
 LDY $025A  : $DC8A
 STA $025A  : $D9AA $DD27



 $025B-$025F/603-607:   Last work (buffers)

ROM-Reference:

 EOR $025B,X: $D703
 LDA $025B,X: $D1D7 $D328 $D506 $D5CB $D5E3 $D6B4 $DDAF $EC23 $EEF8
 STA $025B,X: $CBEE $D2AB $D582 $D5F1 $D63C $D663 $DE88 $ECB9



 $0260-$0265/608-613:   Directory sector (buffers)

ROM-Reference:

 LDA $0260,X: $DBAD
 LDA $0260,Y: $DDE1
 STA $0260,X: $D79F $D92F
 STA $0260,Y: $D9DA



 $0266-$026B/614-619:   File's index in directory (buffers)

ROM-Reference:

 LDA $0266,X: $DBB2
 LDA $0266,Y: $DDE8
 STA $0266,X: $D7A7 $D934
 STA $0266,Y: $D9DF



 $026C/620:   Counter for LED flash

   Error Message

ROM-Reference:

 DEC $026C  : $EC8B
 LDA $026C  : $C199 $DAE1 $DAF7 $E0CE
 LDX $026C  : $EC72
 STA $026C  : $C125 $C131 $C260 $C2F8 $E0C5 $E24E
 STX $026C  : $EC95



 $026D/621:   Error LED

ROM-Reference:

 EOR $026D  : $EC90
 LDA $026D  : $D6AB $D6C5
 STA $026D  : $C128 $C139 $D5D6



 $026E/622:   Drive for last program

ROM-Reference:

 LDA $026E  : $D7D1
 STA $026E  : $D9FE



 $026F/623:   sector for last program

ROM-Reference:

 LDA $026F  : $D7DC
 STA $026F  : $DA03



 $0270/624:   Write LINDX

ROM-Reference:

 LDX $0270  : $D92A $DC29
 STA $0270  : $D907
 STX $0270  : $DBA7



 $0271/625:   Read LINDX



 $0272-$0273/626-627:   Number of blocks (temp)

ROM-Reference:

 LDA $0272  : $E396 $ECCE $ECF7 $ED23
 STA $0272  : $C72B $EF52
 STX $0272  : $C7C6

 CMP $0273  : $E38F
 LDA $0273  : $ECFD $ED29
 STA $0273  : $C710 $C721 $C7CB $EF58



 $0274/628:   Length of input line

ROM-Reference:

 CPX $0274  : $C6C3
 CPY $0274  : $C26B $C378 $CC8C $CCC5 $EE27
 INC $0274  : $E798
 LDA $0274  : $C2A0 $CB24
 LDX $0274  : $CB92 $DA5C
 LDY $0274  : $C37D
 STY $0274  : $C2CB



 $0275/629:   Char to interpret

ROM-Reference:

 CMP $0275  : $C16D $C273
 STA $0275  : $C165 $C268



 $0276/630:   Index: End of filename in command buffer

ROM-Reference:

 CPX $0276  : $C51D $C6A0
 STX $0276  : $C6C8



 $0277/631:   Temporary storage

ROM-Reference:

 CPX $0277  : $C245 $CAD7 $D861 $D86A
 INC $0277  : $CC95 $DA6F
 LDA $0277  : $C22E $C39A
 LDX $0277  : $C9B6 $CCE5
 STA $0277  : $C2EF $C315
 STX $0277  : $C210



 $0278/632:   Temporary storage

ROM-Reference:

 CMP $0278  : $C39D
 CPX $0278  : $C336 $C9EE
 DEC $0278  : $C3A2
 INC $0278  : $DA72 $E795
 LDA $0278  : $C312 $C58E $C955 $E7AB
 LDX $0278  : $C3D2 $CAD3
 LDY $0278  : $C3A5
 STA $0278  : $C2F2 $C31A $E7B1 $E7C6
 STX $0278  : $C213 $C23A $D849



 $0279/633:   Temporary storage

ROM-Reference:

 DEC $0279  : $C594
 LDX $0279  : $C535 $C59A $C9EA $C9FA $CA0F $CA17 $D9C3 $D9D5
 LDY $0279  : $CC98
 STA $0279  : $C231 $C2EC $C31D $C591 $C973
 STA $0279,X: $C2FD
 STX $0279  : $C9B9
 STY $0279  : $CCCA $D96C



 $027A-$027F/634-639:   Pointer table: Filenames

ROM-Reference:

 INC $027A  : $DA75
 LDA $027A  : $D762
 LDA $027A,X: $C327 $C4FE
 LDA $027A,Y: $C3A8
 LDX $027A  : $C919 $CABB $EE63
 LDY $027A  : $C36D
 LDY $027A,X: $D8B1 $DA09
 STA $027A  : $C94E
 STA $027A,X: $C22B $C32F
 STX $027A  : $C1D3
 STY $027A  : $C1DF $C1FA $D840 $DA92

 LDA $027B  : $C94B
 LDY $027B  : $EE24
 STA $027B,X: $C288 $C2A3

 STA $027F,X: $C308



 $0280-$0284/640-644:   Track of a file

ROM-Reference:

 LDA $0280  : $D89D $D8BA $D8D9 $D940 $E7BB $E7C9
 LDA $0280,X: $C5A1 $C85E $CADC $CAEA $D9C6
 STA $0280  : $C93A $D751
 STA $0280,X: $C574 $CCEA

 STA $0281  : $C93D

 STA $0284,X: $C30B



 $0285-$0289/645-649:   Sector of a file

ROM-Reference:

 LDA $0285  : $CBE4 $E7CE
 LDA $0285,X: $C863 $CDD6 $CDF7 $D9CB
 LDX $0285  : $CBAA
 STA $0285  : $D758
 STA $0285,X: $C57A $CCEE

 LDA $0286  : $CDC4
 LDA $0286,X: $CE03

 LDA $0287,X: $CDFE



 $028A/650:   Flag: wild cards

ROM-Reference:

 INC $028A  : $C280
 LDA $028A  : $C216 $C23E $C28B $C2A6
 STA $028A  : $C225 $C296 $C2F5 $C53F
 STX $028A  : $C4DE



 $028B/651:   Command syntax byte

ROM-Reference:

 DEC $028B  : $C383
 EOR $028B  : $C24E
 LDA $028B  : $C254 $C912 $C928
 ORA $028B  : $C21D
 STA $028B  : $C20C $C220 $C251 $C36A



 $028C/652:   Number of drive(s) to look for

ROM-Reference:

 CMP $028C  : $C4F9
 DEC $028C  : $C45C $C4AF
 LDA $028C  : $C404
 STA $028C  : $C3F7 $C413 $C42F $C937



 $028D/653:   Flag: Looking for drive

ROM-Reference:

 DEC $028D  : $C6FC $C701
 LDA $028D  : $C6ED $C6F7
 STA $028D  : $C3CE $C464 $C494 $C713



 $028E/654:   drive with last write/open error, used as default drive

ROM-Reference:

 LDA $028E  : $C14B $CB84
 LDY $028E  : $C320
 STA $028E  : $C1AF $D825 $DAB4



 $028F/655:   Flag: Found in directory

ROM-Reference:

 LDA $028F  : $C478 $C485 $C4AA $C4C2
 STA $028F  : $C4A7 $C58B $C5A8



 $0290/656:   Directory sector

ROM-Reference:

 LDA $0290  : $C609
 STA $0290  : $C639



 $0291/657:   Sector for first available file

ROM-Reference:

 LDA $0291  : $C5E3 $D715 $D79A
 STA $0291  : $C5ED $C948 $D735
 STY $0291  : $C5AE



 $0292/658:   Index (in directory) for first available file

ROM-Reference:

 CPX $0292  : $C5FD
 LDA $0292  : $D73D $D7A2
 LDX $0292  : $C5F2
 STA $0292  : $C454 $C49F $C5F5 $D728 $D73A $ED94
 STX $0292  : $D70B



 $0293/659:   For the last directory entry 0

ROM-Reference:

 LDA $0293  : $C5C4
 STA $0293  : $C5BE $C5D4



 $0294/660:   Current buffer-index

ROM-Reference:

 LDA $0294  : $C542 $C611 $D911 $DBD3
 STA $0294  : $C631 $DBB5



 $0295/661:   Counter: Files

ROM-Reference:

 DEC $0295  : $C5DA
 LDA $0295  : $C61C
 STA $0295  : $C5CC



 $0296/662:   Flag: Name matching wild cards

ROM-Reference:

 CMP $0296  : $C4D2
 LDA $0296  : $C4C9
 STA $0296  : $C2E7 $C3B9 $D81E



 $0297/663:   Active operating mode (R or W)

ROM-Reference:

 LDA $0297  : $D8A7 $D94A $D993
 LDX $0297  : $D96F
 STA $0297  : $D8C1
 STX $0297  : $D85A $D87F
 STY $0297  : $DA19



 $0298/664:   Flag: Work return

ROM-Reference:

 BIT $0298  : $D5BA $D645
 STA $0298  : $C649 $D5A1



 $0299/665:   Pointer: Re-read error

ROM-Reference:

 INC $0299  : $D613
 LDY $0299  : $D600 $D61D
 STA $0299  : $D5FA



 $029A/666:   Total tracks

ROM-Reference:

 LDA $029A  : $D603 $D625
 STA $029A  : $D5FD $D60A



 $029B-$029C/667-668:   Pointer: BAM last update

ROM-Reference:

 ORA $029B,X: $F064
 STA $029B,X: $F042



 $029D-$02A0/669-672:   BAM: image sector (drives 0 and 1)

ROM-Reference:

 CMP $029D,X: $F02E $F036
 LDA $029D,Y: $F0A6
 STA $029D,X: $F094 $F0D7 $F0DB
 STA $029D,Y: $F0AE



 $02A1-$02B0/673-688:   BAM image

ROM-Reference:

 LDA $02A1,Y: $F0BE
 STA $02A1,Y: $F081 $F0C5

 STA $02B0,Y: $C7B0



 $02B1-$02D4/689-724:   Buffer for directory output

ROM-Reference:

 AND $02B1,X: $C79F
 LDA $02B1,X: $C788
 LDA $02B1,Y: $ED5B
 STA $02B1  : $C7F5
 STA $02B1,X: $C751 $C758 $C75F $C76D $C775 $C780 $C795 $C7A2
 STA $02B1,Y: $C80E

 STA $02B2  : $C7FA
 STA $02B2,X: $C747 $C768

 STA $02B3,Y: $C7ED

 STA $02C3  : $C7FD

 STA $02C4  : $C802



 $02D5-$02F8/725-760:   Buffer for error message

ROM-Reference:

 LDA $02D5  : $E6D9



 $02F9/761:   Flag: Don't write BAM

   This flag is reset to zero before and after each command.

ROM-Reference:

 BIT $02F9  : $EFF3
 LDA $02F9  : $C88C $F097
 ORA $02F9  : $F127 $F1AB
 STA $02F9  : $C148 $C196 $C891 $CD00 $D884 $DAC2 $E64D $ED8C $EDAA $EFFE
              $F0A1 $F12A $F1AE
 STA $02F9,Y: $FC77



 $02FA-$02FB/762-763:   Number of free blocks, low byte (drives 0 and 1)

ROM-Reference:

 DEC $02FA,X: $EFBA
 EOR $02FA,Y: $FC6B
 INC $02FA,X: $EF7F
 LDA $02FA,X: $EF4F $EFB2 $EFC2
 STA $02FA,X: $D097

 EOR $02FB,Y: $FC6E



 $02FC-$02FD/764-765:   Number of free blocks, hi byte (drives 0 and 1)

ROM-Reference:

 DEC $02FC,X: $EFB7
 EOR $02FC,Y: $FC71
 INC $02FC,X: $EF84
 LDA $02FC,X: $EF55 $EFBD
 STA $02FC,X: $D093

 EOR $02FD,Y: $FC74



 $02FE-$02FF/766-767:   Stepper motor sequence

ROM-Reference:

 CMP $02FE,Y: $D69A
 LDA $02FE  : $F9B1
 STA $02FE  : $F9BC $F9C5
 STA $02FE,Y: $D697 $D6A1



 $0300-$03FF/768-1023:   Buffer 0

ROM-Reference:

 LDA $0300  : $FDEE
 LDA $0300,Y: $FCC5 $FDE5
 STA $0300,Y: $FC41 $FC49 $FC4F $FC55 $FC5B $FC61 $FC65

 STA $0345  : $FDF1
 STA $0345,Y: $FDE8



 $0400-$04FF/1024-1279:   Buffer 1



 $0500-$05FF/1280-1535:   Buffer 2

ROM-Reference:

 CMP $0500,Y: $FD7D
 STA $0500,X: $FC88



 $0600-$06FF/1536-1791:   Buffer 3

ROM-Reference:

 STA $0600  : $C8C8

 STA $0601  : $C8CD

 STA $0602  : $C8D2



 $0620/1568:   Format: number of retries

ROM-Reference:

 DEC $0620  : $FDD3
 STA $0620  : $FAE5



 $0621+$0622/1569+1570:   Format: expected track capacity

ROM-Reference:

 ADC $0621  : $FBA5
 LDX $0621  : $FDC3
 STA $0621  : $FAEA $FBA8

 ADC $0622  : $FBAD
 LDY $0622  : $FDC6
 STA $0622  : $FAEF $FBB0



 $0623/1571:   Format: number of read attempts

ROM-Reference:

 DEC $0623  : $FD58
 STA $0623  : $FD29



 $0624+$0625/1572+1573:   Format: measured track capacity(?)

   $0624 is the high-byte and $0625 is the low-byte!

ROM-Reference:

 ADC $0624  : $FC0B
 DEC $0624  : $FC00
 STA $0624  : $FBD5

 ADC $0625  : $FBFB
 STA $0625  : $FBD0



 $0626/1574:   Format: temporary storage

   Number of additional bytes per sector
   Number of bytes per interval

ROM-Reference:

 ADC $0626  : $FBEB
 LDX $0626  : $FD06
 STA $0626  : $FBE2
 STX $0626  : $FC24



 $0627/1575:   Format: number of sectors/track

ROM-Reference:

 STA $0627  : $FC33



 $0628/1576:   Format: current sector, verify counter

ROM-Reference:

 DEC $0628  : $FD19 $FD86
 INC $0628  : $FC7A
 LDA $0628  : $FC46 $FC7D
 STA $0628  : $FC38 $FD36



 $0700-$07FF/1792-2047:   Buffer 4



 $07FF/2047:   End of RAM



  +------------------------------------------------------------------------
  |
  |      DISK-DRIVE 1541: ROM-LISTING
  |
  +------------------------------------------------------------------------
  |
  | ROM-Comments were done by Frank Kontros, used with permission.
  |
  |
  | File Manager Routines:
  |
  |   $C100/49408      Turn LED on for current drive
  |   $C118/49432      Turn LED on
  |   $C123/49443      Clear error flags
  |   $C12C/49452      Prepare for LED flash after error
  |   $C146/49478      Interpret command from computer
  |   $C194/49556      Prepare error msg after executing command
  |   $C1BD/49597      Erase input buffer
  |   $C1C8/49608      Output error msg (track and sector 0)
  |   $C1D1/49617      Check input line
  |   $C1E5/49637      Check ':' on input line
  |   $C1EE/49646      Check input line
  |   $C268/49768      Search character in input buffer
  |   $C2B3/49843      Check line length
  |   $C2DC/49884      Clear flags for command input
  |   $C312/49938      Preserve drive number
  |   $C33C/49980      Search for drive number
  |   $C368/50024      Get drive number
  |   $C38F/50063      Reverse drive number
  |   $C398/50072      Check given file type
  |   $C3BD/50109      Check given drive number
  |   $C3CA/50122      Verify drive number
  |   $C440/50240      Flags for drive check
  |   $C44F/50255      Search for file in directory
  |   $C48B/50315      ?
  |   $C4D8/50392      ?
  |   $C5AC/50604      ?
  |   $C63D/50749      Test and initalise drive
  |   $C66E/50798      Name of file in directory buffer
  |   $C688/50824      Copy filename to work buffer
  |   $C6A6/50854      Search for end of name in command
  |   $C6CE/50894      ?
  |   $C6DE/50910      ?
  |   $C7AC/51116      Clear Directory Output Buffer
  |   $C7B7/51127      Create header with disk name
  |   $C806/51206      Print 'blocks free.'
  |   $C817/51223      'Blocks free.'
  |   $C823/51235      Perform [S] - Scratch command
  |   $C87D/51325      Erase file
  |   $C8B6/51382      Erase dir entry
  |   $C8C1/51393      Perform [D] - Backup command (Unused)
  |   $C8C6/51398      Format disk
  |   $C8F0/51440      Perform [C] - Copy command
  |   $C9A1/51617      ?
  |   $C9A7/51623      ?
  |   $C9D5/51669      ?
  |   $C9FA/51706      ?
  |   $CA35/51765      ?
  |   $CA88/51848      Perform [R] - Rename command
  |   $CACC/51916      Check if file present
  |   $CAF8/51960      Perform [M] - Memory command
  |   $CB20/52000      M-R memory read
  |   $CB50/52048      M-W memory write
  |   $CB5C/52060      Perform [U] - User command
  |   $CB84/52100      Open direct access channel, number
  |   $CC1B/52251      Perform [B] - Block/Buffer command
  |   $CC5D/52317      Block commands "AFRWEP"
  |   $CC63/52323      Block command vectors
  |   $CC6F/52335      Get parameters form block commands
  |   $CCF2/52466      Decimal values  1, 10, 100
  |   $CCF5/52469      B-F block free
  |   $CCFE/52478      ?
  |   $CD03/52483      B-A block allocate
  |   $CD36/52534      Read block to buffer
  |   $CD3C/52540      Get byte from buffer
  |   $CD42/52546      Read block from disk
  |   $CD56/52566      B-R block read
  |   $CD5F/52575      U1, Block read without changing buffer pointer
  |   $CD73/52595      B-W block write
  |   $CD97/52631      U2, Block write without changing buffer pointer
  |   $CDA3/52643      B-E block execute
  |   $CDBD/52669      B-P block pointer
  |   $CDD2/52690      Open channel
  |   $CDF2/52722      Check buffer number and open channel
  |   $CE0E/52750      Set pointer for REL file
  |   $CE2C/52780      ?
  |   $CE6E/52846      Divide by 254
  |   $CE71/52849      Divide by 120
  |   $CED9/52953      Erase work storage
  |   $CEE2/52962      Left shift 3-byte register twice
  |   $CEE5/52965      Left shift 3-byte register once
  |   $CEED/52973      Add 3-byte registers
  |   $CEFA/52986      ?
  |   $CF09/53001      ?
  |   $CF1E/53022      ?
  |   $CF8C/53132      Change buffer
  |   $CF9B/53147      Write data in buffer
  |   $CFF1/53233      Write data byte in buffer
  |   $D005/53253      Perform [I] - Initalise command
  |   $D00E/53262      Read BAM from disk
  |   $D042/53314      Load BAM
  |   $D075/53365      Calculate blocks free
  |   $D09B/53403      ?
  |   $D0AF/53423      ?
  |   $D0C3/53443      Read block
  |   $D0C7/53447      Write block
  |   $D0EB/53483      Open channel for reading
  |   $D107/53511      Open channel for writing
  |   $D125/53541      Check for file type REL
  |   $D12F/53551      Get buffer and channel numbers
  |   $D137/53559      Get a byte from buffer
  |   $D156/53590      Get byte and read next block
  |   $D19D/53661      Write byte in buffer and block
  |   $D1C6/53702      Increment buffer pointer
  |   $D1D3/53715      Get drive number
  |   $D1DF/53727      Find write channel and buffer
  |   $D1E2/53730      Find read channel and buffer
  |   $D227/53799      Close channel
  |   $D25A/53850      Free buffer
  |   $D28E/53902      Find buffer
  |   $D2BA/53946      ?
  |   $D2DA/53978      ?
  |   $D307/54023      Close all channels
  |   $D313/54035      Close all channels of other drives
  |   $D339/54073      ?
  |   $D37F/54143      Find channel and allocate
  |   $D39B/54171      Get byte for output
  |   $D44D/54349      Read next block
  |   $D460/54368      Read block
  |   $D464/54372      Write block
  |   $D475/54389      Allocate buffer and read block
  |   $D486/54406      Allocate new block
  |   $D48D/54413      Write dir block
  |   $D4C8/54472      Set buffer pointer
  |   $D4DA/54490      Close internal channel
  |   $D4E8/54504      Set buffer pointer
  |   $D4F6/54518      Get byte from buffer
  |   $D506/54534      Check track and sector numbers
  |   $D552/54610      Get track and sector numbers for current job
  |   $D55F/54623      Check for vaild track and sector numbers
  |   $D572/54642      DOS mismatch error
  |   $D586/54662      Read block
  |   $D58A/54666      Write block
  |   $D599/54681      Verify execution
  |   $D5C6/54726      Additional attempts for read errors
  |   $D676/54902      Move head by half a track
  |   $D693/54931      Move head one track in or out
  |   $D6A6/54950      Attempt command execution multiple times
  |   $D6D0/54992      Transmit param to disk controller
  |   $D6E4/55012      Enter file in dir
  |   $D7B4/55220      OPEN command, secondary addr 15
  |   $D7C7/55239      -Check '*' Last file
  |   $D7F3/55283      -Check '$' Directory
  |   $D815/55317      -Check '#' Channel
  |   $D8F5/55541      Open a file with overwriting (@)
  |   $D940/55616      ?
  |   $D9A0/55712      Open file for reading
  |   $D9E3/55779      Open file for writing
  |   $DA09/55817      Check file type and control mode
  |   $DA2A/55850      Preparation for append
  |   $DA55/55893      Open directory
  |   $DAC0/56000      Close routine
  |   $DB02/56066      Close file
  |   $DB62/56162      Write last block
  |   $DBA5/56229      Directory entry
  |   $DC46/56390      Read block, allocate buffer
  |   $DCB6/56502      Reset pointer
  |   $DCDA/56538      Construct a new block
  |   $DD8D/56717      Write byte in side-sector block
  |   $DD95/56725      Manipulate flags
  |   $DDA6/56742      ?
  |   $DDAB/56747      Verify command code for writing
  |   $DDB7/56759      ?
  |   $DDF1/56817      Write a block of a REL file
  |   $DDFD/56829      Write bytes for following track
  |   $DE0C/56844      Get following track and sector numbers
  |   $DE19/56857      Following track for last block
  |   $DE2B/56875      buffer pointer to zero
  |   $DE3B/56891      Get track and sector
  |   $DE50/56912      Write
  |   $DE57/56919      Read
  |   $DE5E/56926      Write
  |   $DE65/56933      Read
  |   $DE6C/56940      Write
  |   $DE73/56947      Read
  |   $DE95/56981      Get following track and sector from buffer
  |   $DEA5/56997      Copy buffer contents
  |   $DEC1/57025      Erase buffer Y
  |   $DED2/57042      Get side-sector number
  |   $DEDC/57052      Set buffer pointer to side-sector
  |   $DEE9/57065      Buffer pointer for side-sector
  |   $DEF8/57080      Get side sector and buffer pointer
  |   $DF1B/57115      Read side-sector
  |   $DF21/57121      Write side-sector
  |   $DF45/57157      Set buffer pointer in side-sector
  |   $DF4C/57164      Calculate number of blocks in a REL file
  |   $DF66/57190      Verify side-sector in buffer
  |   $DF93/57235      Get buffer number
  |   $DF9E/57246      ?
  |   $DFB7/57271      ?
  |   $DFC2/57282      ?
  |   $DFD0/57296      Get next record iin REL file
  |   $E03C/57404      Write block and read next block
  |   $E07C/57468      Write a byte in a record
  |   $E0AB/57515      Write byte in REL file
  |   $E0F3/57587      Fill record with 0s
  |   $E105/57605      Write buffer number in table
  |   $E120/57632      Get byte from REL file
  |   $E1CB/57803      Get last side-sector
  |   $E207/57863      Perform [P] - Position command
  |   $E2E2/58082      Divide data blocks into records
  |   $E304/58116      Set pointer to next record
  |   $E31C/58140      Expand side-sector
  |   $E44E/58446      Write side-sector and allocate new
  |   $E4FC/58620      Table of Error Messages: 00,     Ok
  |   $E500/58624      Error Message: 20,21,22,23,24,27, Read error
  |   $E50B/58635      Error Message: 52, File too large
  |   $E517/58647      Error Message: 50, Record not present
  |   $E522/58658      Error Message: 51, Overflow in record
  |   $E52F/58671      Error Message: 25,28, Write error
  |   $E533/58675      Error Message: 26, Write protect on
  |   $E540/58688      Error Message: 29, Disk id mismatch
  |   $E546/58694      Error Message: 30,31,32,33,34, Syntax error
  |   $E552/58706      Error Message: 60, Write file open
  |   $E556/58710      Error Message: 63, File exists
  |   $E55F/58719      Error Message: 64, File type mismatch
  |   $E567/58727      Error Message: 65, No block
  |   $E570/58736      Error Message: 66,67, Illegal track or sector
  |   $E589/58761      Error Message: 61, File not open
  |   $E58D/58765      Error Message: 39,62, File not found
  |   $E592/58770      Error Message: 01, Files scratched
  |   $E59F/58783      Error Message: 70, No channel
  |   $E5AA/58794      Error Message: 71, Dir error
  |   $E5AF/58799      Error Message: 72, Disk full
  |   $E5B6/58806      Error Message: 73, Cbm dos v2.6 1541
  |   $E5C8/58824      Error Message: 74, Drive not ready
  |   $E5D5/58837      Indexed words: 09 Error
  |   $E5DB/58843      Indexed words: 0A Write
  |   $E5E1/58849      Indexed words: 03 File
  |   $E5E6/58854      Indexed words: 04 Open
  |   $E5EB/58859      Indexed words: 05 Mismatch
  |   $E5F4/58868      Indexed words: 06 Not
  |   $E5F8/58872      Indexed words: 07 Found
  |   $E5FE/58878      Indexed words: 08 Disk
  |   $E603/58883      Indexed words: 0B Record
  |   $E60A/58890      Prepare error number and message
  |   $E645/58949      Print error message into error buffer
  |   $E680/59008      TALK
  |   $E688/59016      LISTEN
  |   $E69B/59035      Convert BIN to 2-Ascii (error message buffer)
  |   $E6AB/59051      Convert BCD to 2-Ascii (error message buffer)
  |   $E6BC/59068      Write OK in buffer
  |   $E6C1/59073      Print error on track 00,00 to error buffer
  |   $E6C7/59079      Print error on current track to error buffer
  |   $E706/59142      Write error message string to buffer
  |   $E754/59220      Get character and in buffer
  |   $E767/59239      Get a char of the error message
  |   $E775/59253      Increment pointer
  |   $E77F/59263      Dummy subroutine
  |   $E780/59264      Check for auto start - removed
  |   $E7A3/59299      Perform [&] - USR file execute command
  |   $E84B/59467      Generate checksum
  |   $E853/59475      IRQ routine for serial bus
  |   $E85B/59483      Service the serial bus
  |   $E909/59657      Send data
  |   $E99C/59804      DATA OUT lo
  |   $E9A5/59813      DATA OUT hi
  |   $E9AE/59822      CLOCK OUT hi
  |   $E9B7/59831      CLOCK OUT lo
  |   $E9C0/59840      Read IEEE port
  |   $E9C9/59849      Get data byte from bus
  |   $E9F2/59890      Accept byte with EOI
  |   $EA2E/59950      Accept data from serial bus
  |   $EA59/59993      Test for ATN
  |   $EA6E/60014      Flash LED for hardware defects, self-test
  |   $EAA0/60064      Power-up RESET routine
  |   $EBFF/60415      Wait loop
  |   $EC9E/60574      Load dir
  |   $ED23/60707      ?
  |   $ED59/60761      Transmit dir line
  |   $ED67/60775      Get byte from buffer
  |   $ED84/60804      Perform [V] - Validate command
  |   $EDB3/60851      ?
  |   $EDE5/60901      Allocate file blocks in BAM
  |   $EE0D/60941      Perform [N] - New (Format) command
  |   $EEB7/61111      Create BAM
  |   $EEF4/61172      Write BAM if needed
  |   $EF3A/61242      Set buffer pointer for BAM
  |   $EF4D/61261      Get number of free blocks for dir
  |   $EF5C/61276      Mark block as free
  |   $EF88/61320      Set flag for BAM changed
  |   $EF90/61328      Mark block as allocated
  |   $EFCF/61391      Erase bit for sector in BAM entry
  |   $EFE9/61417      Powers of 2
  |   $EFF1/61425      Write BAM after change
  |   $F005/61445      Erase BAM buffer
  |   $F011/61457      ?
  |   $F05B/61531      ?
  |   $F0D1/61649      ?
  |   $F0DF/61663      ?
  |   $F10F/61711      Get buffer number for BAM
  |   $F119/61721      Buffer number for BAM
  |   $F11E/61726      Find and allocate free block
  |   $F1A9/61865      Find free sector and allocate
  |   $F1FA/61946      Find free sectors in current track
  |   $F220/61984      Verify number of free blocks in BAM
  |   $F24B/62027      Establish number of sectors per track
  |   $F258/62040      Dummy subroutine
  |
  | Disk Controller Routines:
  |
  |   $F259/62041      Initialise disk controller
  |   $F2B0/62128      IRQ routine for disk controller
  |   $F2F9/62201      Head transport
  |   $F36E/62318      Execute program in buffer
  |   $F37C/62332      Bump, find track 1 (head at stop)
  |   $F393/62355      Initialise pointer in buffer
  |   $F3B1/62385      Read block header, verify ID
  |   $F410/62480      Preserve block header
  |   $F418/62488      Work Return value 01 (OK) into queue
  |   $F41B/62491      Work Return value 0B (READ ERROR) into queue
  |   $F41E/62494      Work Return value 09 (READ ERROR) into queue
  |   $F423/62499      Job optimisation
  |   $F4CA/62666      Test command code further
  |   $F4D1/62673      Read sector
  |   $F50A/62730      Find start of data block
  |   $F510/62736      Read block header
  |   $F556/62806      Wait for SYNC
  |   $F56E/62830      Test command code further
  |   $F575/62837      Write data block to disk
  |   $F5E9/62953      Calculate parity for data buffer
  |   $F5F2/62962      Convert buffer of GCR data into binary
  |   $F691/63121      Test command code further
  |   $F698/63128      Compare written data with data on disk
  |   $F6CA/63178      Command code for find sector
  |   $F6D0/63184      Convert 4 binary bytes to 5 GCR bytes
  |   $F77F/63359      GCR (5-bit) nybble table
  |   $F78F/63375      Convert 260 bytes to 325 bytes group code
  |   $F7E6/63462      Convert 5 GCR bytes to 4 binary bytes
  |   $F8A0/63648      Conversion table GCR to binary - high nybble
  |   $F8C0/63680      Conversion table GCR to binary - low nybble
  |   $F8E0/63712      Decode 69 GCR bytes
  |   $F934/63796      Convert block header to GCR code
  |   $F969/63849      Error entry disk controller
  |   $F97E/63870      Turn drive motor on
  |   $F98F/63887      Turn drive motor off
  |   $F99C/63900      Job loop disk controller
  |   $F9CB/63947      ?
  |   $F9D9/63961      ?
  |   $FA05/64005      Move head to next track
  |   $FA1C/64028      Calculate number of head steps
  |   $FA3B/64059      Move stepper motor short distance
  |   $FA4E/64078      Load head
  |   $FA63/64099      ?
  |   $FA7B/64123      Prepare fast head movement
  |   $FA97/64151      Fast head movement
  |   $FAA5/64165      Prepare slow head movement
  |   $FAC7/64199      Formatting
  |   $FDA3/64931      Write SYNC 10240 times, erase track
  |   $FDC3/64963      Read/write ($621/$622) times
  |   $FDD3/64979      Attempt counter for formatting
  |   $FDE5/64997      ?
  |   $FDF5/65013      Copy data from overflow buffer
  |   $FE00/65024      Switch to reading
  |   $FE0E/65038      Write $55 10240 times
  |   $FE30/65072      Convert header in buffer 0 to GCR code
  |   $FE67/65127      Interrupt routine
  |   $FE85/65157      Constant: Directory track
  |   $FE86/65158      Constant: Start of BAM
  |   $FE87/65159      Constant: Length of BAM per track
  |   $FE88/65160      Constant: End of BAM
  |   $FE89/65161      Table of command words
  |   $FE95/65173      Low  byte of command addresses
  |   $FEA1/65185      High byte of command addresses
  |   $FEAD/65197      Bytes for syntax check
  |   $FEB2/65202      File control methods "RWAM"
  |   $FEB6/65206      File types "DSPUL"
  |   $FEBB/65211      Names of file types: 1st letter "DSPUR"
  |   $FEC0/65216      Names of file types: 2nd letter "EERSE"
  |   $FEC5/65221      Names of file types: 3rd letter "LQGRL"
  |   $FECA/65226      Error LED bit value
  |   $FECD/65229      Masks for bit command
  |   $FED1/65233      Number of sectors per track
  |   $FED5/65237      'A' marker for 1541 format
  |   $FED6/65238      4 track ranges
  |   $FED7/65239      Number of tracks
  |   $FED8/65240      Tracks on which sector numbers change
  |   $FEDB/65243      Control bytes for head postion
  |   $FEE0/65248      Buffer address high bytes
  |   $FEE6/65254      ROM checksum
  |   $FEE7/65255      From UI command $EB22, to reset (Without RAM/ROM test)
  |   $FEEA/65258      Patch for diagnostic routine from $EA7A
  |   $FEF3/65267      Delay loop for serial bus in 1541 mode, from $E97D
  |   $FEFB/65275      Patch for data output to serial bus, from $E980
  |   $FF01/65281      U9 vector, switch 1540/1541
  |   $FF10/65296      Patch for reset routine, from $EAA4
  |   $FF20/65312      Patch for listen to serial bus, from $E9DC
  |   $FF2F/65327      Unused
  |   $FFE6/65510      Format  [C8C6]
  |   $FFE8/65512      Turn motor off [F98F]
  |   $FFEA/65514      USER vectors: UA, U1  [CD5F]
  |   $FFEC/65516      USER vectors: UB, U2  [CD97]
  |   $FFEE/65518      USER vectors: UC, U3  [0500]
  |   $FFF0/65520      USER vectors: UD, U4  [0503]
  |   $FFF2/65522      USER vectors: UE, U5  [0506]
  |   $FFF4/65524      USER vectors: UF, U6  [0509]
  |   $FFF6/65526      USER vectors: UG, U7  [050C]
  |   $FFF8/65528      USER vectors: UH, U8  [050F]
  |   $FFFA/65530      USER vectors: UI, U9  [FF01]
  |   $FFFC/65532      Hardware vectors: RESET [EAA0]
  |   $FFFE/65534      Hardware vectors: IRQ   [FE67]
  |
  +------------------------------------------------------------------------


 $C100/49408:   Turn LED on for current drive

Jump from $C38C, $C439, $C46A, $C49A, $CE0B, $CFA2, $D39E, $D7E1, $EE1D:

C100: 78        SEI
C101: A9 F7     LDA #$F7        ; erase LED bit
C103: 2D 00 1C  AND $1C00
C106: 48        PHA
C107: A5 7F     LDA $7F         ; drive number
C109: F0 05     BEQ $C110       ; 0?
C10B: 68        PLA
C10C: 09 00     ORA #$00        ; not drive 0, turn LED off
C10E: D0 03     BNE $C113

Jump from $C109:

C110: 68        PLA
C111: 09 08     ORA #$08        ; turn LED on

Jump from $C10E:

C113: 8D 00 1C  STA $1C00
C116: 58        CLI
C117: 60        RTS



 $C118/49432:   Turn LED on

C118: 78        SEI
C119: A9 08     LDA #$08
C11B: 0D 00 1C  ORA $1C00       ; LED on
C11E: 8D 00 1C  STA $1C00
C121: 58        CLI
C122: 60        RTS



 $C123/49443:   Clear error flags

Jump from $C1AA, $D425, $E6BC:

C123: A9 00     LDA #$00
C125: 8D 6C 02  STA $026C
C128: 8D 6D 02  STA $026D
C12B: 60        RTS



 $C12C/49452:   Prepare for LED flash after error

Jump from $E650:

C12C: 78        SEI
C12D: 8A        TXA             ; save X register
C12E: 48        PHA
C12F: A9 50     LDA #$50
C131: 8D 6C 02  STA $026C
C134: A2 00     LDX #$00
C136: BD CA FE  LDA $FECA,X     ; 8
C139: 8D 6D 02  STA $026D
C13C: 0D 00 1C  ORA $1C00       ; turn LED on
C13F: 8D 00 1C  STA $1C00
C142: 68        PLA
C143: AA        TAX             ; get X register back
C144: 58        CLI
C145: 60        RTS



 $C146/49478:   Interpret command from computer

Jump from $EBFC:

C146: A9 00     LDA #$00
C148: 8D F9 02  STA $02F9
C14B: AD 8E 02  LDA $028E       ; last drive number
C14E: 85 7F     STA $7F         ; drive number
C150: 20 BC E6  JSR $E6BC       ; prepare 'ok' message
C153: A5 84     LDA $84         ; secondary address
C155: 10 09     BPL $C160
C157: 29 0F     AND #$0F
C159: C9 0F     CMP #$0F        ; 15, command channel
C15B: F0 03     BEQ $C160       ; yes
C15D: 4C B4 D7  JMP $D7B4       ; to OPEN command

Jump from $C155, $C15B:

C160: 20 B3 C2  JSR $C2B3       ; determine line length and erase flags
C163: B1 A3     LDA ($A3),Y     ; get first character
C165: 8D 75 02  STA $0275       ; and store
C168: A2 0B     LDX #$0B        ; 11

Jump from $C173:

C16A: BD 89 FE  LDA $FE89,X     ; commands
C16D: CD 75 02  CMP $0275       ; compare to first character
C170: F0 08     BEQ $C17A       ; found?
C172: CA        DEX
C173: 10 F5     BPL $C16A
C175: A9 31     LDA #$31        ; not found
C177: 4C C8 C1  JMP $C1C8       ; 31, 'syntax error'

Jump from $C170:

C17A: 8E 2A 02  STX $022A       ; number of command words
C17D: E0 09     CPX #$09
C17F: 90 03     BCC $C184       ; command number < 9?
C181: 20 EE C1  JSR $C1EE       ; test for 'R', 'S', and 'N'

Jump from $C17F:

C184: AE 2A 02  LDX $022A       ; command number
C187: BD 95 FE  LDA $FE95,X     ; jump address lo
C18A: 85 6F     STA $6F
C18C: BD A1 FE  LDA $FEA1,X     ; jump address hi
C18F: 85 70     STA $70
C191: 6C 6F 00  JMP ($006F)     ; jump to command



 $C194/49556:   Prepare error msg after executing command

Jump from $C99E, $C9A4, $CAC9, $CB6F, $CC18, $CCFB, $CD16, $CD5C, $CD70,
          $CD94, $CDA0, $CDB7, $CDCF, $D00B, $D7F0, $D99D, $DAE6, $DAFC,
          $E272, $EDB0, $EEB4:

C194: A9 00     LDA #$00
C196: 8D F9 02  STA $02F9

Jump from $DA06:

C199: AD 6C 02  LDA $026C       ; flag set?
C19C: D0 2A     BNE $C1C8       ; yes, then set error message
C19E: A0 00     LDY #$00
C1A0: 98        TYA             ; error number 0
C1A1: 84 80     STY $80         ; track number 0

Jump from $C87A:

C1A3: 84 81     STY $81         ; sector number 0
C1A5: 84 A3     STY $A3
C1A7: 20 C7 E6  JSR $E6C7       ; prepare 'ok' message
C1AA: 20 23 C1  JSR $C123       ; erase error flag

Jump from $DAE9, $DAFF:

C1AD: A5 7F     LDA $7F         ; drive number
C1AF: 8D 8E 02  STA $028E       ; save as last drive number
C1B2: AA        TAX
C1B3: A9 00     LDA #$00
C1B5: 95 FF     STA $FF,X
C1B7: 20 BD C1  JSR $C1BD       ; erase input buffer
C1BA: 4C DA D4  JMP $D4DA       ; close internal channel



 $C1BD/49597:   Erase input buffer

Jump from $C1B7, $E648:

C1BD: A0 28     LDY #$28        ; erase 41 characters
C1BF: A9 00     LDA #$00

Jump from $C1C5:

C1C1: 99 00 02  STA $0200,Y     ; $200 to $228
C1C4: 88        DEY
C1C5: 10 FA     BPL $C1C1
C1C7: 60        RTS



 $C1C8/49608:   Output error msg (track and sector 0)

Jump from $C177, $C19C, $C1F5, $C265, $C2D9, $C41D, $C8C3, $C925, $C984,
          $CAE3, $CAF1, $CB4D, $CBA2, $CC28, $CC2D, $CD33, $CDE2, $CF78,
          $CFFA, $D214, $D38E, $D839, $D8ED, $D8F2, $D947, $D959, $D967,
          $D9C0, $E0D3, $E16B, $E216, $E225, $E299, $E365, $E44B, $E7C2,
          $EE16, $F0EF, $F15C:

C1C8: A0 00     LDY #$00
C1CA: 84 80     STY $80         ; track = 0
C1CC: 84 81     STY $81         ; sector = 0
C1CE: 4C 45 E6  JMP $E645       ; error number acc, generate error message



 $C1D1/49617:   Check input line

Jump from $D005, $D7FF, $ED84:

C1D1: A2 00     LDX #$00
C1D3: 8E 7A 02  STX $027A       ; pointer to drive number
C1D6: A9 3A     LDA #$3A        ; ':'
C1D8: 20 68 C2  JSR $C268       ; test line to ':' or to end
C1DB: F0 05     BEQ $C1E2       ; no colon found?
C1DD: 88        DEY
C1DE: 88        DEY
C1DF: 8C 7A 02  STY $027A       ; point to drive number (before colon)

Jump from $C1DB:

C1E2: 4C 68 C3  JMP $C368       ; get drive number and turn LED on



 $C1E5/49637:   Check ':' on input line

Jump from $C1EE, $C904, $D82B, $DA86:

C1E5: A0 00     LDY #$00        ; pointer to input buffer
C1E7: A2 00     LDX #$00        ; counter for commas
C1E9: A9 3A     LDA #$3A        ; ':'
C1EB: 4C 68 C2  JMP $C268       ; test line to colon or to end



 $C1EE/49646:   Check input line

Jump from $C181:

C1EE: 20 E5 C1  JSR $C1E5       ; test line to ':' or end
C1F1: D0 05     BNE $C1F8       ; colon found?

Jump from $C1FE:

C1F3: A9 34     LDA #$34
C1F5: 4C C8 C1  JMP $C1C8       ; 34, 'syntax error'

Jump from $C1F1, $C90C:

C1F8: 88        DEY
C1F9: 88        DEY             ; set pointer to colon
C1FA: 8C 7A 02  STY $027A       ; position of the drive number
C1FD: 8A        TXA             ; comma before the colon
C1FE: D0 F3     BNE $C1F3       ; yes, then 'syntax error'

Jump from $DA95:

C200: A9 3D     LDA #$3D        ; '='
C202: 20 68 C2  JSR $C268       ; check input to '='
C205: 8A        TXA             ; comma found?
C206: F0 02     BEQ $C20A       ; no
C208: A9 40     LDA #$40        ; bit 6

Jump from $C206:

C20A: 09 21     ORA #$21        ; and set bit 0 and 5
C20C: 8D 8B 02  STA $028B       ; flag for syntax check
C20F: E8        INX
C210: 8E 77 02  STX $0277
C213: 8E 78 02  STX $0278
C216: AD 8A 02  LDA $028A       ; wildcard found?
C219: F0 0D     BEQ $C228       ; no
C21B: A9 80     LDA #$80
C21D: 0D 8B 02  ORA $028B       ; set bit 7
C220: 8D 8B 02  STA $028B
C223: A9 00     LDA #$00
C225: 8D 8A 02  STA $028A       ; reset wildcard flag

Jump from $C219:

C228: 98        TYA             ; '=' found?
C229: F0 29     BEQ $C254       ; no
C22B: 9D 7A 02  STA $027A,X
C22E: AD 77 02  LDA $0277       ; number of commas before '='
C231: 8D 79 02  STA $0279
C234: A9 8D     LDA #$8D        ; shift CR
C236: 20 68 C2  JSR $C268       ; check line to end
C239: E8        INX             ; increment comma counter
C23A: 8E 78 02  STX $0278       ; store number of commas
C23D: CA        DEX
C23E: AD 8A 02  LDA $028A       ; wildcard found?
C241: F0 02     BEQ $C245       ; no
C243: A9 08     LDA #$08        ; set bit 3

Jump from $C241:

C245: EC 77 02  CPX $0277       ; comma after '='?
C248: F0 02     BEQ $C24C       ; no
C24A: 09 04     ORA #$04        ; set bit 2

Jump from $C248:

C24C: 09 03     ORA #$03        ; set bits 0 and 1
C24E: 4D 8B 02  EOR $028B
C251: 8D 8B 02  STA $028B       ; as flag for syntax check

Jump from $C229:

C254: AD 8B 02  LDA $028B       ; syntax flag
C257: AE 2A 02  LDX $022A       ; command number
C25A: 3D A5 FE  AND $FEA5,X     ; combine with check byte
C25D: D0 01     BNE $C260
C25F: 60        RTS

Jump from $C25D:

C260: 8D 6C 02  STA $026C       ; set error flag
C263: A9 30     LDA #$30
C265: 4C C8 C1  JMP $C1C8       ; 30, 'syntax error'



 $C268/49768:   Search character in input buffer

Jump from $C1D8, $C1EB, $C202, $C236, $CC21, $CC75, $D845, $E7A5:

C268: 8D 75 02  STA $0275       ; save character

Jump from $C285, $C29C:

C26B: CC 74 02  CPY $0274       ; already done?
C26E: B0 2E     BCS $C29E       ; yes
C270: B1 A3     LDA ($A3),Y     ; get char from buffer
C272: C8        INY
C273: CD 75 02  CMP $0275       ; compared with char
C276: F0 28     BEQ $C2A0       ; found
C278: C9 2A     CMP #$2A        ; '*'
C27A: F0 04     BEQ $C280
C27C: C9 3F     CMP #$3F        ; '?'
C27E: D0 03     BNE $C283

Jump from $C27A:

C280: EE 8A 02  INC $028A       ; set wildcard flag

Jump from $C27E:

C283: C9 2C     CMP #$2C        ; ','
C285: D0 E4     BNE $C26B
C287: 98        TYA
C288: 9D 7B 02  STA $027B,X     ; note comma position
C28B: AD 8A 02  LDA $028A       ; wildcard flag
C28E: 29 7F     AND #$7F
C290: F0 07     BEQ $C299       ; no wildcard
C292: A9 80     LDA #$80
C294: 95 E7     STA $E7,X       ; note flag
C296: 8D 8A 02  STA $028A       ; and save as wildcard flag

Jump from $C290:

C299: E8        INX             ; increment comma counter
C29A: E0 04     CPX #$04        ; 4 commas already?
C29C: 90 CD     BCC $C26B       ; no, continue

Jump from $C26E:

C29E: A0 00     LDY #$00

Jump from $C276:

C2A0: AD 74 02  LDA $0274       ; set flag for line end
C2A3: 9D 7B 02  STA $027B,X
C2A6: AD 8A 02  LDA $028A       ; wildcard flag
C2A9: 29 7F     AND #$7F
C2AB: F0 04     BEQ $C2B1       ; no wildcard
C2AD: A9 80     LDA #$80
C2AF: 95 E7     STA $E7,X       ; set flag

Jump from $C2AB:

C2B1: 98        TYA
C2B2: 60        RTS



 $C2B3/49843:   Check line length

Jump from $C160, $D7B9, $E207:

C2B3: A4 A3     LDY $A3         ; pointer to command input buffer
C2B5: F0 14     BEQ $C2CB       ; zero?
C2B7: 88        DEY
C2B8: F0 10     BEQ $C2CA       ; one?
C2BA: B9 00 02  LDA $0200,Y     ; pointer to input buffer
C2BD: C9 0D     CMP #$0D        ; 'CR'
C2BF: F0 0A     BEQ $C2CB       ; yes, line end
C2C1: 88        DEY
C2C2: B9 00 02  LDA $0200,Y     ; preceding character
C2C5: C9 0D     CMP #$0D        ; 'CR'
C2C7: F0 02     BEQ $C2CB       ; yes
C2C9: C8        INY

Jump from $C2B8:

C2CA: C8        INY             ; pointer to old value again

Jump from $C2B5, $C2BF, $C2C7:

C2CB: 8C 74 02  STY $0274       ; same line length
C2CE: C0 2A     CPY #$2A        ; compare with 42 characters
C2D0: A0 FF     LDY #$FF
C2D2: 90 08     BCC $C2DC       ; smaller, ok
C2D4: 8C 2A 02  STY $022A
C2D7: A9 32     LDA #$32
C2D9: 4C C8 C1  JMP $C1C8       ; 32, 'syntax error' line too long



 $C2DC/49884:   Clear flags for command input

Jump from $C2D2, $DA8B:

C2DC: A0 00     LDY #$00
C2DE: 98        TYA
C2DF: 85 A3     STA $A3         ; pointer to input buffer lo
C2E1: 8D 58 02  STA $0258       ; record length
C2E4: 8D 4A 02  STA $024A       ; file type
C2E7: 8D 96 02  STA $0296
C2EA: 85 D3     STA $D3
C2EC: 8D 79 02  STA $0279       ; comma counter
C2EF: 8D 77 02  STA $0277       ;      "
C2F2: 8D 78 02  STA $0278       ;      "
C2F5: 8D 8A 02  STA $028A       ; wildcard flag
C2F8: 8D 6C 02  STA $026C       ; error flag
C2FB: A2 05     LDX #$05

Jump from $C30F:

C2FD: 9D 79 02  STA $0279,X     ; flags for line analysis
C300: 95 D7     STA $D7,X       ; directory sectors
C302: 95 DC     STA $DC,X       ; buffer pointer
C304: 95 E1     STA $E1,X       ; drive number
C306: 95 E6     STA $E6,X       ; wildcard flag
C308: 9D 7F 02  STA $027F,X     ; track number
C30B: 9D 84 02  STA $0284,X     ; sector number
C30E: CA        DEX
C30F: D0 EC     BNE $C2FD
C311: 60        RTS



 $C312/49938:   Preserve drive number

Jump from $D84C, $EE0D:

C312: AD 78 02  LDA $0278       ; number of commas
C315: 8D 77 02  STA $0277       ; save
C318: A9 01     LDA #$01
C31A: 8D 78 02  STA $0278       ; number of drive numbers
C31D: 8D 79 02  STA $0279

Jump from $C826, $C90F, $CA88, $DA9B:

C320: AC 8E 02  LDY $028E       ; last drive number
C323: A2 00     LDX #$00

Jump from $C339:

C325: 86 D3     STX $D3
C327: BD 7A 02  LDA $027A,X     ; position of the colon
C32A: 20 3C C3  JSR $C33C       ; get drive number before colon
C32D: A6 D3     LDX $D3
C32F: 9D 7A 02  STA $027A,X     ; save exact position
C332: 98        TYA
C333: 95 E2     STA $E2,X       ; drive number in table
C335: E8        INX
C336: EC 78 02  CPX $0278       ; got all drive numbers?
C339: 90 EA     BCC $C325       ; no, continue
C33B: 60        RTS



 $C33C/49980:   Search for drive number

Jump from $C32A:

C33C: AA        TAX             ; note position
C33D: A0 00     LDY #$00
C33F: A9 3A     LDA #$3A        ; ':'
C341: DD 01 02  CMP $0201,X     ; colon behind it?
C344: F0 0C     BEQ $C352       ; yes
C346: DD 00 02  CMP $0200,X     ; colon here?
C349: D0 16     BNE $C361       ; no
C34B: E8        INX

Jump from $C35F:

C34C: 98        TYA

Jump from $C359, $C35D:

C34D: 29 01     AND #$01        ; drive number

Jump from $C366:

C34F: A8        TAY
C350: 8A        TXA
C351: 60        RTS

Jump from $C344:

C352: BD 00 02  LDA $0200,X     ; get drive number
C355: E8        INX
C356: E8        INX
C357: C9 30     CMP #$30        ; '0'?
C359: F0 F2     BEQ $C34D       ; yes
C35B: C9 31     CMP #$31        ; '1'?
C35D: F0 EE     BEQ $C34D       ; yes
C35F: D0 EB     BNE $C34C       ; no, use last drive number

Jump from $C349:

C361: 98        TYA             ; last drive number
C362: 09 80     ORA #$80        ; set bit 7, uncertain drive number
C364: 29 81     AND #$81        ; erase remaining bits
C366: D0 E7     BNE $C34F



 $C368/50024:   Get drive number

Jump from $C1E2:

C368: A9 00     LDA #$00
C36A: 8D 8B 02  STA $028B       ; erase syntax flag
C36D: AC 7A 02  LDY $027A       ; position in command line

Jump from $C381:

C370: B1 A3     LDA ($A3),Y     ; get chars from command buffer
C372: 20 BD C3  JSR $C3BD       ; get drive number
C375: 10 11     BPL $C388       ; certain number?
C377: C8        INY             ; increment pointer
C378: CC 74 02  CPY $0274       ; line end?
C37B: B0 06     BCS $C383       ; yes
C37D: AC 74 02  LDY $0274
C380: 88        DEY
C381: D0 ED     BNE $C370       ; search line for drive number

Jump from $C37B:

C383: CE 8B 02  DEC $028B
C386: A9 00     LDA #$00

Jump from $C375:

C388: 29 01     AND #$01
C38A: 85 7F     STA $7F         ; drive number
C38C: 4C 00 C1  JMP $C100       ; turn LED on



 $C38F/50063:   Reverse drive number

Jump from $C40E, $C420, $C427, $C467, $C497, $C704, $C70B:

C38F: A5 7F     LDA $7F         ; drive number
C391: 49 01     EOR #$01        ; switch bit 0
C393: 29 01     AND #$01
C395: 85 7F     STA $7F
C397: 60        RTS



 $C398/50072:   Check given file type

Jump from $C823, $DA98:

C398: A0 00     LDY #$00
C39A: AD 77 02  LDA $0277       ; '=' found?
C39D: CD 78 02  CMP $0278
C3A0: F0 16     BEQ $C3B8       ; no
C3A2: CE 78 02  DEC $0278       ; get pointer
C3A5: AC 78 02  LDY $0278
C3A8: B9 7A 02  LDA $027A,Y     ; set pointer to character behind '='
C3AB: A8        TAY
C3AC: B1 A3     LDA ($A3),Y     ; pointer to buffer
C3AE: A0 04     LDY #$04        ; compare with marker for file type

Jump from $C3B6:

C3B0: D9 BB FE  CMP $FEBB,Y     ; 'S', 'P', 'U', 'R'
C3B3: F0 03     BEQ $C3B8       ; agreement
C3B5: 88        DEY
C3B6: D0 F8     BNE $C3B0

Jump from $C3A0, $C3B3:

C3B8: 98        TYA
C3B9: 8D 96 02  STA $0296       ; note file type (1-4)
C3BC: 60        RTS



 $C3BD/50109:   Check given drive number

Jump from $C372, $DA68:

C3BD: C9 30     CMP #$30        ; '0'
C3BF: F0 06     BEQ $C3C7
C3C1: C9 31     CMP #$31        ; '1'
C3C3: F0 02     BEQ $C3C7
C3C5: 09 80     ORA #$80        ; no zero or one, then set bit 7

Jump from $C3BF, $C3C3:

C3C7: 29 81     AND #$81
C3C9: 60        RTS



 $C3CA/50122:   Verify drive number

Jump from $C44F, $C829, $D84F, $DA9E:

C3CA: A9 00     LDA #$00
C3CC: 85 6F     STA $6F
C3CE: 8D 8D 02  STA $028D
C3D1: 48        PHA
C3D2: AE 78 02  LDX $0278       ; number of drive numbers

Jump from $C3E9, $C3ED:

C3D5: 68        PLA
C3D6: 05 6F     ORA $6F
C3D8: 48        PHA
C3D9: A9 01     LDA #$01
C3DB: 85 6F     STA $6F
C3DD: CA        DEX
C3DE: 30 0F     BMI $C3EF
C3E0: B5 E2     LDA $E2,X
C3E2: 10 04     BPL $C3E8
C3E4: 06 6F     ASL $6F
C3E6: 06 6F     ASL $6F

Jump from $C3E2:

C3E8: 4A        LSR
C3E9: 90 EA     BCC $C3D5
C3EB: 06 6F     ASL $6F
C3ED: D0 E6     BNE $C3D5

Jump from $C3DE:

C3EF: 68        PLA
C3F0: AA        TAX
C3F1: BD 3F C4  LDA $C43F,X     ; get syntax flag
C3F4: 48        PHA
C3F5: 29 03     AND #$03
C3F7: 8D 8C 02  STA $028C
C3FA: 68        PLA
C3FB: 0A        ASL
C3FC: 10 3E     BPL $C43C
C3FE: A5 E2     LDA $E2

Jump from $C43D:

C400: 29 01     AND #$01        ; isolate drive number
C402: 85 7F     STA $7F
C404: AD 8C 02  LDA $028C
C407: F0 2B     BEQ $C434
C409: 20 3D C6  JSR $C63D       ; initialize drive
C40C: F0 12     BEQ $C420       ; error?
C40E: 20 8F C3  JSR $C38F       ; switch to other drive
C411: A9 00     LDA #$00
C413: 8D 8C 02  STA $028C
C416: 20 3D C6  JSR $C63D       ; initialize drive
C419: F0 1E     BEQ $C439       ; no error?

Jump from $C437:

C41B: A9 74     LDA #$74
C41D: 20 C8 C1  JSR $C1C8       ; 74, 'drive not ready'

Jump from $C40C:

C420: 20 8F C3  JSR $C38F
C423: 20 3D C6  JSR $C63D       ; initialize drive
C426: 08        PHP
C427: 20 8F C3  JSR $C38F       ; switch to other drive
C42A: 28        PLP
C42B: F0 0C     BEQ $C439       ; no error?
C42D: A9 00     LDA #$00
C42F: 8D 8C 02  STA $028C       ; number of drives
C432: F0 05     BEQ $C439

Jump from $C407:

C434: 20 3D C6  JSR $C63D       ; initialize drive
C437: D0 E2     BNE $C41B       ; error?

Jump from $C419, $C42B, $C432:

C439: 4C 00 C1  JMP $C100       ; turn LED on

Jump from $C3FC:

C43C: 2A        ROL             ; drive number from carry after bit 0
C43D: 4C 00 C4  JMP $C400



 $C440/50240:   Flags for drive check

C440: 00 80 41 01 01 01 01 81
C448: 81 81 81 42 42 42 42



 $C44F/50255:   Search for file in directory

Jump from $C952, $CA99, $E7B8:

C44F: 20 CA C3  JSR $C3CA       ; initialize drive

Jump from $C46D:

C452: A9 00     LDA #$00
C454: 8D 92 02  STA $0292       ; pointer
C457: 20 AC C5  JSR $C5AC       ; read first directory block
C45A: D0 19     BNE $C475       ; entry present?

Jump from $C488:

C45C: CE 8C 02  DEC $028C       ; drive number clear?
C45F: 10 01     BPL $C462       ; no
C461: 60        RTS

Jump from $C45F:

C462: A9 01     LDA #$01
C464: 8D 8D 02  STA $028D
C467: 20 8F C3  JSR $C38F       ; change drive
C46A: 20 00 C1  JSR $C100       ; turn LED on
C46D: 4C 52 C4  JMP $C452       ; and search

Jump from $C481:

C470: 20 17 C6  JSR $C617       ; search next file in directory
C473: F0 10     BEQ $C485       ; not found?

Jump from $C45A, $C483:

C475: 20 D8 C4  JSR $C4D8       ; verify directory entry
C478: AD 8F 02  LDA $028F
C47B: F0 01     BEQ $C47E       ; more files?
C47D: 60        RTS

Jump from $C47B:

C47E: AD 53 02  LDA $0253
C481: 30 ED     BMI $C470       ; file not found?
C483: 10 F0     BPL $C475       ; yes

Jump from $C473:

C485: AD 8F 02  LDA $028F
C488: F0 D2     BEQ $C45C
C48A: 60        RTS



 $C48B/50315:   ?

Jump from $C86D:

C48B: 20 04 C6  JSR $C604       ; search next directory block
C48E: F0 1A     BEQ $C4AA       ; not found?
C490: D0 28     BNE $C4BA

Jump from $C4B2:

C492: A9 01     LDA #$01
C494: 8D 8D 02  STA $028D
C497: 20 8F C3  JSR $C38F       ; change drive
C49A: 20 00 C1  JSR $C100       ; turn LED on

Jump from $C830, $D852, $DAA4:

C49D: A9 00     LDA #$00
C49F: 8D 92 02  STA $0292
C4A2: 20 AC C5  JSR $C5AC       ; read directory block
C4A5: D0 13     BNE $C4BA       ; found?
C4A7: 8D 8F 02  STA $028F

Jump from $C48E, $C4B8:

C4AA: AD 8F 02  LDA $028F
C4AD: D0 28     BNE $C4D7
C4AF: CE 8C 02  DEC $028C
C4B2: 10 DE     BPL $C492
C4B4: 60        RTS

Jump from $C4C5, $C4D5, $C7A7:

C4B5: 20 17 C6  JSR $C617       ; next entry in directory
C4B8: F0 F0     BEQ $C4AA       ; not found?

Jump from $C490, $C4A5:

C4BA: 20 D8 C4  JSR $C4D8       ; check entry
C4BD: AE 53 02  LDX $0253
C4C0: 10 07     BPL $C4C9       ; file found?
C4C2: AD 8F 02  LDA $028F
C4C5: F0 EE     BEQ $C4B5       ; yes
C4C7: D0 0E     BNE $C4D7       ; no, then done

Jump from $C4C0:

C4C9: AD 96 02  LDA $0296
C4CC: F0 09     BEQ $C4D7
C4CE: B5 E7     LDA $E7,X       ; file type
C4D0: 29 07     AND #$07
C4D2: CD 96 02  CMP $0296       ; same as desired file type?
C4D5: D0 DE     BNE $C4B5       ; no

Jump from $C4AD, $C4C7, $C4CC:

C4D7: 60        RTS



 $C4D8/50392:   ?

Jump from $C475, $C4BA:

C4D8: A2 FF     LDX #$FF
C4DA: 8E 53 02  STX $0253       ; flag for data found
C4DD: E8        INX
C4DE: 8E 8A 02  STX $028A
C4E1: 20 89 C5  JSR $C589       ; set pointer to data
C4E4: F0 06     BEQ $C4EC

Jump from $C4EA:

C4E6: 60        RTS

Jump from $C4F5, $C4FC, $C513, $C519, $C533:

C4E7: 20 94 C5  JSR $C594       ; pointer to next file
C4EA: D0 FA     BNE $C4E6       ; end, then done

Jump from $C4E4:

C4EC: A5 7F     LDA $7F         ; drive number
C4EE: 55 E2     EOR $E2,X
C4F0: 4A        LSR
C4F1: 90 0B     BCC $C4FE
C4F3: 29 40     AND #$40
C4F5: F0 F0     BEQ $C4E7
C4F7: A9 02     LDA #$02
C4F9: CD 8C 02  CMP $028C       ; search both drives?
C4FC: F0 E9     BEQ $C4E7       ; yes

Jump from $C4F1:

C4FE: BD 7A 02  LDA $027A,X
C501: AA        TAX
C502: 20 A6 C6  JSR $C6A6       ; get length of filename
C505: A0 03     LDY #$03
C507: 4C 1D C5  JMP $C51D

Jump from $C529:

C50A: BD 00 02  LDA $0200,X     ; get chars out of command line
C50D: D1 94     CMP ($94),Y     ; same character in directory?
C50F: F0 0A     BEQ $C51B       ; yes
C511: C9 3F     CMP #$3F        ; '?'
C513: D0 D2     BNE $C4E7       ; no
C515: B1 94     LDA ($94),Y
C517: C9 A0     CMP #$A0        ; shift blank, end of name?
C519: F0 CC     BEQ $C4E7       ; yes

Jump from $C50F:

C51B: E8        INX             ; increment pointer
C51C: C8        INY

Jump from $C507:

C51D: EC 76 02  CPX $0276       ; end of the name in the command?
C520: B0 09     BCS $C52B       ; yes
C522: BD 00 02  LDA $0200,X     ; next character
C525: C9 2A     CMP #$2A        ; '*'
C527: F0 0C     BEQ $C535       ; yes, file found
C529: D0 DF     BNE $C50A       ; continue search

Jump from $C520:

C52B: C0 13     CPY #$13        ; 19
C52D: B0 06     BCS $C535       ; reached end of name
C52F: B1 94     LDA ($94),Y
C531: C9 A0     CMP #$A0        ; shift blank, end of name
C533: D0 B2     BNE $C4E7       ; not found

Jump from $C527, $C52D:

C535: AE 79 02  LDX $0279
C538: 8E 53 02  STX $0253
C53B: B5 E7     LDA $E7,X
C53D: 29 80     AND #$80
C53F: 8D 8A 02  STA $028A
C542: AD 94 02  LDA $0294
C545: 95 DD     STA $DD,X
C547: A5 81     LDA $81         ; sector number of the directory
C549: 95 D8     STA $D8,X       ; enter in table
C54B: A0 00     LDY #$00
C54D: B1 94     LDA ($94),Y     ; file type
C54F: C8        INY
C550: 48        PHA
C551: 29 40     AND #$40        ; isolate search-protect bit
C553: 85 6F     STA $6F         ; (6) and save
C555: 68        PLA
C556: 29 DF     AND #$DF        ; erase bit 7
C558: 30 02     BMI $C55C
C55A: 09 20     ORA #$20        ; set bit 5

Jump from $C558:

C55C: 29 27     AND #$27        ; erase bits 3 and 4
C55E: 05 6F     ORA $6F         ; get bit 6 again
C560: 85 6F     STA $6F
C562: A9 80     LDA #$80
C564: 35 E7     AND $E7,X       ; isolate flag for wildcard
C566: 05 6F     ORA $6F
C568: 95 E7     STA $E7,X       ; write in table
C56A: B5 E2     LDA $E2,X
C56C: 29 80     AND #$80
C56E: 05 7F     ORA $7F         ; drive number
C570: 95 E2     STA $E2,X
C572: B1 94     LDA ($94),Y
C574: 9D 80 02  STA $0280,X     ; first track of file
C577: C8        INY
C578: B1 94     LDA ($94),Y
C57A: 9D 85 02  STA $0285,X     ; get sector from directory
C57D: AD 58 02  LDA $0258       ; record length
C580: D0 07     BNE $C589
C582: A0 15     LDY #$15
C584: B1 94     LDA ($94),Y     ; record length
C586: 8D 58 02  STA $0258       ; get from directory

Jump from $C4E1, $C580:

C589: A9 FF     LDA #$FF
C58B: 8D 8F 02  STA $028F
C58E: AD 78 02  LDA $0278
C591: 8D 79 02  STA $0279

Jump from $C4E7, $C5A4:

C594: CE 79 02  DEC $0279
C597: 10 01     BPL $C59A
C599: 60        RTS

Jump from $C597:

C59A: AE 79 02  LDX $0279
C59D: B5 E7     LDA $E7,X       ; wildcard flag set?
C59F: 30 05     BMI $C5A6       ; yes
C5A1: BD 80 02  LDA $0280,X     ; track number already set
C5A4: D0 EE     BNE $C594       ; yes

Jump from $C59F:

C5A6: A9 00     LDA #$00
C5A8: 8D 8F 02  STA $028F
C5AB: 60        RTS



 $C5AC/50604:   ?

Jump from $C457, $C4A2, $D70E, $ED97:

C5AC: A0 00     LDY #$00
C5AE: 8C 91 02  STY $0291
C5B1: 88        DEY
C5B2: 8C 53 02  STY $0253
C5B5: AD 85 FE  LDA $FE85       ; 18, directory track
C5B8: 85 80     STA $80
C5BA: A9 01     LDA #$01
C5BC: 85 81     STA $81         ; sector 1
C5BE: 8D 93 02  STA $0293
C5C1: 20 75 D4  JSR $D475       ; read sector

Jump from $C62C:

C5C4: AD 93 02  LDA $0293
C5C7: D0 01     BNE $C5CA
C5C9: 60        RTS

Jump from $C5C7:

C5CA: A9 07     LDA #$07
C5CC: 8D 95 02  STA $0295       ; number of directory entries (-1)
C5CF: A9 00     LDA #$00
C5D1: 20 F6 D4  JSR $D4F6       ; get pointer from buffer
C5D4: 8D 93 02  STA $0293       ; save as track number

Jump from $C626:

C5D7: 20 E8 D4  JSR $D4E8       ; set buffer pointer
C5DA: CE 95 02  DEC $0295       ; decrement counter
C5DD: A0 00     LDY #$00
C5DF: B1 94     LDA ($94),Y     ; first byte from directory
C5E1: D0 18     BNE $C5FB
C5E3: AD 91 02  LDA $0291
C5E6: D0 2F     BNE $C617
C5E8: 20 3B DE  JSR $DE3B       ; get track and sector number
C5EB: A5 81     LDA $81
C5ED: 8D 91 02  STA $0291       ; sector number
C5F0: A5 94     LDA $94
C5F2: AE 92 02  LDX $0292
C5F5: 8D 92 02  STA $0292       ; buffer pointer
C5F8: F0 1D     BEQ $C617
C5FA: 60        RTS

Jump from $C5E1:

C5FB: A2 01     LDX #$01
C5FD: EC 92 02  CPX $0292       ; buffer pointer to one?
C600: D0 2D     BNE $C62F
C602: F0 13     BEQ $C617

Jump from $C48B, $EDD4:

C604: AD 85 FE  LDA $FE85       ; 18, track number of BAM
C607: 85 80     STA $80         ; track number
C609: AD 90 02  LDA $0290
C60C: 85 81     STA $81         ; sector number
C60E: 20 75 D4  JSR $D475       ; read block
C611: AD 94 02  LDA $0294
C614: 20 C8 D4  JSR $D4C8       ; set buffer pointer

Jump from $C5E6, $C5F8, $C602, $C470, $C4B5, $D72B:

C617: A9 FF     LDA #$FF
C619: 8D 53 02  STA $0253       ; erase-file found flag
C61C: AD 95 02  LDA $0295
C61F: 30 08     BMI $C629       ; all directory entries checked?
C621: A9 20     LDA #$20
C623: 20 C6 D1  JSR $D1C6       ; increment buffer ptr by 32, next entry
C626: 4C D7 C5  JMP $C5D7       ; and continue

Jump from $C61F:

C629: 20 4D D4  JSR $D44D       ; set buffer pointer
C62C: 4C C4 C5  JMP $C5C4       ; read next block

Jump from $C600:

C62F: A5 94     LDA $94
C631: 8D 94 02  STA $0294
C634: 20 3B DE  JSR $DE3B       ; get track & sector number from buffer
C637: A5 81     LDA $81
C639: 8D 90 02  STA $0290       ; save sector number
C63C: 60        RTS



 $C63D/50749:   Test and initalise drive

Jump from $C409, $C416, $C423, $C434, $CB8C:

C63D: A5 68     LDA $68
C63F: D0 28     BNE $C669
C641: A6 7F     LDX $7F         ; drive number
C643: 56 1C     LSR $1C,X       ; disk changed?
C645: 90 22     BCC $C669       ; no, then done
C647: A9 FF     LDA #$FF
C649: 8D 98 02  STA $0298       ; set error flag
C64C: 20 0E D0  JSR $D00E       ; read directory track
C64F: A0 FF     LDY #$FF
C651: C9 02     CMP #$02        ; 20, 'read error'?
C653: F0 0A     BEQ $C65F       ; yes
C655: C9 03     CMP #$03        ; 21, 'read error'?
C657: F0 06     BEQ $C65F       ; yes
C659: C9 0F     CMP #$0F        ; 74, 'drive not ready'?
C65B: F0 02     BEQ $C65F       ; yes
C65D: A0 00     LDY #$00

Jump from $C653, $C657, $C65B:

C65F: A6 7F     LDX $7F         ; drive number
C661: 98        TYA
C662: 95 FF     STA $FF,X       ; save error flag
C664: D0 03     BNE $C669       ; error?
C666: 20 42 D0  JSR $D042       ; load BAM

Jump from $C63F, $C645, $C664:

C669: A6 7F     LDX $7F         ; drive number
C66B: B5 FF     LDA $FF,X       ; transmit error code
C66D: 60        RTS



 $C66E/50798:   Name of file in directory buffer

Jump from $CAC0, $D768, $EE68:

C66E: 48        PHA
C66F: 20 A6 C6  JSR $C6A6       ; get end of the name
C672: 20 88 C6  JSR $C688       ; write filename in buffer
C675: 68        PLA
C676: 38        SEC
C677: ED 4B 02  SBC $024B       ; compare length with maximal length
C67A: AA        TAX
C67B: F0 0A     BEQ $C687
C67D: 90 08     BCC $C687
C67F: A9 A0     LDA #$A0        ; pad with 'shift blank'

Jump from $C685:

C681: 91 94     STA ($94),Y
C683: C8        INY
C684: CA        DEX
C685: D0 FA     BNE $C681

Jump from $C67B, $C67D:

C687: 60        RTS



 $C688/50824:   Copy filename to work buffer

Jump from $C672:

C688: 98        TYA             ; buffer number
C689: 0A        ASL
C68A: A8        TAY             ; times 2 as pointer
C68B: B9 99 00  LDA $99,Y
C68E: 85 94     STA $94
C690: B9 9A 00  LDA $9A,Y       ; buffer pointer after $94/$95
C693: 85 95     STA $95
C695: A0 00     LDY #$00

Jump from $C6A3:

C697: BD 00 02  LDA $0200,X     ; transmit characters in buffer
C69A: 91 94     STA ($94),Y
C69C: C8        INY
C69D: F0 06     BEQ $C6A5       ; buffer already full?
C69F: E8        INX
C6A0: EC 76 02  CPX $0276
C6A3: 90 F2     BCC $C697

Jump from $C69D:

C6A5: 60        RTS



 $C6A6/50854:   Search for end of name in command

Jump from $C502, $C66F:

C6A6: A9 00     LDA #$00
C6A8: 8D 4B 02  STA $024B
C6AB: 8A        TXA
C6AC: 48        PHA

Jump from $C6C6:

C6AD: BD 00 02  LDA $0200,X     ; get characters out of buffer
C6B0: C9 2C     CMP #$2C        ; ','
C6B2: F0 14     BEQ $C6C8
C6B4: C9 3D     CMP #$3D        ; '='
C6B6: F0 10     BEQ $C6C8
C6B8: EE 4B 02  INC $024B       ; increment length of name
C6BB: E8        INX
C6BC: A9 0F     LDA #$0F        ; 15
C6BE: CD 4B 02  CMP $024B
C6C1: 90 05     BCC $C6C8       ; greater?
C6C3: EC 74 02  CPX $0274       ; end of input line?
C6C6: 90 E5     BCC $C6AD

Jump from $C6B2, $C6B6, $C6C1:

C6C8: 8E 76 02  STX $0276
C6CB: 68        PLA
C6CC: AA        TAX             ; pointer to end of name
C6CD: 60        RTS



 $C6CE/50894:   ?

Jump from $ECF2:

C6CE: A5 83     LDA $83
C6D0: 48        PHA             ; secondary address and channel number
C6D1: A5 82     LDA $82
C6D3: 48        PHA
C6D4: 20 DE C6  JSR $C6DE       ; create file entry for directory
C6D7: 68        PLA
C6D8: 85 82     STA $82
C6DA: 68        PLA             ; get data back
C6DB: 85 83     STA $83
C6DD: 60        RTS



 $C6DE/50910:   ?

Jump from $C6D4:

C6DE: A9 11     LDA #$11        ; 17
C6E0: 85 83     STA $83         ; secondary address
C6E2: 20 EB D0  JSR $D0EB       ; open channel to read
C6E5: 20 E8 D4  JSR $D4E8       ; set buffer pointer
C6E8: AD 53 02  LDA $0253
C6EB: 10 0A     BPL $C6F7       ; not yet last entry?
C6ED: AD 8D 02  LDA $028D
C6F0: D0 0A     BNE $C6FC
C6F2: 20 06 C8  JSR $C806       ; write 'blocks free.'
C6F5: 18        CLC
C6F6: 60        RTS

Jump from $C6EB:

C6F7: AD 8D 02  LDA $028D
C6FA: F0 1F     BEQ $C71B

Jump from $C6F0:

C6FC: CE 8D 02  DEC $028D
C6FF: D0 0D     BNE $C70E
C701: CE 8D 02  DEC $028D
C704: 20 8F C3  JSR $C38F       ; change drive
C707: 20 06 C8  JSR $C806       ; write 'blocks free.'
C70A: 38        SEC
C70B: 4C 8F C3  JMP $C38F       ; change drive

Jump from $C6FF:

C70E: A9 00     LDA #$00
C710: 8D 73 02  STA $0273       ; drive no. for header, hi-byte
C713: 8D 8D 02  STA $028D
C716: 20 B7 C7  JSR $C7B7       ; write header
C719: 38        SEC
C71A: 60        RTS

Jump from $C6FA:

C71B: A2 18     LDX #$18
C71D: A0 1D     LDY #$1D
C71F: B1 94     LDA ($94),Y     ; number of blocks hi
C721: 8D 73 02  STA $0273       ; in buffer
C724: F0 02     BEQ $C728       ; zero?
C726: A2 16     LDX #$16

Jump from $C724:

C728: 88        DEY
C729: B1 94     LDA ($94),Y     ; number of blocks lo
C72B: 8D 72 02  STA $0272       ; in buffer
C72E: E0 16     CPX #$16
C730: F0 0A     BEQ $C73C
C732: C9 0A     CMP #$0A        ; 10
C734: 90 06     BCC $C73C
C736: CA        DEX
C737: C9 64     CMP #$64        ; 100
C739: 90 01     BCC $C73C
C73B: CA        DEX

Jump from $C730, $C734, $C739:

C73C: 20 AC C7  JSR $C7AC       ; erase buffer
C73F: B1 94     LDA ($94),Y     ; file type
C741: 48        PHA
C742: 0A        ASL             ; bit 7 in carry
C743: 10 05     BPL $C74A       ; bit 6 not set?
C745: A9 3C     LDA #$3C        ; '<' for protected file
C747: 9D B2 02  STA $02B2,X     ; write behind file type

Jump from $C743:

C74A: 68        PLA
C74B: 29 0F     AND #$0F        ; isolate bits 0-3
C74D: A8        TAY             ; as file type marker
C74E: B9 C5 FE  LDA $FEC5,Y     ; 3rd letter of the file type
C751: 9D B1 02  STA $02B1,X     ; in buffer
C754: CA        DEX
C755: B9 C0 FE  LDA $FEC0,Y     ; 2nd letter of the file type
C758: 9D B1 02  STA $02B1,X     ; in buffer
C75B: CA        DEX
C75C: B9 BB FE  LDA $FEBB,Y     ; 1st letter of the file type
C75F: 9D B1 02  STA $02B1,X     ; in buffer
C762: CA        DEX
C763: CA        DEX
C764: B0 05     BCS $C76B       ; file not closed?
C766: A9 2A     LDA #$2A        ; '*'
C768: 9D B2 02  STA $02B2,X     ; before file type in buffer

Jump from $C764:

C76B: A9 A0     LDA #$A0        ; pad with 'shift blank'
C76D: 9D B1 02  STA $02B1,X     ; in buffer
C770: CA        DEX
C771: A0 12     LDY #$12

Jump from $C77C:

C773: B1 94     LDA ($94),Y     ; filenames
C775: 9D B1 02  STA $02B1,X     ; write in buffer
C778: CA        DEX
C779: 88        DEY
C77A: C0 03     CPY #$03
C77C: B0 F5     BCS $C773
C77E: A9 22     LDA #$22        ; '='
C780: 9D B1 02  STA $02B1,X     ; write before file type

Jump from $C791:

C783: E8        INX
C784: E0 20     CPX #$20
C786: B0 0B     BCS $C793
C788: BD B1 02  LDA $02B1,X     ; character from buffer
C78B: C9 22     CMP #$22        ; '='?
C78D: F0 04     BEQ $C793
C78F: C9 A0     CMP #$A0        ; 'shift blank' at end of name
C791: D0 F0     BNE $C783

Jump from $C786, $C78D:

C793: A9 22     LDA #$22        ; fill through '='
C795: 9D B1 02  STA $02B1,X

Jump from $C7A5:

C798: E8        INX
C799: E0 20     CPX #$20
C79B: B0 0A     BCS $C7A7
C79D: A9 7F     LDA #$7F        ; bit 7
C79F: 3D B1 02  AND $02B1,X
C7A2: 9D B1 02  STA $02B1,X     ; erase in the remaining chars
C7A5: 10 F1     BPL $C798

Jump from $C79B:

C7A7: 20 B5 C4  JSR $C4B5       ; search for the directory entry
C7AA: 38        SEC
C7AB: 60        RTS



 $C7AC/51116:   Clear Directory Output Buffer

Jump from $C73C, $C7BD, $C806:

C7AC: A0 1B     LDY #$1B
C7AE: A9 20     LDA #$20        ; ' ' blank

Jump from $C7B4:

C7B0: 99 B0 02  STA $02B0,Y     ; write in buffer
C7B3: 88        DEY
C7B4: D0 FA     BNE $C7B0
C7B6: 60        RTS



 $C7B7/51127:   Create header with disk name

Jump from $C716, $DAA1:

C7B7: 20 19 F1  JSR $F119       ; initialize if needed
C7BA: 20 DF F0  JSR $F0DF       ; read disk name
C7BD: 20 AC C7  JSR $C7AC       ; erase buffer
C7C0: A9 FF     LDA #$FF
C7C2: 85 6F     STA $6F
C7C4: A6 7F     LDX $7F         ; drive number
C7C6: 8E 72 02  STX $0272       ; as block number lo in buffer
C7C9: A9 00     LDA #$00
C7CB: 8D 73 02  STA $0273       ; block number lo
C7CE: A6 F9     LDX $F9         ; buffer number
C7D0: BD E0 FE  LDA $FEE0,X     ; hi-byte of the buffer address
C7D3: 85 95     STA $95
C7D5: AD 88 FE  LDA $FE88       ; $90, position of disk name
C7D8: 85 94     STA $94         ; save
C7DA: A0 16     LDY #$16
C7DC: B1 94     LDA ($94),Y     ; pad buffer with 'shift blank'
C7DE: C9 A0     CMP #$A0
C7E0: D0 0B     BNE $C7ED
C7E2: A9 31     LDA #$31        ; '1'
C7E4: 2C        .BYTE $2C

Jump from $C7F1:

C7E5: B1 94     LDA ($94),Y     ; character from buffer
C7E7: C9 A0     CMP #$A0        ; compare with 'shift blank'
C7E9: D0 02     BNE $C7ED
C7EB: A9 20     LDA #$20        ; ' ' blank

Jump from $C7E0, $C7E9:

C7ED: 99 B3 02  STA $02B3,Y     ; in buffer
C7F0: 88        DEY
C7F1: 10 F2     BPL $C7E5
C7F3: A9 12     LDA #$12        ; 'RVS ON'
C7F5: 8D B1 02  STA $02B1       ; in buffer
C7F8: A9 22     LDA #$22        ; '"'
C7FA: 8D B2 02  STA $02B2       ; write before
C7FD: 8D C3 02  STA $02C3       ; and after disk name
C800: A9 20     LDA #$20        ; ' ' blank
C802: 8D C4 02  STA $02C4       ; behind it
C805: 60        RTS



 $C806/51206:   Print 'blocks free.'

Jump from $C6F2, $C707:

C806: 20 AC C7  JSR $C7AC       ; erase buffer
C809: A0 0B     LDY #$0B        ; 12 characters

Jump from $C812:

C80B: B9 17 C8  LDA $C817,Y     ; 'blocks free.'
C80E: 99 B1 02  STA $02B1,Y     ; write in buffer
C811: 88        DEY
C812: 10 F7     BPL $C80B
C814: 4C 4D EF  JMP $EF4D       ; number of free blocks in front



 $C817/51223:   'Blocks free.'

C817: 42 4C 4F 43 4B 53 20 46   ; 'blocks f'
C81F: 52 45 45 2E               ; 'ree.'



 $C823/51235:   Perform [S] - Scratch command

C823: 20 98 C3  JSR $C398       ; ascertain file type
C826: 20 20 C3  JSR $C320       ; get drive number
C829: 20 CA C3  JSR $C3CA       ; initialize drive if needed
C82C: A9 00     LDA #$00
C82E: 85 86     STA $86         ; counter for erased files
C830: 20 9D C4  JSR $C49D       ; search for file in directory
C833: 30 3D     BMI $C872       ; not found?

Jump from $C870:

C835: 20 B7 DD  JSR $DDB7       ; is file open
C838: 90 33     BCC $C86D       ; yes
C83A: A0 00     LDY #$00
C83C: B1 94     LDA ($94),Y     ; file type
C83E: 29 40     AND #$40        ; scratch protect
C840: D0 2B     BNE $C86D       ; yes
C842: 20 B6 C8  JSR $C8B6       ; erase file and note in directory
C845: A0 13     LDY #$13
C847: B1 94     LDA ($94),Y     ; track number of the first side-sector
C849: F0 0A     BEQ $C855       ; none present?
C84B: 85 80     STA $80         ; note track number
C84D: C8        INY
C84E: B1 94     LDA ($94),Y     ; and sector number
C850: 85 81     STA $81
C852: 20 7D C8  JSR $C87D       ; erase side-sector

Jump from $C849:

C855: AE 53 02  LDX $0253       ; file number
C858: A9 20     LDA #$20
C85A: 35 E7     AND $E7,X       ; bit 5 set?
C85C: D0 0D     BNE $C86B       ; yes, file not closed
C85E: BD 80 02  LDA $0280,X     ; get track
C861: 85 80     STA $80
C863: BD 85 02  LDA $0285,X     ; and sector
C866: 85 81     STA $81
C868: 20 7D C8  JSR $C87D       ; erase file

Jump from $C85C:

C86B: E6 86     INC $86         ; increment number of erased files

Jump from $C838, $C840:

C86D: 20 8B C4  JSR $C48B       ; search for next file
C870: 10 C3     BPL $C835       ; if present, erase

Jump from $C833:

C872: A5 86     LDA $86         ; number of erased files
C874: 85 80     STA $80         ; save as 'track'
C876: A9 01     LDA #$01        ; 1 as disk status
C878: A0 00     LDY #$00        ; 0 as 'sector'
C87A: 4C A3 C1  JMP $C1A3       ; message 'files scratched'



 $C87D/51325:   Erase file

Jump from $C852, $C868, $DC1B:

C87D: 20 5F EF  JSR $EF5F       ; free block in BAM
C880: 20 75 D4  JSR $D475
C883: 20 19 F1  JSR $F119       ; get buffer number in BAM
C886: B5 A7     LDA $A7,X
C888: C9 FF     CMP #$FF
C88A: F0 08     BEQ $C894
C88C: AD F9 02  LDA $02F9
C88F: 09 40     ORA #$40
C891: 8D F9 02  STA $02F9

Jump from $C88A, $C8B3:

C894: A9 00     LDA #$00
C896: 20 C8 D4  JSR $D4C8       ; buffer pointer to zero
C899: 20 56 D1  JSR $D156       ; get track
C89C: 85 80     STA $80
C89E: 20 56 D1  JSR $D156       ; get sector
C8A1: 85 81     STA $81
C8A3: A5 80     LDA $80         ; track number
C8A5: D0 06     BNE $C8AD       ; not equal to zero
C8A7: 20 F4 EE  JSR $EEF4       ; write BAM
C8AA: 4C 27 D2  JMP $D227       ; close channel

Jump from $C8A5:

C8AD: 20 5F EF  JSR $EF5F       ; free block in BAM
C8B0: 20 4D D4  JSR $D44D       ; read next block
C8B3: 4C 94 C8  JMP $C894       ; and continue



 $C8B6/51382:   Erase dir entry

Jump from $C842, $D8D3, $EDDF:

C8B6: A0 00     LDY #$00
C8B8: 98        TYA
C8B9: 91 94     STA ($94),Y     ; set file type to zero
C8BB: 20 5E DE  JSR $DE5E       ; write block
C8BE: 4C 99 D5  JMP $D599       ; and check



 $C8C1/51393:   Perform [D] - Backup command (Unused)

Jump from $C909:

C8C1: A9 31     LDA #$31
C8C3: 4C C8 C1  JMP $C1C8       ; 31, 'syntax error'



 $C8C6/51398:   Format disk

Jump from $EE3D:

C8C6: A9 4C     LDA #$4C        ; JMP-command
C8C8: 8D 00 06  STA $0600
C8CB: A9 C7     LDA #$C7
C8CD: 8D 01 06  STA $0601       ; JMP $FAC7 in $600 to $602
C8D0: A9 FA     LDA #$FA
C8D2: 8D 02 06  STA $0602
C8D5: A9 03     LDA #$03
C8D7: 20 D3 D6  JSR $D6D3       ; set track and sector number
C8DA: A5 7F     LDA $7F         ; drive number
C8DC: 09 E0     ORA #$E0        ; command code for formatting
C8DE: 85 03     STA $03         ; transmit

Jump from $C8E2:

C8E0: A5 03     LDA $03
C8E2: 30 FC     BMI $C8E0       ; wait until formatting done
C8E4: C9 02     CMP #$02
C8E6: 90 07     BCC $C8EF       ; smaller than two, then ok
C8E8: A9 03     LDA #$03
C8EA: A2 00     LDX #$00
C8EC: 4C 0A E6  JMP $E60A       ; 21, 'read error'

Jump from $C8E6:

C8EF: 60        RTS



 $C8F0/51440:   Perform [C] - Copy command

C8F0: A9 E0     LDA #$E0
C8F2: 8D 4F 02  STA $024F
C8F5: 20 D1 F0  JSR $F0D1
C8F8: 20 19 F1  JSR $F119       ; get buffer number of BAM
C8FB: A9 FF     LDA #$FF
C8FD: 95 A7     STA $A7,X
C8FF: A9 0F     LDA #$0F
C901: 8D 56 02  STA $0256
C904: 20 E5 C1  JSR $C1E5       ; check input line
C907: D0 03     BNE $C90C
C909: 4C C1 C8  JMP $C8C1       ; 31, 'syntax error'

Jump from $C907:

C90C: 20 F8 C1  JSR $C1F8       ; check input
C90F: 20 20 C3  JSR $C320       ; test drive number
C912: AD 8B 02  LDA $028B       ; flag for syntax check
C915: 29 55     AND #$55
C917: D0 0F     BNE $C928
C919: AE 7A 02  LDX $027A
C91C: BD 00 02  LDA $0200,X     ; character of the command
C91F: C9 2A     CMP #$2A        ; '*'
C921: D0 05     BNE $C928

Jump from $C92D:

C923: A9 30     LDA #$30
C925: 4C C8 C1  JMP $C1C8       ; 30, 'syntax error'

Jump from $C917, $C921:

C928: AD 8B 02  LDA $028B       ; syntax flag
C92B: 29 D9     AND #$D9
C92D: D0 F4     BNE $C923       ; 30, 'syntax error'
C92F: 4C 52 C9  JMP $C952
C932: A9 00     LDA #$00
C934: 8D 58 02  STA $0258
C937: 8D 8C 02  STA $028C       ; number of drives
C93A: 8D 80 02  STA $0280       ; track number in directory
C93D: 8D 81 02  STA $0281
C940: A5 E3     LDA $E3
C942: 29 01     AND #$01
C944: 85 7F     STA $7F         ; drive number
C946: 09 01     ORA #$01
C948: 8D 91 02  STA $0291
C94B: AD 7B 02  LDA $027B
C94E: 8D 7A 02  STA $027A
C951: 60        RTS

Jump from $C92F:

C952: 20 4F C4  JSR $C44F       ; search for file in directory
C955: AD 78 02  LDA $0278       ; number of filenames in command
C958: C9 03     CMP #$03        ; smaller than three?
C95A: 90 45     BCC $C9A1       ; yes
C95C: A5 E2     LDA $E2         ; first drive number
C95E: C5 E3     CMP $E3         ; second drive number
C960: D0 3F     BNE $C9A1       ; not on same drive?
C962: A5 DD     LDA $DD         ; directory block of the 1st file
C964: C5 DE     CMP $DE         ; same directory block as second file?
C966: D0 39     BNE $C9A1       ; no
C968: A5 D8     LDA $D8         ; directory sector of first file
C96A: C5 D9     CMP $D9         ; same directory sector as second file?
C96C: D0 33     BNE $C9A1       ; no
C96E: 20 CC CA  JSR $CACC       ; is file present?
C971: A9 01     LDA #$01
C973: 8D 79 02  STA $0279
C976: 20 FA C9  JSR $C9FA
C979: 20 25 D1  JSR $D125       ; get data type
C97C: F0 04     BEQ $C982       ; rel-file? yes
C97E: C9 02     CMP #$02        ; prg-file?
C980: D0 05     BNE $C987       ; no

Jump from $C97C:

C982: A9 64     LDA #$64
C984: 20 C8 C1  JSR $C1C8       ; 64, 'file type mismatch'

Jump from $C980:

C987: A9 12     LDA #$12        ; 18
C989: 85 83     STA $83         ; secondary address
C98B: AD 3C 02  LDA $023C
C98E: 8D 3D 02  STA $023D
C991: A9 FF     LDA #$FF
C993: 8D 3C 02  STA $023C
C996: 20 2A DA  JSR $DA2A       ; prepare append
C999: A2 02     LDX #$02
C99B: 20 B9 C9  JSR $C9B9       ; copy file
C99E: 4C 94 C1  JMP $C194       ; done



 $C9A1/51617:   ?

Jump from $C95A, $C960, $C966, $C96C:

C9A1: 20 A7 C9  JSR $C9A7       ; copy file
C9A4: 4C 94 C1  JMP $C194       ; done



 $C9A7/51623:   ?

Jump from $C9A1:

C9A7: 20 E7 CA  JSR $CAE7
C9AA: A5 E2     LDA $E2         ; drive number of first file
C9AC: 29 01     AND #$01
C9AE: 85 7F     STA $7F         ; drive number
C9B0: 20 86 D4  JSR $D486
C9B3: 20 E4 D6  JSR $D6E4       ; enter file in directory
C9B6: AE 77 02  LDX $0277

Jump from $C99B, $C9F1:

C9B9: 8E 79 02  STX $0279
C9BC: 20 FA C9  JSR $C9FA
C9BF: A9 11     LDA #$11        ; 17
C9C1: 85 83     STA $83
C9C3: 20 EB D0  JSR $D0EB
C9C6: 20 25 D1  JSR $D125       ; get data type
C9C9: D0 03     BNE $C9CE       ; no rel-file?
C9CB: 20 53 CA  JSR $CA53

Jump from $C9C9:

C9CE: A9 08     LDA #$08
C9D0: 85 F8     STA $F8
C9D2: 4C D8 C9  JMP $C9D8



 $C9D5/51669:   ?

Jump from $C9E0:

C9D5: 20 9B CF  JSR $CF9B       ; write byte in buffer

Jump from $C9D2:

C9D8: 20 35 CA  JSR $CA35       ; and get byte
C9DB: A9 80     LDA #$80
C9DD: 20 A6 DD  JSR $DDA6       ; test bit 7
C9E0: F0 F3     BEQ $C9D5       ; not set?
C9E2: 20 25 D1  JSR $D125       ; check file type
C9E5: F0 03     BEQ $C9EA       ; rel-file?
C9E7: 20 9B CF  JSR $CF9B       ; get data byte in buffer

Jump from $C9E5:

C9EA: AE 79 02  LDX $0279
C9ED: E8        INX
C9EE: EC 78 02  CPX $0278
C9F1: 90 C6     BCC $C9B9
C9F3: A9 12     LDA #$12        ; 18
C9F5: 85 83     STA $83
C9F7: 4C 02 DB  JMP $DB02       ; close channel



 $C9FA/51706:   ?

Jump from $C976, $C9BC:

C9FA: AE 79 02  LDX $0279
C9FD: B5 E2     LDA $E2,X       ; drive number
C9FF: 29 01     AND #$01
CA01: 85 7F     STA $7F         ; save
CA03: AD 85 FE  LDA $FE85       ; 18, directory track
CA06: 85 80     STA $80         ; save
CA08: B5 D8     LDA $D8,X       ; directory sector
CA0A: 85 81     STA $81
CA0C: 20 75 D4  JSR $D475       ; read block
CA0F: AE 79 02  LDX $0279
CA12: B5 DD     LDA $DD,X       ; pointer in block
CA14: 20 C8 D4  JSR $D4C8       ; set buffer pointer
CA17: AE 79 02  LDX $0279
CA1A: B5 E7     LDA $E7,X       ; file type
CA1C: 29 07     AND #$07        ; isolate
CA1E: 8D 4A 02  STA $024A       ; and save
CA21: A9 00     LDA #$00
CA23: 8D 58 02  STA $0258
CA26: 20 A0 D9  JSR $D9A0       ; get parameters for rel-file
CA29: A0 01     LDY #$01
CA2B: 20 25 D1  JSR $D125       ; get file type
CA2E: F0 01     BEQ $CA31       ; rel-file?
CA30: C8        INY

Jump from $CA2E:

CA31: 98        TYA
CA32: 4C C8 D4  JMP $D4C8       ; set buffer pointer



 $CA35/51765:   ?

Jump from $C9D8, $E81B, $E839:

CA35: A9 11     LDA #$11        ; 11
CA37: 85 83     STA $83

Jump from $DA2A:

CA39: 20 9B D3  JSR $D39B       ; open channel and get byte
CA3C: 85 85     STA $85
CA3E: A6 82     LDX $82         ; channel number
CA40: B5 F2     LDA $F2,X
CA42: 29 08     AND #$08        ; isolate end marker
CA44: 85 F8     STA $F8
CA46: D0 0A     BNE $CA52       ; not set?
CA48: 20 25 D1  JSR $D125       ; get data type
CA4B: F0 05     BEQ $CA52       ; rel-file?
CA4D: A9 80     LDA #$80
CA4F: 20 97 DD  JSR $DD97       ; set bit 7

Jump from $CA46, $CA4B:

CA52: 60        RTS

Jump from $C9CB:

CA53: 20 D3 D1  JSR $D1D3       ; set drive number
CA56: 20 CB E1  JSR $E1CB
CA59: A5 D6     LDA $D6
CA5B: 48        PHA
CA5C: A5 D5     LDA $D5
CA5E: 48        PHA
CA5F: A9 12     LDA #$12        ; 18
CA61: 85 83     STA $83
CA63: 20 07 D1  JSR $D107       ; open write channel
CA66: 20 D3 D1  JSR $D1D3       ; set drive number
CA69: 20 CB E1  JSR $E1CB
CA6C: 20 9C E2  JSR $E29C
CA6F: A5 D6     LDA $D6
CA71: 85 87     STA $87
CA73: A5 D5     LDA $D5
CA75: 85 86     STA $86
CA77: A9 00     LDA #$00
CA79: 85 88     STA $88
CA7B: 85 D4     STA $D4
CA7D: 85 D7     STA $D7
CA7F: 68        PLA
CA80: 85 D5     STA $D5
CA82: 68        PLA
CA83: 85 D6     STA $D6
CA85: 4C 3B E3  JMP $E33B



 $CA88/51848:   Perform [R] - Rename command

CA88: 20 20 C3  JSR $C320       ; get drive number from command line
CA8B: A5 E3     LDA $E3
CA8D: 29 01     AND #$01
CA8F: 85 E3     STA $E3         ; 2nd drive number
CA91: C5 E2     CMP $E2         ; compare with 1st drive number
CA93: F0 02     BEQ $CA97       ; same?
CA95: 09 80     ORA #$80

Jump from $CA93:

CA97: 85 E2     STA $E2
CA99: 20 4F C4  JSR $C44F       ; search for file in directory
CA9C: 20 E7 CA  JSR $CAE7       ; does name exist?
CA9F: A5 E3     LDA $E3
CAA1: 29 01     AND #$01
CAA3: 85 7F     STA $7F         ; drive number
CAA5: A5 D9     LDA $D9
CAA7: 85 81     STA $81         ; sector number
CAA9: 20 57 DE  JSR $DE57       ; read block from directory
CAAC: 20 99 D5  JSR $D599       ; ok?
CAAF: A5 DE     LDA $DE         ; pointer to directory entry
CAB1: 18        CLC
CAB2: 69 03     ADC #$03        ; pointer plus 3 to file name
CAB4: 20 C8 D4  JSR $D4C8       ; set buffer pointer
CAB7: 20 93 DF  JSR $DF93       ; get buffer number
CABA: A8        TAY
CABB: AE 7A 02  LDX $027A
CABE: A9 10     LDA #$10        ; 16 characters
CAC0: 20 6E C6  JSR $C66E       ; write name in buffer
CAC3: 20 5E DE  JSR $DE5E       ; write block to directory
CAC6: 20 99 D5  JSR $D599       ; ok?
CAC9: 4C 94 C1  JMP $C194       ; done, prepare disk status



 $CACC/51916:   Check if file present

Jump from $CAE7, $C96E:

CACC: A5 E8     LDA $E8         ; file type
CACE: 29 07     AND #$07
CAD0: 8D 4A 02  STA $024A       ; save
CAD3: AE 78 02  LDX $0278

Jump from $CADF:

CAD6: CA        DEX
CAD7: EC 77 02  CPX $0277
CADA: 90 0A     BCC $CAE6
CADC: BD 80 02  LDA $0280,X     ; track number
CADF: D0 F5     BNE $CAD6       ; not zero?
CAE1: A9 62     LDA #$62
CAE3: 4C C8 C1  JMP $C1C8       ; 62, 'file not found'

Jump from $CADA:

CAE6: 60        RTS

Jump from $C9A7, $CA9C:

CAE7: 20 CC CA  JSR $CACC       ; does file exist with old name?

Jump from $CAF5:

CAEA: BD 80 02  LDA $0280,X     ; track number of new file
CAED: F0 05     BEQ $CAF4       ; file erased?
CAEF: A9 63     LDA #$63
CAF1: 4C C8 C1  JMP $C1C8       ; 63, 'file exists'

Jump from $CAED:

CAF4: CA        DEX
CAF5: 10 F3     BPL $CAEA
CAF7: 60        RTS



 $CAF8/51960:   Perform [M] - Memory command

CAF8: AD 01 02  LDA $0201       ; 2nd character from buffer
CAFB: C9 2D     CMP #$2D        ; '-'
CAFD: D0 4C     BNE $CB4B
CAFF: AD 03 02  LDA $0203
CB02: 85 6F     STA $6F         ; address in $6F/$70
CB04: AD 04 02  LDA $0204
CB07: 85 70     STA $70
CB09: A0 00     LDY #$00
CB0B: AD 02 02  LDA $0202       ; 3rd character from buffer
CB0E: C9 52     CMP #$52        ; 'R'
CB10: F0 0E     BEQ $CB20       ; to memory read
CB12: 20 58 F2  JSR $F258       ; (RTS)
CB15: C9 57     CMP #$57        ; 'W'
CB17: F0 37     BEQ $CB50       ; to memory write
CB19: C9 45     CMP #$45        ; 'E'
CB1B: D0 2E     BNE $CB4B
CB1D: 6C 6F 00  JMP ($006F)     ; memory-execute



 $CB20/52000:   M-R memory read

Jump from $CB10:

CB20: B1 6F     LDA ($6F),Y     ; read byte
CB22: 85 85     STA $85
CB24: AD 74 02  LDA $0274       ; length of command line
CB27: C9 06     CMP #$06        ; less than 6?
CB29: 90 1A     BCC $CB45       ; yes
CB2B: AE 05 02  LDX $0205       ; number
CB2E: CA        DEX
CB2F: F0 14     BEQ $CB45       ; only one byte?
CB31: 8A        TXA             ; number of bytes
CB32: 18        CLC
CB33: 65 6F     ADC $6F         ; plus start address
CB35: E6 6F     INC $6F
CB37: 8D 49 02  STA $0249       ; end pointer
CB3A: A5 6F     LDA $6F
CB3C: 85 A5     STA $A5         ; buffer pointer for error message
CB3E: A5 70     LDA $70         ; set to start address for 'M-R'
CB40: 85 A6     STA $A6
CB42: 4C 43 D4  JMP $D443       ; byte out

Jump from $CB29, $CB2F:

CB45: 20 EB D0  JSR $D0EB       ; open read channel
CB48: 4C 3A D4  JMP $D43A       ; byte out

Jump from $CAFD, $CB1B:

CB4B: A9 31     LDA #$31
CB4D: 4C C8 C1  JMP $C1C8       ; 31, 'syntax error'



 $CB50/52048:   M-W memory write

Jump from $CB59, $CB17:

CB50: B9 06 02  LDA $0206,Y     ; read character
CB53: 91 6F     STA ($6F),Y     ; and save
CB55: C8        INY
CB56: CC 05 02  CPY $0205       ; number of characters
CB59: 90 F5     BCC $CB50       ; all characters?
CB5B: 60        RTS



 $CB5C/52060:   Perform [U] - User command

CB5C: AC 01 02  LDY $0201       ; second char
CB5F: C0 30     CPY #$30        ; '0'
CB61: D0 09     BNE $CB6C       ; no

Jump from $EBBC:

CB63: A9 EA     LDA #$EA
CB65: 85 6B     STA $6B         ; pointer to table of user-addresses
CB67: A9 FF     LDA #$FF        ; $FFEA
CB69: 85 6C     STA $6C
CB6B: 60        RTS

Jump from $CB61:

CB6C: 20 72 CB  JSR $CB72
CB6F: 4C 94 C1  JMP $C194       ; done, prepare error message

Jump from $CB6C:

CB72: 88        DEY
CB73: 98        TYA
CB74: 29 0F     AND #$0F        ; number
CB76: 0A        ASL             ; times 2
CB77: A8        TAY
CB78: B1 6B     LDA ($6B),Y     ; as pointer in table
CB7A: 85 75     STA $75
CB7C: C8        INY             ; address at $75/$76
CB7D: B1 6B     LDA ($6B),Y
CB7F: 85 76     STA $76
CB81: 6C 75 00  JMP ($0075)     ; execute function



 $CB84/52100:   Open direct access channel, number

Jump from $D819:

CB84: AD 8E 02  LDA $028E       ; last drive number
CB87: 85 7F     STA $7F         ; drive number
CB89: A5 83     LDA $83         ; channel number
CB8B: 48        PHA
CB8C: 20 3D C6  JSR $C63D       ; check drive and initialize
CB8F: 68        PLA
CB90: 85 83     STA $83
CB92: AE 74 02  LDX $0274       ; length of filename
CB95: CA        DEX
CB96: D0 0D     BNE $CBA5       ; greater than one?
CB98: A9 01     LDA #$01
CB9A: 20 E2 D1  JSR $D1E2       ; layout buffer and channel
CB9D: 4C F1 CB  JMP $CBF1       ; set flags, done

Jump from $CBAF, $CBC4, $CBCB:

CBA0: A9 70     LDA #$70
CBA2: 4C C8 C1  JMP $C1C8       ; 70, 'no channel'

Jump from $CB96:

CBA5: A0 01     LDY #$01
CBA7: 20 7C CC  JSR $CC7C       ; get buffer number
CBAA: AE 85 02  LDX $0285       ; buffer number
CBAD: E0 05     CPX #$05        ; bigger than 5?
CBAF: B0 EF     BCS $CBA0       ; 70, 'no channel'
CBB1: A9 00     LDA #$00
CBB3: 85 6F     STA $6F
CBB5: 85 70     STA $70
CBB7: 38        SEC

Jump from $CBBD:

CBB8: 26 6F     ROL $6F
CBBA: 26 70     ROL $70
CBBC: CA        DEX
CBBD: 10 F9     BPL $CBB8
CBBF: A5 6F     LDA $6F
CBC1: 2D 4F 02  AND $024F
CBC4: D0 DA     BNE $CBA0
CBC6: A5 70     LDA $70
CBC8: 2D 50 02  AND $0250
CBCB: D0 D3     BNE $CBA0
CBCD: A5 6F     LDA $6F
CBCF: 0D 4F 02  ORA $024F
CBD2: 8D 4F 02  STA $024F
CBD5: A5 70     LDA $70
CBD7: 0D 50 02  ORA $0250
CBDA: 8D 50 02  STA $0250
CBDD: A9 00     LDA #$00
CBDF: 20 E2 D1  JSR $D1E2       ; search channel
CBE2: A6 82     LDX $82         ; channel number
CBE4: AD 85 02  LDA $0285       ; buffer number
CBE7: 95 A7     STA $A7,X
CBE9: AA        TAX
CBEA: A5 7F     LDA $7F         ; drive number
CBEC: 95 00     STA $00,X
CBEE: 9D 5B 02  STA $025B,X

Jump from $CB9D:

CBF1: A6 83     LDX $83         ; secondary address
CBF3: BD 2B 02  LDA $022B,X
CBF6: 09 40     ORA #$40        ; set READ and WRITE flags
CBF8: 9D 2B 02  STA $022B,X
CBFB: A4 82     LDY $82         ; channel number
CBFD: A9 FF     LDA #$FF
CBFF: 99 44 02  STA $0244,Y     ; end pointer
CC02: A9 89     LDA #$89
CC04: 99 F2 00  STA $F2,Y       ; set READ and WRITE flags
CC07: B9 A7 00  LDA $A7,Y       ; buffer number
CC0A: 99 3E 02  STA $023E,Y
CC0D: 0A        ASL             ; times 2
CC0E: AA        TAX
CC0F: A9 01     LDA #$01
CC11: 95 99     STA $99,X       ; buffer pointer to one
CC13: A9 0E     LDA #$0E
CC15: 99 EC 00  STA $EC,Y       ; flag for direct access
CC18: 4C 94 C1  JMP $C194       ; done



 $CC1B/52251:   Perform [B] - Block/Buffer command

CC1B: A0 00     LDY #$00
CC1D: A2 00     LDX #$00
CC1F: A9 2D     LDA #$2D        ; '-'
CC21: 20 68 C2  JSR $C268       ; search for minus sign
CC24: D0 0A     BNE $CC30       ; found?

Jump from $CC40:

CC26: A9 31     LDA #$31
CC28: 4C C8 C1  JMP $C1C8       ; 31, 'syntax error'

Jump from $CC31, $CC9F:

CC2B: A9 30     LDA #$30
CC2D: 4C C8 C1  JMP $C1C8       ; 30, 'syntax error'

Jump from $CC24:

CC30: 8A        TXA
CC31: D0 F8     BNE $CC2B       ; comma, then error
CC33: A2 05     LDX #$05
CC35: B9 00 02  LDA $0200,Y     ; char from buffer

Jump from $CC3E:

CC38: DD 5D CC  CMP $CC5D,X     ; compare with 'AFRWEP'
CC3B: F0 05     BEQ $CC42       ; found?
CC3D: CA        DEX
CC3E: 10 F8     BPL $CC38       ; compare with all characters
CC40: 30 E4     BMI $CC26       ; not found, error

Jump from $CC3B:

CC42: 8A        TXA
CC43: 09 80     ORA #$80        ; command number, set bit 7
CC45: 8D 2A 02  STA $022A
CC48: 20 6F CC  JSR $CC6F       ; get parameters
CC4B: AD 2A 02  LDA $022A
CC4E: 0A        ASL             ; number times 2
CC4F: AA        TAX             ; as index
CC50: BD 64 CC  LDA $CC64,X     ; address of command hi
CC53: 85 70     STA $70
CC55: BD 63 CC  LDA $CC63,X     ; address lo
CC58: 85 6F     STA $6F
CC5A: 6C 6F 00  JMP ($006F)     ; jump to command



 $CC5D/52317:   Block commands "AFRWEP"

CC5D: 41 46 52 57 45 50         ; 'AFRWEP'



 $CC63/52323:   Block command vectors

CC63: 03 CD F5 CC 56 CD 73 CD    $CD03,$CCF5,$CD56,$CD73
CC6B: A3 CD BD CD                $CDA3,$CDBD



 $CC6F/52335:   Get parameters form block commands

Jump from $CC48, $CD5F, $CD97:

CC6F: A0 00     LDY #$00
CC71: A2 00     LDX #$00
CC73: A9 3A     LDA #$3A        ; ':'
CC75: 20 68 C2  JSR $C268       ; test line to colon
CC78: D0 02     BNE $CC7C       ; found?
CC7A: A0 03     LDY #$03        ; no, begin at 4th character

Jump from $CC78, $CC8F, $CBA7:

CC7C: B9 00 02  LDA $0200,Y     ; search for separating char
CC7F: C9 20     CMP #$20        ; ' ' blank
CC81: F0 08     BEQ $CC8B
CC83: C9 1D     CMP #$1D        ; cursor right
CC85: F0 04     BEQ $CC8B
CC87: C9 2C     CMP #$2C        ; ',' comma
CC89: D0 07     BNE $CC92

Jump from $CC81, $CC85, $CC9D:

CC8B: C8        INY
CC8C: CC 74 02  CPY $0274       ; line end?
CC8F: 90 EB     BCC $CC7C
CC91: 60        RTS

Jump from $CC89:

CC92: 20 A1 CC  JSR $CCA1       ; preserve next parameter
CC95: EE 77 02  INC $0277       ; increment parameter counter
CC98: AC 79 02  LDY $0279
CC9B: E0 04     CPX #$04        ; compare with maximum number
CC9D: 90 EC     BCC $CC8B
CC9F: B0 8A     BCS $CC2B       ; 30, 'syntax error'

Jump from $CC92:

CCA1: A9 00     LDA #$00
CCA3: 85 6F     STA $6F
CCA5: 85 70     STA $70         ; erase storage area for decimal numbers
CCA7: 85 72     STA $72
CCA9: A2 FF     LDX #$FF

Jump from $CCC8:

CCAB: B9 00 02  LDA $0200,Y     ; get characters from input buffer
CCAE: C9 40     CMP #$40
CCB0: B0 18     BCS $CCCA       ; no digits?
CCB2: C9 30     CMP #$30        ; '0'
CCB4: 90 14     BCC $CCCA       ; no digits?
CCB6: 29 0F     AND #$0F        ; convert ASCII digits to hex
CCB8: 48        PHA             ; and save
CCB9: A5 70     LDA $70
CCBB: 85 71     STA $71         ; move digits one further
CCBD: A5 6F     LDA $6F
CCBF: 85 70     STA $70
CCC1: 68        PLA
CCC2: 85 6F     STA $6F         ; note read number
CCC4: C8        INY             ; increment pointer in input buffer
CCC5: CC 74 02  CPY $0274       ; line end reached
CCC8: 90 E1     BCC $CCAB       ; no

Jump from $CCB0, $CCB4:

CCCA: 8C 79 02  STY $0279       ; save pointer
CCCD: 18        CLC
CCCE: A9 00     LDA #$00

Jump from $CCD8:

CCD0: E8        INX
CCD1: E0 03     CPX #$03
CCD3: B0 0F     BCS $CCE4       ; convert hex digits to one byte
CCD5: B4 6F     LDY $6F,X

Jump from $CCDD, $CCE2:

CCD7: 88        DEY
CCD8: 30 F6     BMI $CCD0
CCDA: 7D F2 CC  ADC $CCF2,X     ; add decimal value
CCDD: 90 F8     BCC $CCD7
CCDF: 18        CLC
CCE0: E6 72     INC $72
CCE2: D0 F3     BNE $CCD7

Jump from $CCD3:

CCE4: 48        PHA
CCE5: AE 77 02  LDX $0277       ; counter for paramaters
CCE8: A5 72     LDA $72
CCEA: 9D 80 02  STA $0280,X     ; hi-byte
CCED: 68        PLA
CCEE: 9D 85 02  STA $0285,X     ; lo-byte
CCF1: 60        RTS



 $CCF2/52466:   Decimal values  1, 10, 100

CCF2: 01 0A 64                  ; 1, 10, 100



 $CCF5/52469:   B-F block free

CCF5: 20 F5 CD  JSR $CDF5       ; get track, sector and drive number
CCF8: 20 5F EF  JSR $EF5F       ; free block
CCFB: 4C 94 C1  JMP $C194       ; done, prepare error message



 $CCFE/52478:   ?

CCFE: A9 01     LDA #$01
CD00: 8D F9 02  STA $02F9



 $CD03/52483:   B-A block allocate

CD03: 20 F5 CD  JSR $CDF5       ; get track, sector and drive number
CD06: A5 81     LDA $81         ; sector
CD08: 48        PHA             ; save
CD09: 20 FA F1  JSR $F1FA       ; find block in BAM
CD0C: F0 0B     BEQ $CD19       ; block allocated?
CD0E: 68        PLA             ; desired sector
CD0F: C5 81     CMP $81         ; = next free sector?
CD11: D0 19     BNE $CD2C       ; no
CD13: 20 90 EF  JSR $EF90       ; allocate block in BAM
CD16: 4C 94 C1  JMP $C194       ; done

Jump from $CD0C:

CD19: 68        PLA

Jump from $CD2A:

CD1A: A9 00     LDA #$00
CD1C: 85 81     STA $81         ; sector 0
CD1E: E6 80     INC $80         ; next track
CD20: A5 80     LDA $80         ; track number
CD22: CD D7 FE  CMP $FED7       ; 36, last track number + 1
CD25: B0 0A     BCS $CD31       ; >=, then 'no block'
CD27: 20 FA F1  JSR $F1FA       ; find free block in next track
CD2A: F0 EE     BEQ $CD1A       ; not found, check next track

Jump from $CD11:

CD2C: A9 65     LDA #$65
CD2E: 20 45 E6  JSR $E645       ; 65, 'no block' next free block

Jump from $CD25:

CD31: A9 65     LDA #$65
CD33: 20 C8 C1  JSR $C1C8       ; 65, 'no block' no more free blocks



 $CD36/52534:   Read block to buffer

Jump from $CD42, $CDA6:

CD36: 20 F2 CD  JSR $CDF2       ; open channel, set parameters
CD39: 4C 60 D4  JMP $D460       ; read block from disk



 $CD3C/52540:   Get byte from buffer

Jump from $CD4A:

CD3C: 20 2F D1  JSR $D12F       ; set pointer to buffer
CD3F: A1 99     LDA ($99,X)     ; get byte
CD41: 60        RTS



 $CD42/52546:   Read block from disk

Jump from $CD56, $CD62:

CD42: 20 36 CD  JSR $CD36       ; open channel, read block
CD45: A9 00     LDA #$00
CD47: 20 C8 D4  JSR $D4C8       ; set buffer pointer to zero
CD4A: 20 3C CD  JSR $CD3C       ; get a byte from the buffer
CD4D: 99 44 02  STA $0244,Y
CD50: A9 89     LDA #$89        ; set read and write flag
CD52: 99 F2 00  STA $F2,Y
CD55: 60        RTS



 $CD56/52566:   B-R block read

CD56: 20 42 CD  JSR $CD42       ; read block from disk
CD59: 20 EC D3  JSR $D3EC       ; prepare byte from buffer
CD5C: 4C 94 C1  JMP $C194       ; prepare error message



 $CD5F/52575:   U1, Block read without changing buffer pointer

CD5F: 20 6F CC  JSR $CC6F       ; get parameters of the command
CD62: 20 42 CD  JSR $CD42       ; read block from disk
CD65: B9 44 02  LDA $0244,Y     ; end pointer
CD68: 99 3E 02  STA $023E,Y     ; save as data byte
CD6B: A9 FF     LDA #$FF
CD6D: 99 44 02  STA $0244,Y     ; end pointer to $FF
CD70: 4C 94 C1  JMP $C194       ; done, prepare error message



 $CD73/52595:   B-W block write

CD73: 20 F2 CD  JSR $CDF2       ; open channel
CD76: 20 E8 D4  JSR $D4E8       ; set buffer pointer
CD79: A8        TAY
CD7A: 88        DEY
CD7B: C9 02     CMP #$02        ; buffer pointer lo less than 2?
CD7D: B0 02     BCS $CD81       ; no
CD7F: A0 01     LDY #$01

Jump from $CD7D:

CD81: A9 00     LDA #$00
CD83: 20 C8 D4  JSR $D4C8       ; buffer pointer to zero
CD86: 98        TYA
CD87: 20 F1 CF  JSR $CFF1       ; write byte in buffer
CD8A: 8A        TXA
CD8B: 48        PHA
CD8C: 20 64 D4  JSR $D464       ; write block to disk
CD8F: 68        PLA
CD90: AA        TAX
CD91: 20 EE D3  JSR $D3EE       ; get byte from buffer
CD94: 4C 94 C1  JMP $C194       ; done, error message



 $CD97/52631:   U2, Block write without changing buffer pointer

CD97: 20 6F CC  JSR $CC6F       ; get command parameters
CD9A: 20 F2 CD  JSR $CDF2       ; open channel
CD9D: 20 64 D4  JSR $D464       ; and write block to disk
CDA0: 4C 94 C1  JMP $C194       ; done



 $CDA3/52643:   B-E block execute

CDA3: 20 58 F2  JSR $F258       ; (RTS)
CDA6: 20 36 CD  JSR $CD36       ; open channel and read block
CDA9: A9 00     LDA #$00
CDAB: 85 6F     STA $6F         ; address low
CDAD: A6 F9     LDX $F9         ; buffer number
CDAF: BD E0 FE  LDA $FEE0,X     ; buffer address high
CDB2: 85 70     STA $70
CDB4: 20 BA CD  JSR $CDBA       ; execute routine
CDB7: 4C 94 C1  JMP $C194       ; done

Jump from $CDB4:

CDBA: 6C 6F 00  JMP ($006F)     ; jump to routine



 $CDBD/52669:   B-P block pointer

CDBD: 20 D2 CD  JSR $CDD2       ; open channel, get buffer number
CDC0: A5 F9     LDA $F9         ; buffer number
CDC2: 0A        ASL             ; * 2
CDC3: AA        TAX             ; as index
CDC4: AD 86 02  LDA $0286       ; pointer value
CDC7: 95 99     STA $99,X       ; save as buffer pointer
CDC9: 20 2F D1  JSR $D12F       ; prepare a byte in buffer
CDCC: 20 EE D3  JSR $D3EE       ; for output
CDCF: 4C 94 C1  JMP $C194       ; done



 $CDD2/52690:   Open channel

Jump from $CDBD, $CDF2:

CDD2: A6 D3     LDX $D3
CDD4: E6 D3     INC $D3
CDD6: BD 85 02  LDA $0285,X     ; buffer number
CDD9: A8        TAY
CDDA: 88        DEY
CDDB: 88        DEY
CDDC: C0 0C     CPY #$0C        ; buffer number smaller than 14?
CDDE: 90 05     BCC $CDE5       ; yes

Jump from $CDEA:

CDE0: A9 70     LDA #$70
CDE2: 4C C8 C1  JMP $C1C8       ; 70, 'no channel'

Jump from $CDDE:

CDE5: 85 83     STA $83         ; secondary address
CDE7: 20 EB D0  JSR $D0EB       ; open channel
CDEA: B0 F4     BCS $CDE0       ; already allocated, 'no channel'
CDEC: 20 93 DF  JSR $DF93       ; buffer number
CDEF: 85 F9     STA $F9         ; set
CDF1: 60        RTS



 $CDF2/52722:   Check buffer number and open channel

Jump from $CD36, $CD73, $CD9A:

CDF2: 20 D2 CD  JSR $CDD2       ; check buffer number and open channel

Jump from $CCF5, $CD03:

CDF5: A6 D3     LDX $D3         ; channel number
CDF7: BD 85 02  LDA $0285,X     ; buffer address
CDFA: 29 01     AND #$01
CDFC: 85 7F     STA $7F         ; drive number
CDFE: BD 87 02  LDA $0287,X
CE01: 85 81     STA $81         ; sector
CE03: BD 86 02  LDA $0286,X
CE06: 85 80     STA $80         ; track
CE08: 20 5F D5  JSR $D55F       ; track and sector ok?
CE0B: 4C 00 C1  JMP $C100       ; turn LED on



 $CE0E/52750:   Set pointer for REL file

Jump from $E255, $E338, $E436:

CE0E: 20 2C CE  JSR $CE2C       ; record number * record length
CE11: 20 6E CE  JSR $CE6E       ; divide by 254
CE14: A5 90     LDA $90         ; remainder = pointer in data block
CE16: 85 D7     STA $D7         ; data pointer
CE18: 20 71 CE  JSR $CE71       ; divide by 120 = side-sector number
CE1B: E6 D7     INC $D7
CE1D: E6 D7     INC $D7         ; data pointer + 2 (track/sector pointer!)
CE1F: A5 8B     LDA $8B         ; result of division
CE21: 85 D5     STA $D5         ; equals side-sector number
CE23: A5 90     LDA $90         ; remainder
CE25: 0A        ASL             ; times 2
CE26: 18        CLC
CE27: 69 10     ADC #$10        ; plus 16
CE29: 85 D6     STA $D6         ; =pointer in side-sector to data block
CE2B: 60        RTS



 $CE2C/52780:   ?

Jump from $CE0E:

CE2C: 20 D9 CE  JSR $CED9       ; erase work storage
CE2F: 85 92     STA $92
CE31: A6 82     LDX $82         ; channel number
CE33: B5 B5     LDA $B5,X       ; record number lo
CE35: 85 90     STA $90
CE37: B5 BB     LDA $BB,X       ; record number hi
CE39: 85 91     STA $91
CE3B: D0 04     BNE $CE41
CE3D: A5 90     LDA $90
CE3F: F0 0B     BEQ $CE4C       ; record number not zero?

Jump from $CE3B:

CE41: A5 90     LDA $90
CE43: 38        SEC
CE44: E9 01     SBC #$01        ; then subtract one
CE46: 85 90     STA $90
CE48: B0 02     BCS $CE4C
CE4A: C6 91     DEC $91

Jump from $CE3F, $CE48:

CE4C: B5 C7     LDA $C7,X       ; record length
CE4E: 85 6F     STA $6F

Jump from $CE5C:

CE50: 46 6F     LSR $6F
CE52: 90 03     BCC $CE57
CE54: 20 ED CE  JSR $CEED       ; record number * record length

Jump from $CE52:

CE57: 20 E5 CE  JSR $CEE5       ; shift register left
CE5A: A5 6F     LDA $6F
CE5C: D0 F2     BNE $CE50
CE5E: A5 D4     LDA $D4
CE60: 18        CLC
CE61: 65 8B     ADC $8B
CE63: 85 8B     STA $8B
CE65: 90 06     BCC $CE6D       ; result in $8B/$8C/$8D
CE67: E6 8C     INC $8C
CE69: D0 02     BNE $CE6D
CE6B: E6 8D     INC $8D

Jump from $CE65, $CE69:

CE6D: 60        RTS



 $CE6E/52846:   Divide by 254

Jump from $CE11:

CE6E: A9 FE     LDA #$FE        ; 254
CE70: 2C        .BYTE $2C



 $CE71/52849:   Divide by 120

Jump from $CE18:

CE71: A9 78     LDA #$78
CE73: 85 6F     STA $6F         ; divisor
CE75: A2 03     LDX #$03

Jump from $CE82:

CE77: B5 8F     LDA $8F,X
CE79: 48        PHA
CE7A: B5 8A     LDA $8A,X
CE7C: 95 8F     STA $8F,X
CE7E: 68        PLA
CE7F: 95 8A     STA $8A,X
CE81: CA        DEX
CE82: D0 F3     BNE $CE77
CE84: 20 D9 CE  JSR $CED9       ; erase work storage

Jump from $CEC3:

CE87: A2 00     LDX #$00

Jump from $CE90:

CE89: B5 90     LDA $90,X
CE8B: 95 8F     STA $8F,X
CE8D: E8        INX
CE8E: E0 04     CPX #$04
CE90: 90 F7     BCC $CE89
CE92: A9 00     LDA #$00
CE94: 85 92     STA $92
CE96: 24 6F     BIT $6F
CE98: 30 09     BMI $CEA3
CE9A: 06 8F     ASL $8F
CE9C: 08        PHP
CE9D: 46 8F     LSR $8F
CE9F: 28        PLP
CEA0: 20 E6 CE  JSR $CEE6       ; shift register 1 left

Jump from $CE98:

CEA3: 20 ED CE  JSR $CEED       ; add register 0 to register 1
CEA6: 20 E5 CE  JSR $CEE5       ; shift register 1 left
CEA9: 24 6F     BIT $6F
CEAB: 30 03     BMI $CEB0
CEAD: 20 E2 CE  JSR $CEE2       ; left-shift register 1 twice

Jump from $CEAB:

CEB0: A5 8F     LDA $8F
CEB2: 18        CLC
CEB3: 65 90     ADC $90
CEB5: 85 90     STA $90
CEB7: 90 06     BCC $CEBF
CEB9: E6 91     INC $91
CEBB: D0 02     BNE $CEBF
CEBD: E6 92     INC $92

Jump from $CEB7, $CEBB:

CEBF: A5 92     LDA $92
CEC1: 05 91     ORA $91
CEC3: D0 C2     BNE $CE87
CEC5: A5 90     LDA $90
CEC7: 38        SEC
CEC8: E5 6F     SBC $6F         ; quotient in $8B/$8C/$8D
CECA: 90 0C     BCC $CED8
CECC: E6 8B     INC $8B
CECE: D0 06     BNE $CED6
CED0: E6 8C     INC $8C
CED2: D0 02     BNE $CED6
CED4: E6 8D     INC $8D

Jump from $CECE, $CED2:

CED6: 85 90     STA $90         ; remainder in $90

Jump from $CECA:

CED8: 60        RTS



 $CED9/52953:   Erase work storage

Jump from $CE2C, $CE84:

CED9: A9 00     LDA #$00
CEDB: 85 8B     STA $8B
CEDD: 85 8C     STA $8C
CEDF: 85 8D     STA $8D
CEE1: 60        RTS



 $CEE2/52962:   Left shift 3-byte register twice

Jump from $CEAD:

CEE2: 20 E5 CE  JSR $CEE5



 $CEE5/52965:   Left shift 3-byte register once

Jump from $CE57, $CEA6, $CEE2:

CEE5: 18        CLC

Jump from $CEA0:

CEE6: 26 90     ROL $90
CEE8: 26 91     ROL $91
CEEA: 26 92     ROL $92
CEEC: 60        RTS



 $CEED/52973:   Add 3-byte registers

Jump from $CE54, $CEA3:

CEED: 18        CLC
CEEE: A2 FD     LDX #$FD

Jump from $CEF7:

CEF0: B5 8E     LDA $8E,X       ; register $90/$91/$92
CEF2: 75 93     ADC $93,X       ; add to register $8B/$8C/$8D
CEF4: 95 8E     STA $8E,X
CEF6: E8        INX
CEF7: D0 F7     BNE $CEF0
CEF9: 60        RTS



 $CEFA/52986:   ?

Jump from $CF17, $EBBF:

CEFA: A2 00     LDX #$00

Jump from $CF02:

CEFC: 8A        TXA
CEFD: 95 FA     STA $FA,X
CEFF: E8        INX
CF00: E0 04     CPX #$04
CF02: D0 F8     BNE $CEFC
CF04: A9 06     LDA #$06
CF06: 95 FA     STA $FA,X
CF08: 60        RTS



 $CF09/53001:   ?

Jump from $CF1E, $CF7B:

CF09: A0 04     LDY #$04
CF0B: A6 82     LDX $82         ; channel number

Jump from $CF1A:

CF0D: B9 FA 00  LDA $FA,Y
CF10: 96 FA     STX $FA,Y
CF12: C5 82     CMP $82         ; channel number
CF14: F0 07     BEQ $CF1D
CF16: 88        DEY
CF17: 30 E1     BMI $CEFA
CF19: AA        TAX
CF1A: 4C 0D CF  JMP $CF0D

Jump from $CF14:

CF1D: 60        RTS



 $CF1E/53022:   ?

Jump from $D0B7, $D0C0, $D16A, $D180, $D18C, $D1BB, $DB2F, $DB7D, $DBA2,
          $E04A, $E05D, $E072, $E078, $E18D, $E19A, $E19D, $E2B9, $E3B6,
          $E3C8, $E439, $E451, $E4F9:

CF1E: 20 09 CF  JSR $CF09
CF21: 20 B7 DF  JSR $DFB7
CF24: D0 46     BNE $CF6C
CF26: 20 D3 D1  JSR $D1D3       ; set drive number
CF29: 20 8E D2  JSR $D28E
CF2C: 30 48     BMI $CF76
CF2E: 20 C2 DF  JSR $DFC2
CF31: A5 80     LDA $80         ; track
CF33: 48        PHA
CF34: A5 81     LDA $81         ; sector
CF36: 48        PHA
CF37: A9 01     LDA #$01
CF39: 20 F6 D4  JSR $D4F6       ; get byte 1 from buffer
CF3C: 85 81     STA $81         ; sector
CF3E: A9 00     LDA #$00
CF40: 20 F6 D4  JSR $D4F6       ; get byte 0 from buffer
CF43: 85 80     STA $80         ; track
CF45: F0 1F     BEQ $CF66
CF47: 20 25 D1  JSR $D125       ; check file type
CF4A: F0 0B     BEQ $CF57       ; rel-file?
CF4C: 20 AB DD  JSR $DDAB
CF4F: D0 06     BNE $CF57
CF51: 20 8C CF  JSR $CF8C
CF54: 4C 5D CF  JMP $CF5D

Jump from $CF4A, $CF4F:

CF57: 20 8C CF  JSR $CF8C
CF5A: 20 57 DE  JSR $DE57

Jump from $CF54:

CF5D: 68        PLA
CF5E: 85 81     STA $81         ; get sector
CF60: 68        PLA
CF61: 85 80     STA $80         ; and track number
CF63: 4C 6F CF  JMP $CF6F

Jump from $CF45:

CF66: 68        PLA
CF67: 85 81     STA $81         ; get back sector
CF69: 68        PLA
CF6A: 85 80     STA $80         ; and track number

Jump from $CF24:

CF6C: 20 8C CF  JSR $CF8C

Jump from $CF63:

CF6F: 20 93 DF  JSR $DF93
CF72: AA        TAX
CF73: 4C 99 D5  JMP $D599       ; and verify

Jump from $CF2C, $CF86:

CF76: A9 70     LDA #$70
CF78: 4C C8 C1  JMP $C1C8       ; 70, 'no channel'

Jump from $E325:

CF7B: 20 09 CF  JSR $CF09
CF7E: 20 B7 DF  JSR $DFB7
CF81: D0 08     BNE $CF8B
CF83: 20 8E D2  JSR $D28E
CF86: 30 EE     BMI $CF76
CF88: 20 C2 DF  JSR $DFC2

Jump from $CF81:

CF8B: 60        RTS



 $CF8C/53132:   Change buffer

Jump from $CF51, $CF57, $CF6C:

CF8C: A6 82     LDX $82         ; channel number
CF8E: B5 A7     LDA $A7,X
CF90: 49 80     EOR #$80
CF92: 95 A7     STA $A7,X
CF94: B5 AE     LDA $AE,X       ; rotate bit 7 in table
CF96: 49 80     EOR #$80
CF98: 95 AE     STA $AE,X
CF9A: 60        RTS



 $CF9B/53147:   Write data in buffer

Jump from $C9D5, $C9E7:

CF9B: A2 12     LDX #$12        ; channel 18
CF9D: 86 83     STX $83
CF9F: 20 07 D1  JSR $D107       ; open write channel
CFA2: 20 00 C1  JSR $C100       ; turn LED on
CFA5: 20 25 D1  JSR $D125       ; check file type
CFA8: 90 05     BCC $CFAF       ; no rel-file
CFAA: A9 20     LDA #$20
CFAC: 20 9D DD  JSR $DD9D       ; change buffer

Jump from $CFA8:

CFAF: A5 83     LDA $83         ; secondary address
CFB1: C9 0F     CMP #$0F        ; 15?
CFB3: F0 23     BEQ $CFD8       ; yes
CFB5: D0 08     BNE $CFBF       ; no

Jump from $EA48:

CFB7: A5 84     LDA $84         ; secondary address
CFB9: 29 8F     AND #$8F
CFBB: C9 0F     CMP #$0F        ; greater than 15?
CFBD: B0 19     BCS $CFD8       ; then input buffer

Jump from $CFB5:

CFBF: 20 25 D1  JSR $D125       ; check file type
CFC2: B0 05     BCS $CFC9       ; rel-file or direct access?
CFC4: A5 85     LDA $85         ; data byte
CFC6: 4C 9D D1  JMP $D19D       ; write in buffer

Jump from $CFC2:

CFC9: D0 03     BNE $CFCE       ; direct access file?
CFCB: 4C AB E0  JMP $E0AB       ; write data byte in rel-file

Jump from $CFC9:

CFCE: A5 85     LDA $85
CFD0: 20 F1 CF  JSR $CFF1       ; write data byte in buffer
CFD3: A4 82     LDY $82         ; channel number
CFD5: 4C EE D3  JMP $D3EE       ; prepare next byte for output

Jump from $CFB3, $CFBD:

CFD8: A9 04     LDA #$04        ; channel 4
CFDA: 85 82     STA $82         ; corresponding input buffer
CFDC: 20 E8 D4  JSR $D4E8       ; set buffer pointer
CFDF: C9 2A     CMP #$2A        ; 40
CFE1: F0 05     BEQ $CFE8       ; buffer end?
CFE3: A5 85     LDA $85
CFE5: 20 F1 CF  JSR $CFF1       ; write data byte in buffer

Jump from $CFE1:

CFE8: A5 F8     LDA $F8         ; end flag set?
CFEA: F0 01     BEQ $CFED       ; yes
CFEC: 60        RTS

Jump from $CFEA:

CFED: EE 55 02  INC $0255       ; set command flag
CFF0: 60        RTS



 $CFF1/53233:   Write data byte in buffer

Jump from $CD87, $CFD0, $CFE5, $D19D, $D1B0, $D1B5, $D4A8, $D4AD, $D4BB,
          $D4C0, $D4C5, $D74D, $D754, $D75B, $DB73, $DB95, $DB99, $ECBE,
          $ECC3, $ECC8, $ECCB, $ECD1, $ECD6, $ECE7, $ECEC, $ECEF, $ECFA,
          $ED00, $ED08, $ED26, $ED2C, $ED3D, $ED40, $ED43, $ED5E:

CFF1: 48        PHA             ; save data byte
CFF2: 20 93 DF  JSR $DF93       ; get buffer number
CFF5: 10 06     BPL $CFFD       ; associated buffer?
CFF7: 68        PLA
CFF8: A9 61     LDA #$61
CFFA: 4C C8 C1  JMP $C1C8       ; 61, 'file not open'

Jump from $CFF5, $DD92:

CFFD: 0A        ASL             ; buffer number times 2
CFFE: AA        TAX             ; as index
CFFF: 68        PLA             ; data byte
D000: 81 99     STA ($99,X)     ; write in buffer
D002: F6 99     INC $99,X       ; increment buffer pointer
D004: 60        RTS



 $D005/53253:   Perform [I] - Initalise command

D005: 20 D1 C1  JSR $C1D1       ; find drive number
D008: 20 42 D0  JSR $D042       ; load BAM
D00B: 4C 94 C1  JMP $C194       ; prepare disk status



 $D00E/53262:   Read BAM from disk

Jump from $C64C, $D048:

D00E: 20 0F F1  JSR $F10F
D011: A8        TAY
D012: B6 A7     LDX $A7,Y
D014: E0 FF     CPX #$FF
D016: D0 14     BNE $D02C
D018: 48        PHA
D019: 20 8E D2  JSR $D28E
D01C: AA        TAX
D01D: 10 05     BPL $D024
D01F: A9 70     LDA #$70
D021: 20 48 E6  JSR $E648       ; 70, 'no channel'

Jump from $D01D:

D024: 68        PLA
D025: A8        TAY
D026: 8A        TXA
D027: 09 80     ORA #$80
D029: 99 A7 00  STA $A7,Y

Jump from $D016:

D02C: 8A        TXA
D02D: 29 0F     AND #$0F
D02F: 85 F9     STA $F9
D031: A2 00     LDX #$00
D033: 86 81     STX $81         ; sector 0
D035: AE 85 FE  LDX $FE85       ; 18
D038: 86 80     STX $80         ; track 18
D03A: 20 D3 D6  JSR $D6D3       ; transmit parameter to disk controller
D03D: A9 B0     LDA #$B0        ; command code 'read block header'
D03F: 4C 8C D5  JMP $D58C       ; transmit to disk controller



 $D042/53314:   Load BAM

Jump from $C666, $D008, $D828, $E63E, $ED87, $EE46:

D042: 20 D1 F0  JSR $F0D1
D045: 20 13 D3  JSR $D313
D048: 20 0E D0  JSR $D00E       ; read block
D04B: A6 7F     LDX $7F         ; drive number
D04D: A9 00     LDA #$00
D04F: 9D 51 02  STA $0251,X     ; reset flag for "BAM changed'
D052: 8A        TXA
D053: 0A        ASL
D054: AA        TAX
D055: A5 16     LDA $16
D057: 95 12     STA $12,X
D059: A5 17     LDA $17         ; save ID
D05B: 95 13     STA $13,X
D05D: 20 86 D5  JSR $D586
D060: A5 F9     LDA $F9         ; buffer number
D062: 0A        ASL
D063: AA        TAX
D064: A9 02     LDA #$02        ; buffer pointer to $200
D066: 95 99     STA $99,X
D068: A1 99     LDA ($99,X)     ; get character from buffer
D06A: A6 7F     LDX $7F         ; drive number
D06C: 9D 01 01  STA $0101,X
D06F: A9 00     LDA #$00
D071: 95 1C     STA $1C,X       ; flag for write protect
D073: 95 FF     STA $FF,X       ; flag for read error



 $D075/53365:   Calculate blocks free

Jump from $EEF1:

D075: 20 3A EF  JSR $EF3A       ; buffer address to $6D/$6E
D078: A0 04     LDY #$04        ; begin at position 4
D07A: A9 00     LDA #$00
D07C: AA        TAX

Jump from $D08D:

D07D: 18        CLC
D07E: 71 6D     ADC ($6D),Y     ; add number of free blocks per track
D080: 90 01     BCC $D083
D082: E8        INX             ; X as hi-byte

Jump from $D080, $D089:

D083: C8        INY
D084: C8        INY             ; plus 4
D085: C8        INY
D086: C8        INY
D087: C0 48     CPY #$48        ; track 18?
D089: F0 F8     BEQ $D083       ; then skip
D08B: C0 90     CPY #$90        ; last track number?
D08D: D0 EE     BNE $D07D       ; no
D08F: 48        PHA             ; lo-byte
D090: 8A        TXA             ; hi-byte
D091: A6 7F     LDX $7F         ; drive number
D093: 9D FC 02  STA $02FC,X     ; hi-byte to $2FC
D096: 68        PLA             ; lo-byte
D097: 9D FA 02  STA $02FA,X     ; to $2FA
D09A: 60        RTS



 $D09B/53403:   ?

Jump from $D0AF, $DC57:

D09B: 20 D0 D6  JSR $D6D0       ; parameters to disk controller
D09E: 20 C3 D0  JSR $D0C3       ; read block
D0A1: 20 99 D5  JSR $D599       ; ok?
D0A4: 20 37 D1  JSR $D137       ; get byte from buffer
D0A7: 85 80     STA $80         ; track
D0A9: 20 37 D1  JSR $D137       ; next byte from buffer
D0AC: 85 81     STA $81         ; sector
D0AE: 60        RTS



 $D0AF/53423:   ?

Jump from $E2CD:

D0AF: 20 9B D0  JSR $D09B
D0B2: A5 80     LDA $80         ; track
D0B4: D0 01     BNE $D0B7
D0B6: 60        RTS

Jump from $D0B4:

D0B7: 20 1E CF  JSR $CF1E       ; change buffer
D0BA: 20 D0 D6  JSR $D6D0       ; parameters to disk controller
D0BD: 20 C3 D0  JSR $D0C3       ; read block
D0C0: 4C 1E CF  JMP $CF1E       ; change buffer



 $D0C3/53443:   Read block

Jump from $D09E, $D0BD, $D189:

D0C3: A9 80     LDA #$80        ; code for 'read'
D0C5: D0 02     BNE $D0C9



 $D0C7/53447:   Write block

Jump from $D1B8, $D4B0, $DB9C:

D0C7: A9 90     LDA #$90        ; code for 'write'

Jump from $D0C5:

D0C9: 8D 4D 02  STA $024D       ; save
D0CC: 20 93 DF  JSR $DF93       ; get buffer number
D0CF: AA        TAX
D0D0: 20 06 D5  JSR $D506       ; get track/sector, read/write block
D0D3: 8A        TXA
D0D4: 48        PHA
D0D5: 0A        ASL             ; buffer pointer times 2
D0D6: AA        TAX
D0D7: A9 00     LDA #$00
D0D9: 95 99     STA $99,X       ; pointer in buffer to zero
D0DB: 20 25 D1  JSR $D125       ; get file type
D0DE: C9 04     CMP #$04        ; rel-file or direct access?
D0E0: B0 06     BCS $D0E8       ; yes
D0E2: F6 B5     INC $B5,X
D0E4: D0 02     BNE $D0E8       ; increment block counter
D0E6: F6 BB     INC $BB,X

Jump from $D0E0, $D0E4:

D0E8: 68        PLA
D0E9: AA        TAX
D0EA: 60        RTS



 $D0EB/53483:   Open channel for reading

Jump from $C6E2, $C9C3, $CB45, $CDE7, $D39B, $D90E, $DE3B, $E20F, $E680,
          $E90A:

D0EB: A5 83     LDA $83         ; secondary address
D0ED: C9 13     CMP #$13        ; 19
D0EF: 90 02     BCC $D0F3       ; smaller?
D0F1: 29 0F     AND #$0F

Jump from $D0EF:

D0F3: C9 0F     CMP #$0F
D0F5: D0 02     BNE $D0F9
D0F7: A9 10     LDA #$10        ; 16

Jump from $D0F5:

D0F9: AA        TAX
D0FA: 38        SEC
D0FB: BD 2B 02  LDA $022B,X
D0FE: 30 06     BMI $D106
D100: 29 0F     AND #$0F
D102: 85 82     STA $82
D104: AA        TAX
D105: 18        CLC             ; flag for ok

Jump from $D0FE:

D106: 60        RTS



 $D107/53511:   Open channel for writing

Jump from $CA63, $CF9F, $DB1B, $DC43, $E688, $EA2F:

D107: A5 83     LDA $83         ; secondary address
D109: C9 13     CMP #$13        ; 19
D10B: 90 02     BCC $D10F       ; smaller?
D10D: 29 0F     AND #$0F

Jump from $D10B:

D10F: AA        TAX
D110: BD 2B 02  LDA $022B,X     ; channel number
D113: A8        TAY
D114: 0A        ASL
D115: 90 0A     BCC $D121
D117: 30 0A     BMI $D123

Jump from $D121:

D119: 98        TYA
D11A: 29 0F     AND #$0F
D11C: 85 82     STA $82
D11E: AA        TAX
D11F: 18        CLC             ; flag for ok
D120: 60        RTS

Jump from $D115:

D121: 30 F6     BMI $D119

Jump from $D117:

D123: 38        SEC             ; flag for channel allocated
D124: 60        RTS



 $D125/53541:   Check for file type REL

Jump from $C979, $C9C6, $C9E2, $CA2B, $CA48, $CF47, $CFA5, $CFBF, $D0DB,
          $D3AC, $D3C0, $D3D7, $DB10, $DBDE, $E21E, $E68E:

D125: A6 82     LDX $82
D127: B5 EC     LDA $EC,X
D129: 4A        LSR
D12A: 29 07     AND #$07
D12C: C9 04     CMP #$04        ; 'REL'?
D12E: 60        RTS



 $D12F/53551:   Get buffer and channel numbers

Jump from $CD3C, $CDC9, $D137, $D3DE, $E01D, $E127, $E138, $E156:

D12F: 20 93 DF  JSR $DF93       ; get buffer number
D132: 0A        ASL
D133: AA        TAX
D134: A4 82     LDY $82
D136: 60        RTS



 $D137/53559:   Get a byte from buffer

Jump from $D0A4, $D0A9, $D156, $D172, $D17B, $D192, $D433, $DAAA, $DE9A,
          $DE9F, $ED67, $EDF3, $EDF8:

D137: 20 2F D1  JSR $D12F       ; get buffer and channel number
D13A: B9 44 02  LDA $0244,Y     ; end pointer
D13D: F0 12     BEQ $D151
D13F: A1 99     LDA ($99,X)     ; get byte from buffer
D141: 48        PHA
D142: B5 99     LDA $99,X       ; buffer pointer
D144: D9 44 02  CMP $0244,Y     ; equal end pointer?
D147: D0 04     BNE $D14D       ; no
D149: A9 FF     LDA #$FF
D14B: 95 99     STA $99,X       ; buffer pointer to -1

Jump from $D147:

D14D: 68        PLA             ; data byte
D14E: F6 99     INC $99,X       ; increment buffer pointer
D150: 60        RTS

Jump from $D13D:

D151: A1 99     LDA ($99,X)     ; get character from buffer
D153: F6 99     INC $99,X       ; increment buffer pointer
D155: 60        RTS



 $D156/53590:   Get byte and read next block

Jump from $C899, $C89E, $D400, $D45C, $DCA9:

D156: 20 37 D1  JSR $D137       ; get byte from buffer
D159: D0 36     BNE $D191       ; not last character?
D15B: 85 85     STA $85         ; save data byte
D15D: B9 44 02  LDA $0244,Y     ; end pointer
D160: F0 08     BEQ $D16A       ; yes
D162: A9 80     LDA #$80
D164: 99 F2 00  STA $F2,Y       ; READ-flag
D167: A5 85     LDA $85         ; data byte
D169: 60        RTS

Jump from $D160:

D16A: 20 1E CF  JSR $CF1E       ; change buffer and read next block
D16D: A9 00     LDA #$00
D16F: 20 C8 D4  JSR $D4C8       ; set buffer pointer to zero
D172: 20 37 D1  JSR $D137       ; get first byte from buffer
D175: C9 00     CMP #$00        ; track number zero
D177: F0 19     BEQ $D192       ; yes, then last block
D179: 85 80     STA $80         ; save last track number
D17B: 20 37 D1  JSR $D137       ; get next byte
D17E: 85 81     STA $81         ; save as following track
D180: 20 1E CF  JSR $CF1E       ; change buffer and read next block
D183: 20 D3 D1  JSR $D1D3       ; save drive number
D186: 20 D0 D6  JSR $D6D0       ; parameter to disk controller
D189: 20 C3 D0  JSR $D0C3       ; transmit read command
D18C: 20 1E CF  JSR $CF1E       ; change buffer and read block
D18F: A5 85     LDA $85         ; get data byte

Jump from $D159:

D191: 60        RTS

Jump from $D177:

D192: 20 37 D1  JSR $D137       ; get next byte from buffer
D195: A4 82     LDY $82
D197: 99 44 02  STA $0244,Y     ; save as end pointer
D19A: A5 85     LDA $85         ; get data byte back
D19C: 60        RTS



 $D19D/53661:   Write byte in buffer and block

Jump from $CFC6:

D19D: 20 F1 CF  JSR $CFF1       ; byte in buffer
D1A0: F0 01     BEQ $D1A3       ; buffer full?
D1A2: 60        RTS

Jump from $D1A0, $DA3D:

D1A3: 20 D3 D1  JSR $D1D3       ; get drive number
D1A6: 20 1E F1  JSR $F11E       ; find free block in BAM
D1A9: A9 00     LDA #$00
D1AB: 20 C8 D4  JSR $D4C8       ; buffer pointer to zero
D1AE: A5 80     LDA $80
D1B0: 20 F1 CF  JSR $CFF1       ; track number as first byte
D1B3: A5 81     LDA $81
D1B5: 20 F1 CF  JSR $CFF1       ; sector number as second byte
D1B8: 20 C7 D0  JSR $D0C7       ; write block
D1BB: 20 1E CF  JSR $CF1E       ; change buffer
D1BE: 20 D0 D6  JSR $D6D0       ; parameter to disk controller
D1C1: A9 02     LDA #$02
D1C3: 4C C8 D4  JMP $D4C8       ; buffer pointer to 2



 $D1C6/53702:   Increment buffer pointer

Jump from $C623:

D1C6: 85 6F     STA $6F
D1C8: 20 E8 D4  JSR $D4E8       ; get buffer pointer
D1CB: 18        CLC
D1CC: 65 6F     ADC $6F
D1CE: 95 99     STA $99,X       ; and increment
D1D0: 85 94     STA $94
D1D2: 60        RTS



 $D1D3/53715:   Get drive number

Jump from $CA53, $CA66, $CF26, $D183, $D1A3, $E03C, $E31C:

D1D3: 20 93 DF  JSR $DF93       ; get drive number
D1D6: AA        TAX
D1D7: BD 5B 02  LDA $025B,X
D1DA: 29 01     AND #$01        ; isolate drive number
D1DC: 85 7F     STA $7F         ; and save
D1DE: 60        RTS



 $D1DF/53727:   Find write channel and buffer

Jump from $DCDF:

D1DF: 38        SEC             ; flag for writing
D1E0: B0 01     BCS $D1E3



 $D1E2/53730:   Find read channel and buffer

Jump from $CB9A, $CBDF, $DC48, $ECA4:

D1E2: 18        CLC             ; flag for reading

Jump from $D1E0:

D1E3: 08        PHP             ; save
D1E4: 85 6F     STA $6F         ; buffer number
D1E6: 20 27 D2  JSR $D227       ; close channel
D1E9: 20 7F D3  JSR $D37F       ; allocate free channel
D1EC: 85 82     STA $82         ; channel number
D1EE: A6 83     LDX $83         ; secondary address
D1F0: 28        PLP
D1F1: 90 02     BCC $D1F5       ; read channel?
D1F3: 09 80     ORA #$80        ; flag for writing

Jump from $D1F1:

D1F5: 9D 2B 02  STA $022B,X     ; set
D1F8: 29 3F     AND #$3F
D1FA: A8        TAY
D1FB: A9 FF     LDA #$FF        ; default value
D1FD: 99 A7 00  STA $A7,Y
D200: 99 AE 00  STA $AE,Y       ; write in associated table
D203: 99 CD 00  STA $CD,Y
D206: C6 6F     DEC $6F         ; decrement buffer number
D208: 30 1C     BMI $D226       ; done already?
D20A: 20 8E D2  JSR $D28E       ; find buffer
D20D: 10 08     BPL $D217       ; found?

Jump from $D221, $DC7E, $DD13:

D20F: 20 5A D2  JSR $D25A       ; erase flags in table
D212: A9 70     LDA #$70
D214: 4C C8 C1  JMP $C1C8       ; 70, 'no channel'

Jump from $D20D:

D217: 99 A7 00  STA $A7,Y       ; buffer number in table
D21A: C6 6F     DEC $6F         ; buffer number
D21C: 30 08     BMI $D226       ; already done?
D21E: 20 8E D2  JSR $D28E       ; find buffer
D221: 30 EC     BMI $D20F       ; not found?
D223: 99 AE 00  STA $AE,Y       ; buffer number in table

Jump from $D208, $D21C:

D226: 60        RTS



 $D227/53799:   Close channel

Jump from $C8AA, $D1E6, $D30B, $D331, $D4DE, $D4E5, $DACE, $DB29, $DB5F,
          $E695, $EE01:

D227: A5 83     LDA $83         ; secondary address
D229: C9 0F     CMP #$0F        ; 15?
D22B: D0 01     BNE $D22E       ; no
D22D: 60        RTS             ; else done already

Jump from $D22B:

D22E: A6 83     LDX $83
D230: BD 2B 02  LDA $022B,X     ; channel number
D233: C9 FF     CMP #$FF        ; not associated?
D235: F0 22     BEQ $D259       ; then done
D237: 29 3F     AND #$3F
D239: 85 82     STA $82         ; channel number
D23B: A9 FF     LDA #$FF
D23D: 9D 2B 02  STA $022B,X     ; erase association in table
D240: A6 82     LDX $82
D242: A9 00     LDA #$00
D244: 95 F2     STA $F2,X       ; erase READ and WRITE flag
D246: 20 5A D2  JSR $D25A       ; free buffer
D249: A6 82     LDX $82         ; channel number
D24B: A9 01     LDA #$01        ; set bit 0

Jump from $D251:

D24D: CA        DEX
D24E: 30 03     BMI $D253       ; shift to correct position
D250: 0A        ASL
D251: D0 FA     BNE $D24D

Jump from $D24E:

D253: 0D 56 02  ORA $0256       ; free in allocation register
D256: 8D 56 02  STA $0256

Jump from $D235:

D259: 60        RTS



 $D25A/53850:   Free buffer

Jump from $D20F, $D246:

D25A: A6 82     LDX $82         ; channel number
D25C: B5 A7     LDA $A7,X       ; buffer number
D25E: C9 FF     CMP #$FF
D260: F0 09     BEQ $D26B       ; not associated?
D262: 48        PHA
D263: A9 FF     LDA #$FF
D265: 95 A7     STA $A7,X       ; erase buffer association
D267: 68        PLA
D268: 20 F3 D2  JSR $D2F3       ; erase buffer allocation register

Jump from $D260:

D26B: A6 82     LDX $82         ; channel number
D26D: B5 AE     LDA $AE,X
D26F: C9 FF     CMP #$FF        ; associated in second table?
D271: F0 09     BEQ $D27C       ; no
D273: 48        PHA
D274: A9 FF     LDA #$FF
D276: 95 AE     STA $AE,X       ; erase association
D278: 68        PLA
D279: 20 F3 D2  JSR $D2F3       ; erase buffer in allocation register

Jump from $D271:

D27C: A6 82     LDX $82         ; channel number
D27E: B5 CD     LDA $CD,X
D280: C9 FF     CMP #$FF        ; associated in 3rd table?
D282: F0 09     BEQ $D28D       ; no
D284: 48        PHA
D285: A9 FF     LDA #$FF
D287: 95 CD     STA $CD,X       ; erase association
D289: 68        PLA
D28A: 20 F3 D2  JSR $D2F3       ; erase buffer in allocation register

Jump from $D282:

D28D: 60        RTS



 $D28E/53902:   Find buffer

Jump from $CF29, $CF83, $D019, $D20A, $D21E, $DC79, $DD0E, $F0E7:

D28E: 98        TYA
D28F: 48        PHA
D290: A0 01     LDY #$01
D292: 20 BA D2  JSR $D2BA
D295: 10 0C     BPL $D2A3
D297: 88        DEY
D298: 20 BA D2  JSR $D2BA
D29B: 10 06     BPL $D2A3
D29D: 20 39 D3  JSR $D339
D2A0: AA        TAX
D2A1: 30 13     BMI $D2B6

Jump from $D295, $D29B, $D2A5:

D2A3: B5 00     LDA $00,X
D2A5: 30 FC     BMI $D2A3
D2A7: A5 7F     LDA $7F
D2A9: 95 00     STA $00,X
D2AB: 9D 5B 02  STA $025B,X
D2AE: 8A        TXA
D2AF: 0A        ASL
D2B0: A8        TAY
D2B1: A9 02     LDA #$02
D2B3: 99 99 00  STA $99,Y

Jump from $D2A1:

D2B6: 68        PLA
D2B7: A8        TAY
D2B8: 8A        TXA
D2B9: 60        RTS



 $D2BA/53946:   ?

Jump from $D292, $D298:

D2BA: A2 07     LDX #$07

Jump from $D2C5:

D2BC: B9 4F 02  LDA $024F,Y
D2BF: 3D E9 EF  AND $EFE9,X     ; erase bit
D2C2: F0 04     BEQ $D2C8
D2C4: CA        DEX
D2C5: 10 F5     BPL $D2BC
D2C7: 60        RTS

Jump from $D2C2:

D2C8: B9 4F 02  LDA $024F,Y
D2CB: 5D E9 EF  EOR $EFE9,X     ; rotate bit
D2CE: 99 4F 02  STA $024F,Y
D2D1: 8A        TXA             ; buffer number
D2D2: 88        DEY
D2D3: 30 03     BMI $D2D8
D2D5: 18        CLC
D2D6: 69 08     ADC #$08

Jump from $D2D3:

D2D8: AA        TAX             ; buffer number

Jump from $D2E7, $D2EB:

D2D9: 60        RTS



 $D2DA/53978:   ?

Jump from $E2BC, $E2BF:

D2DA: A6 82     LDX $82
D2DC: B5 A7     LDA $A7,X
D2DE: 30 09     BMI $D2E9
D2E0: 8A        TXA
D2E1: 18        CLC
D2E2: 69 07     ADC #$07
D2E4: AA        TAX
D2E5: B5 A7     LDA $A7,X
D2E7: 10 F0     BPL $D2D9

Jump from $D2DE:

D2E9: C9 FF     CMP #$FF
D2EB: F0 EC     BEQ $D2D9
D2ED: 48        PHA
D2EE: A9 FF     LDA #$FF
D2F0: 95 A7     STA $A7,X
D2F2: 68        PLA

Jump from $D268, $D279, $D28A:

D2F3: 29 0F     AND #$0F
D2F5: A8        TAY             ; buffer number
D2F6: C8        INY
D2F7: A2 10     LDX #$10        ; 16

Jump from $D304:

D2F9: 6E 50 02  ROR $0250
D2FC: 6E 4F 02  ROR $024F       ; rotate 16-bit allocation register
D2FF: 88        DEY
D300: D0 01     BNE $D303
D302: 18        CLC             ; erase bit for buffer

Jump from $D300:

D303: CA        DEX
D304: 10 F3     BPL $D2F9
D306: 60        RTS



 $D307/54023:   Close all channels

Jump from $EE36:

D307: A9 0E     LDA #$0E        ; 14
D309: 85 83     STA $83         ; secondary address

Jump from $D310:

D30B: 20 27 D2  JSR $D227       ; close channel
D30E: C6 83     DEC $83         ; next secondary address
D310: D0 F9     BNE $D30B
D312: 60        RTS



 $D313/54035:   Close all channels of other drives

Jump from $D045, $EC55, $EC66:

D313: A9 0E     LDA #$0E        ; 14
D315: 85 83     STA $83         ; secondary address

Jump from $D336:

D317: A6 83     LDX $83
D319: BD 2B 02  LDA $022B,X     ; association table
D31C: C9 FF     CMP #$FF        ; channel associated?
D31E: F0 14     BEQ $D334       ; no
D320: 29 3F     AND #$3F
D322: 85 82     STA $82         ; channel number
D324: 20 93 DF  JSR $DF93       ; get buffer number
D327: AA        TAX
D328: BD 5B 02  LDA $025B,X     ; drive number
D32B: 29 01     AND #$01        ; isolate
D32D: C5 7F     CMP $7F         ; equal to actual drive number
D32F: D0 03     BNE $D334       ; no
D331: 20 27 D2  JSR $D227       ; close channel

Jump from $D31E, $D32F:

D334: C6 83     DEC $83         ; next channel
D336: 10 DF     BPL $D317
D338: 60        RTS



 $D339/54073:   ?

Jump from $D29D:

D339: A5 6F     LDA $6F
D33B: 48        PHA
D33C: A0 00     LDY #$00

Jump from $D358:

D33E: B6 FA     LDX $FA,Y
D340: B5 A7     LDA $A7,X
D342: 10 04     BPL $D348
D344: C9 FF     CMP #$FF
D346: D0 16     BNE $D35E

Jump from $D342, $D36F:

D348: 8A        TXA
D349: 18        CLC
D34A: 69 07     ADC #$07
D34C: AA        TAX
D34D: B5 A7     LDA $A7,X
D34F: 10 04     BPL $D355
D351: C9 FF     CMP #$FF
D353: D0 09     BNE $D35E

Jump from $D34F, $D371:

D355: C8        INY
D356: C0 05     CPY #$05
D358: 90 E4     BCC $D33E
D35A: A2 FF     LDX #$FF
D35C: D0 1C     BNE $D37A

Jump from $D346, $D353:

D35E: 86 6F     STX $6F
D360: 29 3F     AND #$3F
D362: AA        TAX

Jump from $D365:

D363: B5 00     LDA $00,X
D365: 30 FC     BMI $D363
D367: C9 02     CMP #$02
D369: 90 08     BCC $D373
D36B: A6 6F     LDX $6F
D36D: E0 07     CPX #$07
D36F: 90 D7     BCC $D348
D371: B0 E2     BCS $D355

Jump from $D369:

D373: A4 6F     LDY $6F
D375: A9 FF     LDA #$FF
D377: 99 A7 00  STA $A7,Y

Jump from $D35C:

D37A: 68        PLA
D37B: 85 6F     STA $6F
D37D: 8A        TXA
D37E: 60        RTS



 $D37F/54143:   Find channel and allocate

Jump from $D1E9:

D37F: A0 00     LDY #$00
D381: A9 01     LDA #$01        ; set bit 0

Jump from $D38A:

D383: 2C 56 02  BIT $0256
D386: D0 09     BNE $D391       ; channel free?
D388: C8        INY
D389: 0A        ASL             ; rotate bit to left
D38A: D0 F7     BNE $D383       ; all channels checked?
D38C: A9 70     LDA #$70
D38E: 4C C8 C1  JMP $C1C8       ; 70, 'no channel'

Jump from $D386:

D391: 49 FF     EOR #$FF        ; rotate bit model
D393: 2D 56 02  AND $0256       ; erase bit
D396: 8D 56 02  STA $0256       ; allocate channel
D399: 98        TYA
D39A: 60        RTS



 $D39B/54171:   Get byte for output

Jump from $CA39:

D39B: 20 EB D0  JSR $D0EB       ; open channel for reading
D39E: 20 00 C1  JSR $C100       ; turn LED on
D3A1: 20 AA D3  JSR $D3AA       ; get byte in output register
D3A4: A6 82     LDX $82         ; channel number
D3A6: BD 3E 02  LDA $023E,X     ; get byte
D3A9: 60        RTS

Jump from $D3A1, $E992:

D3AA: A6 82     LDX $82         ; channel number
D3AC: 20 25 D1  JSR $D125       ; check file type
D3AF: D0 03     BNE $D3B4       ; no rel-file?
D3B1: 4C 20 E1  JMP $E120       ; get byte from rel-file

Jump from $D3AF:

D3B4: A5 83     LDA $83         ; secondary address
D3B6: C9 0F     CMP #$0F        ; 15
D3B8: F0 5A     BEQ $D414       ; yes, read error channel
D3BA: B5 F2     LDA $F2,X
D3BC: 29 08     AND #$08        ; end flag set?
D3BE: D0 13     BNE $D3D3       ; no
D3C0: 20 25 D1  JSR $D125       ; check file type
D3C3: C9 07     CMP #$07        ; direct access file?
D3C5: D0 07     BNE $D3CE       ; no
D3C7: A9 89     LDA #$89        ; set READ and WRITE flag
D3C9: 95 F2     STA $F2,X
D3CB: 4C DE D3  JMP $D3DE

Jump from $D3C5:

D3CE: A9 00     LDA #$00
D3D0: 95 F2     STA $F2,X       ; erase READ and WRITE flag
D3D2: 60        RTS

Jump from $D3BE:

D3D3: A5 83     LDA $83         ; secondary address
D3D5: F0 32     BEQ $D409       ; zero, LOAD?
D3D7: 20 25 D1  JSR $D125       ; check file type
D3DA: C9 04     CMP #$04        ; rel-file or direct access?
D3DC: 90 22     BCC $D400       ; no

Jump from $D3CB:

D3DE: 20 2F D1  JSR $D12F       ; get buffer and channel number
D3E1: B5 99     LDA $99,X       ; buffer pointer
D3E3: D9 44 02  CMP $0244,Y     ; equal end pointer?
D3E6: D0 04     BNE $D3EC       ; no
D3E8: A9 00     LDA #$00
D3EA: 95 99     STA $99,X       ; buffer pointer to zero

Jump from $D3E6, $CD59:

D3EC: F6 99     INC $99,X       ; increment buffer pointer

Jump from $CD91, $CDCC, $CFD5:

D3EE: A1 99     LDA ($99,X)     ; get byte from buffer
D3F0: 99 3E 02  STA $023E,Y     ; into output register
D3F3: B5 99     LDA $99,X       ; buffer pointer
D3F5: D9 44 02  CMP $0244,Y     ; equal end pointer?
D3F8: D0 05     BNE $D3FF       ; no
D3FA: A9 81     LDA #$81
D3FC: 99 F2 00  STA $F2,Y       ; set flags

Jump from $D3F8:

D3FF: 60        RTS

Jump from $D3DC, $D40C:

D400: 20 56 D1  JSR $D156       ; get byte from buffer

Jump from $D411:

D403: A6 82     LDX $82         ; channel number
D405: 9D 3E 02  STA $023E,X     ; byte in output register
D408: 60        RTS

Jump from $D3D5:

D409: AD 54 02  LDA $0254       ; flag for directory?
D40C: F0 F2     BEQ $D400       ; no
D40E: 20 67 ED  JSR $ED67       ; create directory line
D411: 4C 03 D4  JMP $D403

Jump from $D3B8:

D414: 20 E8 D4  JSR $D4E8       ; set buffer pointer
D417: C9 D4     CMP #$D4
D419: D0 18     BNE $D433
D41B: A5 95     LDA $95
D41D: C9 02     CMP #$02
D41F: D0 12     BNE $D433
D421: A9 0D     LDA #$0D        ; CR
D423: 85 85     STA $85         ; in output register
D425: 20 23 C1  JSR $C123       ; erase error flags
D428: A9 00     LDA #$00
D42A: 20 C1 E6  JSR $E6C1       ; create 'ok' message
D42D: C6 A5     DEC $A5         ; set buffer pointer back
D42F: A9 80     LDA #$80        ; set READ flag
D431: D0 12     BNE $D445

Jump from $D419, $D41F:

D433: 20 37 D1  JSR $D137       ; get byte from buffer
D436: 85 85     STA $85         ; into output register
D438: D0 09     BNE $D443

Jump from $CB48:

D43A: A9 D4     LDA #$D4
D43C: 20 C8 D4  JSR $D4C8       ; set buffer pointer in front of error pointer
D43F: A9 02     LDA #$02
D441: 95 9A     STA $9A,X       ; hi-address

Jump from $D438, $CB42:

D443: A9 88     LDA #$88        ; set READ flag

Jump from $D431:

D445: 85 F7     STA $F7
D447: A5 85     LDA $85         ; data byte
D449: 8D 43 02  STA $0243       ; into output register
D44C: 60        RTS



 $D44D/54349:   Read next block

Jump from $C629, $C8B0, $EE07:

D44D: 20 93 DF  JSR $DF93       ; get buffer number
D450: 0A        ASL             ; times 2
D451: AA        TAX
D452: A9 00     LDA #$00
D454: 95 99     STA $99,X       ; buffer pointer to zero
D456: A1 99     LDA ($99,X)     ; get first byte from buffer
D458: F0 05     BEQ $D45F       ; no block following?
D45A: D6 99     DEC $99,X       ; buffer pointer to -1
D45C: 4C 56 D1  JMP $D156       ; read next block

Jump from $D458:

D45F: 60        RTS



 $D460/54368:   Read block

Jump from $CD39, $D720, $DBC9, $EEB1:

D460: A9 80     LDA #$80        ; command code for reading
D462: D0 02     BNE $D466



 $D464/54372:   Write block

Jump from $CD8C, $CD9D, $D790, $D93A, $D98A, $EEAC:

D464: A9 90     LDA #$90        ; command code for writing

Jump from $D462:

D466: 05 7F     ORA $7F         ; drive number
D468: 8D 4D 02  STA $024D       ; save code
D46B: A5 F9     LDA $F9
D46D: 20 D3 D6  JSR $D6D3       ; parameter to disk controller
D470: A6 F9     LDX $F9
D472: 4C 93 D5  JMP $D593       ; execute command



 $D475/54389:   Allocate buffer and read block

Jump from $C5C1, $C60E, $C880, $CA0C, $EDEB:

D475: A9 01     LDA #$01

Jump from $E7D5:

D477: 8D 4A 02  STA $024A       ; file type to sequential
D47A: A9 11     LDA #$11        ; 17
D47C: 85 83     STA $83         ; secondary address
D47E: 20 46 DC  JSR $DC46       ; allocate buffer and read block
D481: A9 02     LDA #$02
D483: 4C C8 D4  JMP $D4C8       ; buffer pointer to 2



 $D486/54406:   Allocate new block

Jump from $C9B0:

D486: A9 12     LDA #$12        ; 18
D488: 85 83     STA $83         ; secondary address
D48A: 4C DA DC  JMP $DCDA       ; allocate new block



 $D48D/54413:   Write dir block

Jump from $D730:

D48D: 20 3B DE  JSR $DE3B       ; get track and sector number
D490: A9 01     LDA #$01
D492: 85 6F     STA $6F         ; a block
D494: A5 69     LDA $69         ; save step width 10 for block
D496: 48        PHA             ; allocation
D497: A9 03     LDA #$03
D499: 85 69     STA $69
D49B: 20 2D F1  JSR $F12D       ; find free block in BAM
D49E: 68        PLA
D49F: 85 69     STA $69         ; get step width back
D4A1: A9 00     LDA #$00
D4A3: 20 C8 D4  JSR $D4C8       ; buffer pointer to zero
D4A6: A5 80     LDA $80
D4A8: 20 F1 CF  JSR $CFF1       ; track number in buffer
D4AB: A5 81     LDA $81
D4AD: 20 F1 CF  JSR $CFF1       ; sector number in buffer
D4B0: 20 C7 D0  JSR $D0C7       ; write block to disk
D4B3: 20 99 D5  JSR $D599       ; and verify
D4B6: A9 00     LDA #$00
D4B8: 20 C8 D4  JSR $D4C8       ; buffer pointer to zero

Jump from $D4BE:

D4BB: 20 F1 CF  JSR $CFF1       ; fill buffer with zeroes
D4BE: D0 FB     BNE $D4BB
D4C0: 20 F1 CF  JSR $CFF1       ; zero as following track
D4C3: A9 FF     LDA #$FF
D4C5: 4C F1 CF  JMP $CFF1       ; $FF as number of bytes



 $D4C8/54472:   Set buffer pointer

Jump from $C614, $C896, $CA14, $CA32, $CAB4, $CD47, $CD83, $D16F, $D1AB,
          $D1C3, $D43C, $D483, $D4A3, $D4B8, $D740, $D914, $DA42, $DB92,
          $DCA0, $DD6F, $DE97, $DFFA, $E04F, $E27A, $E476, $E4A3, $E4C0,
          $E4DB, $ECA9, $EDF0:

D4C8: 85 6F     STA $6F         ; save pointer
D4CA: 20 93 DF  JSR $DF93       ; get buffer number
D4CD: 0A        ASL             ; times 2
D4CE: AA        TAX
D4CF: B5 9A     LDA $9A,X       ; buffer pointer hi
D4D1: 85 95     STA $95
D4D3: A5 6F     LDA $6F
D4D5: 95 99     STA $99,X       ; buffer pointer lo, new value
D4D7: 85 94     STA $94
D4D9: 60        RTS



 $D4DA/54490:   Close internal channel

Jump from $C1BA, $DAD1, $E653:

D4DA: A9 11     LDA #$11        ; 17
D4DC: 85 83     STA $83
D4DE: 20 27 D2  JSR $D227       ; close channel
D4E1: A9 12     LDA #$12        ; 18
D4E3: 85 83     STA $83
D4E5: 4C 27 D2  JMP $D227       ; close channel



 $D4E8/54504:   Set buffer pointer

Jump from $C5D7, $C6E5, $CD76, $CFDC, $D1C8, $D414, $DB6A, $DB76, $DFEA,
          $E182, $E1A9:

D4E8: 20 93 DF  JSR $DF93       ; get buffer number

Jump from $DF49:

D4EB: 0A        ASL
D4EC: AA        TAX
D4ED: B5 9A     LDA $9A,X       ; buffer pointer hi
D4EF: 85 95     STA $95
D4F1: B5 99     LDA $99,X       ; buffer pointer lo
D4F3: 85 94     STA $94
D4F5: 60        RTS



 $D4F6/54518:   Get byte from buffer

Jump from $C5D1, $CF39, $CF40, $E00E, $E39F:

D4F6: 85 71     STA $71         ; pointer lo
D4F8: 20 93 DF  JSR $DF93       ; get buffer number
D4FB: AA        TAX
D4FC: BD E0 FE  LDA $FEE0,X     ; hi-byte buffer address
D4FF: 85 72     STA $72         ; pointer hi
D501: A0 00     LDY #$00
D503: B1 71     LDA ($71),Y     ; get byte from buffer
D505: 60        RTS



 $D506/54534:   Check track and sector numbers

Jump from $D0D0, $DE92:

D506: BD 5B 02  LDA $025B,X     ; command code for disk controller
D509: 29 01     AND #$01        ; drive number
D50B: 0D 4D 02  ORA $024D       ; plus command code

Jump from $D596:

D50E: 48        PHA             ; save
D50F: 86 F9     STX $F9         ; buffer number
D511: 8A        TXA
D512: 0A        ASL             ; times 2
D513: AA        TAX
D514: B5 07     LDA $07,X       ; sector
D516: 8D 4D 02  STA $024D       ; save
D519: B5 06     LDA $06,X       ; track
D51B: F0 2D     BEQ $D54A       ; 66, 'illegal track or sector'
D51D: CD D7 FE  CMP $FED7       ; 36, highest track number + 1
D520: B0 28     BCS $D54A       ; 66, 'illegal track or sector'
D522: AA        TAX
D523: 68        PLA             ; command code
D524: 48        PHA
D525: 29 F0     AND #$F0
D527: C9 90     CMP #$90        ; code for writing?
D529: D0 4F     BNE $D57A       ; no
D52B: 68        PLA
D52C: 48        PHA
D52D: 4A        LSR
D52E: B0 05     BCS $D535
D530: AD 01 01  LDA $0101
D533: 90 03     BCC $D538

Jump from $D52E:

D535: AD 02 01  LDA $0102

Jump from $D533:

D538: F0 05     BEQ $D53F
D53A: CD D5 FE  CMP $FED5       ; 'A', format marker
D53D: D0 33     BNE $D572       ; 73, 'cbm dos v2.6 1541'

Jump from $D538:

D53F: 8A        TXA             ; track number
D540: 20 4B F2  JSR $F24B       ; get maximum sector number
D543: CD 4D 02  CMP $024D       ; compare with sector number
D546: F0 02     BEQ $D54A       ; equal, then error
D548: B0 30     BCS $D57A       ; smaller?

Jump from $D51B, $D520, $D546:

D54A: 20 52 D5  JSR $D552       ; get track and sector number

Jump from $D561, $D566, $D56D, $D56F:

D54D: A9 66     LDA #$66
D54F: 4C 45 E6  JMP $E645       ; 66, 'illegal track or sector'



 $D552/54610:   Get track and sector numbers for current job

Jump from $D54A, $D572:

D552: A5 F9     LDA $F9         ; buffer number
D554: 0A        ASL             ; *2
D555: AA        TAX             ; as index
D556: B5 06     LDA $06,X
D558: 85 80     STA $80         ; track
D55A: B5 07     LDA $07,X
D55C: 85 81     STA $81         ; sector
D55E: 60        RTS



 $D55F/54623:   Check for vaild track and sector numbers

Jump from $CE08, $EDE5:

D55F: A5 80     LDA $80         ; track
D561: F0 EA     BEQ $D54D       ; zero, then error
D563: CD D7 FE  CMP $FED7       ; 36, maximum track number + 1
D566: B0 E5     BCS $D54D       ; 66, 'illegal track and sector number'
D568: 20 4B F2  JSR $F24B       ; get maximum sector number
D56B: C5 81     CMP $81         ; sector
D56D: F0 DE     BEQ $D54D
D56F: 90 DC     BCC $D54D       ; error
D571: 60        RTS



 $D572/54642:   DOS mismatch error

Jump from $D53D, $EE53:

D572: 20 52 D5  JSR $D552       ; get track and sector number
D575: A9 73     LDA #$73
D577: 4C 45 E6  JMP $E645       ; 73, 'cbm dos v2.6 1541'

Jump from $D529, $D548:

D57A: A6 F9     LDX $F9         ; buffer number
D57C: 68        PLA
D57D: 8D 4D 02  STA $024D       ; command code for disk controller
D580: 95 00     STA $00,X       ; in command register
D582: 9D 5B 02  STA $025B,X     ; and write in table
D585: 60        RTS



 $D586/54662:   Read block

Jump from $D05D, $F107:

D586: A9 80     LDA #$80        ; code for read
D588: D0 02     BNE $D58C



 $D58A/54666:   Write block

Jump from $EF37, $F001, $F09C:

D58A: A9 90     LDA #$90        ; code for write

Jump from $D03F, $D588:

D58C: 05 7F     ORA $7F         ; drive number
D58E: A6 F9     LDX $F9         ; buffer number

Jump from $DC3D:

D590: 8D 4D 02  STA $024D

Jump from $D472, $DF42:

D593: AD 4D 02  LDA $024D       ; command code
D596: 20 0E D5  JSR $D50E       ; check track and sector



 $D599/54681:   Verify execution

Jump from $D59C, $C8BE, $CAAC, $CAC6, $CF73, $D0A1, $D4B3, $DB9F, $DC95,
          $DD6A, $DD84, $DDF9, $E05A, $E068, $E430, $E4A9, $E4F0:

D599: 20 A6 D5  JSR $D5A6       ; verify execution
D59C: B0 FB     BCS $D599       ; wait for end
D59E: 48        PHA
D59F: A9 00     LDA #$00
D5A1: 8D 98 02  STA $0298       ; erase error flag
D5A4: 68        PLA
D5A5: 60        RTS

Jump from $D599:

D5A6: B5 00     LDA $00,X       ; command code (bit 7) still in register?
D5A8: 30 1A     BMI $D5C4       ; yes
D5AA: C9 02     CMP #$02
D5AC: 90 14     BCC $D5C2       ; error-free execution
D5AE: C9 08     CMP #$08        ; 8
D5B0: F0 08     BEQ $D5BA       ; write protect
D5B2: C9 0B     CMP #$0B        ; 11
D5B4: F0 04     BEQ $D5BA       ; ID mismatch
D5B6: C9 0F     CMP #$0F        ; 15
D5B8: D0 0C     BNE $D5C6

Jump from $D5B0, $D5B4:

D5BA: 2C 98 02  BIT $0298
D5BD: 30 03     BMI $D5C2
D5BF: 4C 3F D6  JMP $D63F       ; create error message

Jump from $D5AC, $D5BD:

D5C2: 18        CLC             ; execution ended
D5C3: 60        RTS

Jump from $D5A8:

D5C4: 38        SEC             ; execution not yet ended
D5C5: 60        RTS



 $D5C6/54726:   Additional attempts for read errors

Jump from $D5B8:

D5C6: 98        TYA
D5C7: 48        PHA
D5C8: A5 7F     LDA $7F         ; drive number
D5CA: 48        PHA
D5CB: BD 5B 02  LDA $025B,X
D5CE: 29 01     AND #$01        ; drive number
D5D0: 85 7F     STA $7F
D5D2: A8        TAY
D5D3: B9 CA FE  LDA $FECA,Y     ; bit model for drive
D5D6: 8D 6D 02  STA $026D
D5D9: 20 A6 D6  JSR $D6A6       ; read attempt
D5DC: C9 02     CMP #$02
D5DE: B0 03     BCS $D5E3       ; not ok?
D5E0: 4C 6D D6  JMP $D66D       ; done

Jump from $D5DE:

D5E3: BD 5B 02  LDA $025B,X     ; command code
D5E6: 29 F0     AND #$F0        ; isolate
D5E8: 48        PHA
D5E9: C9 90     CMP #$90        ; code for write
D5EB: D0 07     BNE $D5F4       ; no
D5ED: A5 7F     LDA $7F         ; drive number
D5EF: 09 B8     ORA #$B8
D5F1: 9D 5B 02  STA $025B,X

Jump from $D5EB:

D5F4: 24 6A     BIT $6A
D5F6: 70 39     BVS $D631
D5F8: A9 00     LDA #$00
D5FA: 8D 99 02  STA $0299       ; counter for searches next to track
D5FD: 8D 9A 02  STA $029A

Jump from $D623:

D600: AC 99 02  LDY $0299       ; counter
D603: AD 9A 02  LDA $029A
D606: 38        SEC
D607: F9 DB FE  SBC $FEDB,Y     ; constants for read attempts
D60A: 8D 9A 02  STA $029A
D60D: B9 DB FE  LDA $FEDB,Y
D610: 20 76 D6  JSR $D676       ; position head next to track
D613: EE 99 02  INC $0299       ; increment counter
D616: 20 A6 D6  JSR $D6A6       ; read attempt
D619: C9 02     CMP #$02        ; return message
D61B: 90 08     BCC $D625       ; smaller than 2, ok?
D61D: AC 99 02  LDY $0299       ; load counter
D620: B9 DB FE  LDA $FEDB,Y     ; get constants
D623: D0 DB     BNE $D600       ; not yet zero (table end)?

Jump from $D61B:

D625: AD 9A 02  LDA $029A
D628: 20 76 D6  JSR $D676       ; position head
D62B: B5 00     LDA $00,X
D62D: C9 02     CMP #$02        ; return message
D62F: 90 2B     BCC $D65C       ; ok?

Jump from $D5F6:

D631: 24 6A     BIT $6A
D633: 10 0F     BPL $D644

Jump from $D65A:

D635: 68        PLA             ; command code
D636: C9 90     CMP #$90        ; for writing?
D638: D0 05     BNE $D63F       ; no
D63A: 05 7F     ORA $7F         ; drive number
D63C: 9D 5B 02  STA $025B,X     ; command code in table

Jump from $D638, $D66B, $D5BF:

D63F: B5 00     LDA $00,X       ; return message
D641: 20 0A E6  JSR $E60A       ; set error message

Jump from $D633:

D644: 68        PLA
D645: 2C 98 02  BIT $0298
D648: 30 23     BMI $D66D
D64A: 48        PHA
D64B: A9 C0     LDA #$C0        ; command code for head positioning
D64D: 05 7F     ORA $7F         ; drive number
D64F: 95 00     STA $00,X       ; in command register

Jump from $D653:

D651: B5 00     LDA $00,X
D653: 30 FC     BMI $D651       ; wait for execution
D655: 20 A6 D6  JSR $D6A6       ; attempt command execution again
D658: C9 02     CMP #$02        ; return message
D65A: B0 D9     BCS $D635       ; incorrect?

Jump from $D62F:

D65C: 68        PLA
D65D: C9 90     CMP #$90        ; command code for writing
D65F: D0 0C     BNE $D66D       ; no
D661: 05 7F     ORA $7F         ; drive number
D663: 9D 5B 02  STA $025B,X     ; in table
D666: 20 A6 D6  JSR $D6A6       ; attempt execution again
D669: C9 02     CMP #$02        ; return message
D66B: B0 D2     BCS $D63F       ; error?

Jump from $D5E0, $D648, $D65F:

D66D: 68        PLA
D66E: 85 7F     STA $7F         ; get drive number back
D670: 68        PLA
D671: A8        TAY
D672: B5 00     LDA $00,X       ; error code
D674: 18        CLC             ; end-of-execution flag
D675: 60        RTS



 $D676/54902:   Move head by half a track

Jump from $D610, $D628:

D676: C9 00     CMP #$00
D678: F0 18     BEQ $D692
D67A: 30 0C     BMI $D688

Jump from $D684:

D67C: A0 01     LDY #$01
D67E: 20 93 D6  JSR $D693       ; transmit data for head position
D681: 38        SEC
D682: E9 01     SBC #$01
D684: D0 F6     BNE $D67C
D686: F0 0A     BEQ $D692

Jump from $D67A, $D690:

D688: A0 FF     LDY #$FF
D68A: 20 93 D6  JSR $D693       ; transmit data for head position
D68D: 18        CLC
D68E: 69 01     ADC #$01
D690: D0 F6     BNE $D688

Jump from $D678, $D686:

D692: 60        RTS



 $D693/54931:   Move head one track in or out

Jump from $D67E, $D68A:

D693: 48        PHA
D694: 98        TYA
D695: A4 7F     LDY $7F         ; drive number
D697: 99 FE 02  STA $02FE,Y

Jump from $D69D:

D69A: D9 FE 02  CMP $02FE,Y     ; wait for return message from
D69D: F0 FB     BEQ $D69A
D69F: A9 00     LDA #$00        ; disk controller
D6A1: 99 FE 02  STA $02FE,Y
D6A4: 68        PLA
D6A5: 60        RTS



 $D6A6/54950:   Attempt command execution multiple times

Jump from $D5D9, $D616, $D655, $D666:

D6A6: A5 6A     LDA $6A         ; maximum number of repetitions
D6A8: 29 3F     AND #$3F
D6AA: A8        TAY

Jump from $D6C2:

D6AB: AD 6D 02  LDA $026D       ; bit for LED
D6AE: 4D 00 1C  EOR $1C00
D6B1: 8D 00 1C  STA $1C00
D6B4: BD 5B 02  LDA $025B,X     ; command
D6B7: 95 00     STA $00,X       ; transmit to disk controller

Jump from $D6BB:

D6B9: B5 00     LDA $00,X       ; and return message
D6BB: 30 FC     BMI $D6B9       ; wait
D6BD: C9 02     CMP #$02        ; ok?
D6BF: 90 03     BCC $D6C4       ; yes
D6C1: 88        DEY             ; decrement counter
D6C2: D0 E7     BNE $D6AB       ; attempt again

Jump from $D6BF:

D6C4: 48        PHA
D6C5: AD 6D 02  LDA $026D
D6C8: 0D 00 1C  ORA $1C00       ; LED off
D6CB: 8D 00 1C  STA $1C00
D6CE: 68        PLA
D6CF: 60        RTS



 $D6D0/54992:   Transmit param to disk controller

Jump from $D09B, $D0BA, $D186, $D1BE, $DCE2, $DE7F, $E3B9, $E3CB:

D6D0: 20 93 DF  JSR $DF93       ; get buffer number

Jump from $C8D7, $D03A, $D46D, $DC8F, $DD2E, $DF3D:

D6D3: 0A        ASL
D6D4: A8        TAY
D6D5: A5 80     LDA $80         ; track number
D6D7: 99 06 00  STA $06,Y       ; transmit
D6DA: A5 81     LDA $81         ; sector number
D6DC: 99 07 00  STA $07,Y       ; transmit
D6DF: A5 7F     LDA $7F         ; drive number
D6E1: 0A        ASL             ; times 2
D6E2: AA        TAX
D6E3: 60        RTS



 $D6E4/55012:   Enter file in dir

Jump from $C9B3, $D9EC:

D6E4: A5 83     LDA $83         ; secondary address
D6E6: 48        PHA
D6E7: A5 82     LDA $82         ; channel number
D6E9: 48        PHA
D6EA: A5 81     LDA $81         ; sector number
D6EC: 48        PHA
D6ED: A5 80     LDA $80         ; track number
D6EF: 48        PHA             ; save
D6F0: A9 11     LDA #$11
D6F2: 85 83     STA $83         ; secondary address 17
D6F4: 20 3B DE  JSR $DE3B       ; get track and sector number
D6F7: AD 4A 02  LDA $024A       ; file type
D6FA: 48        PHA             ; save
D6FB: A5 E2     LDA $E2         ; drive number
D6FD: 29 01     AND #$01
D6FF: 85 7F     STA $7F         ; set
D701: A6 F9     LDX $F9         ; buffer number
D703: 5D 5B 02  EOR $025B,X
D706: 4A        LSR
D707: 90 0C     BCC $D715       ; equal drive number?
D709: A2 01     LDX #$01
D70B: 8E 92 02  STX $0292       ; pointer in directory
D70E: 20 AC C5  JSR $C5AC       ; load dir and find first entry
D711: F0 1D     BEQ $D730       ; not found?
D713: D0 28     BNE $D73D       ; found?

Jump from $D707:

D715: AD 91 02  LDA $0291       ; sector number in directory
D718: F0 0C     BEQ $D726       ; equal zero
D71A: C5 81     CMP $81         ; equal sector number?
D71C: F0 1F     BEQ $D73D       ; yes
D71E: 85 81     STA $81         ; save sector number
D720: 20 60 D4  JSR $D460       ; read block
D723: 4C 3D D7  JMP $D73D

Jump from $D718:

D726: A9 01     LDA #$01
D728: 8D 92 02  STA $0292       ; pointer to one
D72B: 20 17 C6  JSR $C617       ; find next entry in directory
D72E: D0 0D     BNE $D73D       ; found?

Jump from $D711:

D730: 20 8D D4  JSR $D48D       ; write directory block
D733: A5 81     LDA $81         ; sector number
D735: 8D 91 02  STA $0291
D738: A9 02     LDA #$02
D73A: 8D 92 02  STA $0292       ; pointer to 2

Jump from $D713, $D71C, $D723, $D72E:

D73D: AD 92 02  LDA $0292
D740: 20 C8 D4  JSR $D4C8       ; set buffer pointer
D743: 68        PLA
D744: 8D 4A 02  STA $024A       ; file type
D747: C9 04     CMP #$04        ; rel-file?
D749: D0 02     BNE $D74D       ; no
D74B: 09 80     ORA #$80        ; set bit 7

Jump from $D749:

D74D: 20 F1 CF  JSR $CFF1       ; and write in buffer
D750: 68        PLA
D751: 8D 80 02  STA $0280       ; following track
D754: 20 F1 CF  JSR $CFF1       ; in buffer
D757: 68        PLA
D758: 8D 85 02  STA $0285       ; following sector
D75B: 20 F1 CF  JSR $CFF1       ; in buffer
D75E: 20 93 DF  JSR $DF93       ; get buffer number
D761: A8        TAY
D762: AD 7A 02  LDA $027A       ; pointer to drive number
D765: AA        TAX
D766: A9 10     LDA #$10        ; 16, length of filename
D768: 20 6E C6  JSR $C66E       ; write filename in buffer
D76B: A0 10     LDY #$10
D76D: A9 00     LDA #$00

Jump from $D774:

D76F: 91 94     STA ($94),Y     ; fill with zeroes at position 16
D771: C8        INY
D772: C0 1B     CPY #$1B        ; position 27 already?
D774: 90 F9     BCC $D76F       ; no
D776: AD 4A 02  LDA $024A       ; file type
D779: C9 04     CMP #$04        ; rel-file?
D77B: D0 13     BNE $D790       ; no
D77D: A0 10     LDY #$10
D77F: AD 59 02  LDA $0259       ; track
D782: 91 94     STA ($94),Y
D784: C8        INY
D785: AD 5A 02  LDA $025A       ; and sector
D788: 91 94     STA ($94),Y     ; the side-sectors in directory entry
D78A: C8        INY
D78B: AD 58 02  LDA $0258       ; record length
D78E: 91 94     STA ($94),Y     ; in directory

Jump from $D77B:

D790: 20 64 D4  JSR $D464       ; write block
D793: 68        PLA
D794: 85 82     STA $82         ; channel number
D796: AA        TAX
D797: 68        PLA
D798: 85 83     STA $83         ; secondary address
D79A: AD 91 02  LDA $0291
D79D: 85 D8     STA $D8
D79F: 9D 60 02  STA $0260,X
D7A2: AD 92 02  LDA $0292
D7A5: 85 DD     STA $DD
D7A7: 9D 66 02  STA $0266,X
D7AA: AD 4A 02  LDA $024A       ; file type
D7AD: 85 E7     STA $E7
D7AF: A5 7F     LDA $7F         ; drive number
D7B1: 85 E2     STA $E2
D7B3: 60        RTS



 $D7B4/55220:   OPEN command, secondary addr 15

Jump from $C15D:

D7B4: A5 83     LDA $83         ; secondary address
D7B6: 8D 4C 02  STA $024C
D7B9: 20 B3 C2  JSR $C2B3       ; get line length, erase flags
D7BC: 8E 2A 02  STX $022A
D7BF: AE 00 02  LDX $0200       ; first character from buffer
D7C2: AD 4C 02  LDA $024C       ; secondary address
D7C5: D0 2C     BNE $D7F3       ; not equal 0 (LOAD)?



 $D7C7/55239:   -Check '*' Last file

D7C7: E0 2A     CPX #$2A        ; '*'
D7C9: D0 28     BNE $D7F3
D7CB: A5 7E     LDA $7E         ; last track number
D7CD: F0 4D     BEQ $D81C
D7CF: 85 80     STA $80         ; track number
D7D1: AD 6E 02  LDA $026E       ; last drive number
D7D4: 85 7F     STA $7F         ; drive number
D7D6: 85 E2     STA $E2
D7D8: A9 02     LDA #$02
D7DA: 85 E7     STA $E7         ; set data type to program
D7DC: AD 6F 02  LDA $026F       ; last sector number
D7DF: 85 81     STA $81         ; sector
D7E1: 20 00 C1  JSR $C100       ; turn LED on
D7E4: 20 46 DC  JSR $DC46       ; allocate buffer, read block
D7E7: A9 04     LDA #$04        ; file type
D7E9: 05 7F     ORA $7F         ; drive number

Jump from $D812:

D7EB: A6 82     LDX $82         ; channel number
D7ED: 99 EC 00  STA $EC,Y       ; set flag
D7F0: 4C 94 C1  JMP $C194       ; done



 $D7F3/55283:   -Check '$' Directory

Jump from $D7C5, $D7C9:

D7F3: E0 24     CPX #$24        ; '$'
D7F5: D0 1E     BNE $D815       ; no
D7F7: AD 4C 02  LDA $024C       ; secondary address
D7FA: D0 03     BNE $D7FF       ; not equal to zero?
D7FC: 4C 55 DA  JMP $DA55       ; OPEN $

Jump from $D7FA:

D7FF: 20 D1 C1  JSR $C1D1       ; analyze line to end
D802: AD 85 FE  LDA $FE85       ; 18, directory track
D805: 85 80     STA $80         ; track
D807: A9 00     LDA #$00
D809: 85 81     STA $81         ; sector 0
D80B: 20 46 DC  JSR $DC46       ; allocate buffer, read block
D80E: A5 7F     LDA $7F         ; drive number
D810: 09 02     ORA #$02
D812: 4C EB D7  JMP $D7EB       ; continue as above



 $D815/55317:   -Check '#' Channel

Jump from $D7F5:

D815: E0 23     CPX #$23        ; "#"
D817: D0 12     BNE $D82B
D819: 4C 84 CB  JMP $CB84       ; open direct access file

Jump from $D7CD:

D81C: A9 02     LDA #$02
D81E: 8D 96 02  STA $0296       ; file type program
D821: A9 00     LDA #$00
D823: 85 7F     STA $7F         ; drive 0
D825: 8D 8E 02  STA $028E
D828: 20 42 D0  JSR $D042       ; load BAM

Jump from $D817:

D82B: 20 E5 C1  JSR $C1E5       ; analyze line
D82E: D0 04     BNE $D834       ; colon found?
D830: A2 00     LDX #$00
D832: F0 0C     BEQ $D840

Jump from $D82E:

D834: 8A        TXA             ; comma found?
D835: F0 05     BEQ $D83C       ; no
D837: A9 30     LDA #$30
D839: 4C C8 C1  JMP $C1C8       ; 30, 'syntax error'

Jump from $D835:

D83C: 88        DEY
D83D: F0 01     BEQ $D840
D83F: 88        DEY

Jump from $D832, $D83D:

D840: 8C 7A 02  STY $027A       ; pointer to drive number
D843: A9 8D     LDA #$8D        ; shift CR
D845: 20 68 C2  JSR $C268       ; analyze line to end
D848: E8        INX
D849: 8E 78 02  STX $0278       ; comma counter
D84C: 20 12 C3  JSR $C312       ; get drive number
D84F: 20 CA C3  JSR $C3CA       ; check drive number
D852: 20 9D C4  JSR $C49D       ; find file entry in directory
D855: A2 00     LDX #$00        ; default values
D857: 8E 58 02  STX $0258       ; record length
D85A: 8E 97 02  STX $0297
D85D: 8E 4A 02  STX $024A       ; file type
D860: E8        INX
D861: EC 77 02  CPX $0277       ; comma before equal sign?
D864: B0 10     BCS $D876       ; no
D866: 20 09 DA  JSR $DA09       ; get file type and control mode
D869: E8        INX
D86A: EC 77 02  CPX $0277       ; additional comma?
D86D: B0 07     BCS $D876       ; no
D86F: C0 04     CPY #$04
D871: F0 3E     BEQ $D8B1
D873: 20 09 DA  JSR $DA09       ; get file type and control method

Jump from $D864, $D86D, $D8BD, $D8C4:

D876: AE 4C 02  LDX $024C
D879: 86 83     STX $83         ; secondary address
D87B: E0 02     CPX #$02        ; greater than 2?
D87D: B0 12     BCS $D891       ; yes
D87F: 8E 97 02  STX $0297       ; 0 or 1 (LOAD or SAVE)
D882: A9 40     LDA #$40
D884: 8D F9 02  STA $02F9
D887: AD 4A 02  LDA $024A       ; file type
D88A: D0 1B     BNE $D8A7       ; not deleted
D88C: A9 02     LDA #$02        ; PRG
D88E: 8D 4A 02  STA $024A       ; as file type

Jump from $D87D:

D891: AD 4A 02  LDA $024A
D894: D0 11     BNE $D8A7
D896: A5 E7     LDA $E7
D898: 29 07     AND #$07        ; get file type and command line
D89A: 8D 4A 02  STA $024A
D89D: AD 80 02  LDA $0280       ; track number
D8A0: D0 05     BNE $D8A7       ; not equal zero?
D8A2: A9 01     LDA #$01
D8A4: 8D 4A 02  STA $024A       ; file type sequential

Jump from $D88A, $D894, $D8A0:

D8A7: AD 97 02  LDA $0297       ; control method
D8AA: C9 01     CMP #$01        ; 'W'
D8AC: F0 18     BEQ $D8C6       ; yes
D8AE: 4C 40 D9  JMP $D940

Jump from $D871:

D8B1: BC 7A 02  LDY $027A,X     ; pointer behind second comma
D8B4: B9 00 02  LDA $0200,Y     ; get value
D8B7: 8D 58 02  STA $0258       ; record length
D8BA: AD 80 02  LDA $0280       ; track number
D8BD: D0 B7     BNE $D876
D8BF: A9 01     LDA #$01        ; 'W'
D8C1: 8D 97 02  STA $0297       ; as second method
D8C4: D0 B0     BNE $D876

Jump from $D8AC:

D8C6: A5 E7     LDA $E7         ; file type
D8C8: 29 80     AND #$80        ; isolate wildcard flag
D8CA: AA        TAX
D8CB: D0 14     BNE $D8E1       ; wildcard in name
D8CD: A9 20     LDA #$20
D8CF: 24 E7     BIT $E7         ; was file closed?
D8D1: F0 06     BEQ $D8D9       ; yes
D8D3: 20 B6 C8  JSR $C8B6       ; byte 0 in buffer and write block
D8D6: 4C E3 D9  JMP $D9E3

Jump from $D8D1:

D8D9: AD 80 02  LDA $0280       ; track number of the first block
D8DC: D0 03     BNE $D8E1       ; already existing
D8DE: 4C E3 D9  JMP $D9E3

Jump from $D8CB, $D8DC:

D8E1: AD 00 02  LDA $0200       ; first character from input buffer
D8E4: C9 40     CMP #$40        ; '@'?
D8E6: F0 0D     BEQ $D8F5       ; yes
D8E8: 8A        TXA
D8E9: D0 05     BNE $D8F0       ; wildcard set?
D8EB: A9 63     LDA #$63
D8ED: 4C C8 C1  JMP $C1C8       ; 63, 'file exists'

Jump from $D8E9:

D8F0: A9 33     LDA #$33
D8F2: 4C C8 C1  JMP $C1C8       ; 33, 'syntax error'



 $D8F5/55541:   Open a file with overwriting (@)

Jump from $D8E6:

D8F5: A5 E7     LDA $E7         ; file type
D8F7: 29 07     AND #$07        ; isolate
D8F9: CD 4A 02  CMP $024A
D8FC: D0 67     BNE $D965       ; file type different?
D8FE: C9 04     CMP #$04        ; rel-file?
D900: F0 63     BEQ $D965       ; 64, 'file type mismatch'
D902: 20 DA DC  JSR $DCDA
D905: A5 82     LDA $82
D907: 8D 70 02  STA $0270       ; save channel number
D90A: A9 11     LDA #$11
D90C: 85 83     STA $83
D90E: 20 EB D0  JSR $D0EB       ; open read channel
D911: AD 94 02  LDA $0294
D914: 20 C8 D4  JSR $D4C8       ; set buffer pointer for directory
D917: A0 00     LDY #$00
D919: B1 94     LDA ($94),Y     ; file type
D91B: 09 20     ORA #$20        ; set bit 5, open file
D91D: 91 94     STA ($94),Y
D91F: A0 1A     LDY #$1A
D921: A5 80     LDA $80         ; track
D923: 91 94     STA ($94),Y
D925: C8        INY
D926: A5 81     LDA $81         ; and sector
D928: 91 94     STA ($94),Y     ; for open with at-sign
D92A: AE 70 02  LDX $0270       ; channel number
D92D: A5 D8     LDA $D8
D92F: 9D 60 02  STA $0260,X     ; pointer to directory block
D932: A5 DD     LDA $DD
D934: 9D 66 02  STA $0266,X
D937: 20 3B DE  JSR $DE3B       ; get track and sector number
D93A: 20 64 D4  JSR $D464       ; write block
D93D: 4C EF D9  JMP $D9EF       ; prepare track, sector, and drive number



 $D940/55616:   ?

Jump from $D8AE:

D940: AD 80 02  LDA $0280       ; first track number
D943: D0 05     BNE $D94A       ; file not erased?
D945: A9 62     LDA #$62
D947: 4C C8 C1  JMP $C1C8       ; 62, 'file not found'

Jump from $D943:

D94A: AD 97 02  LDA $0297       ; control mode
D94D: C9 03     CMP #$03        ; 'M'
D94F: F0 0B     BEQ $D95C       ; yes, then no test of unclosed file
D951: A9 20     LDA #$20        ; bit 5
D953: 24 E7     BIT $E7         ; test in file type
D955: F0 05     BEQ $D95C       ; not set, ok
D957: A9 60     LDA #$60
D959: 4C C8 C1  JMP $C1C8

Jump from $D94F, $D955:

D95C: A5 E7     LDA $E7
D95E: 29 07     AND #$07        ; isolate file type
D960: CD 4A 02  CMP $024A
D963: F0 05     BEQ $D96A

Jump from $D978, $D8FC, $D900:

D965: A9 64     LDA #$64
D967: 4C C8 C1  JMP $C1C8       ; 64, 'file type mismatch'

Jump from $D963:

D96A: A0 00     LDY #$00
D96C: 8C 79 02  STY $0279
D96F: AE 97 02  LDX $0297       ; control mode
D972: E0 02     CPX #$02        ; 'A', append
D974: D0 1A     BNE $D990       ; no
D976: C9 04     CMP #$04        ; rel-file?
D978: F0 EB     BEQ $D965
D97A: B1 94     LDA ($94),Y
D97C: 29 4F     AND #$4F
D97E: 91 94     STA ($94),Y
D980: A5 83     LDA $83
D982: 48        PHA
D983: A9 11     LDA #$11
D985: 85 83     STA $83         ; channel 17
D987: 20 3B DE  JSR $DE3B       ; get track and sector number
D98A: 20 64 D4  JSR $D464       ; write block
D98D: 68        PLA
D98E: 85 83     STA $83         ; get channel number back

Jump from $D974:

D990: 20 A0 D9  JSR $D9A0
D993: AD 97 02  LDA $0297       ; control mode
D996: C9 02     CMP #$02
D998: D0 55     BNE $D9EF
D99A: 20 2A DA  JSR $DA2A
D99D: 4C 94 C1  JMP $C194       ; done



 $D9A0/55712:   Open file for reading

Jump from $CA26, $D990:

D9A0: A0 13     LDY #$13
D9A2: B1 94     LDA ($94),Y     ; track
D9A4: 8D 59 02  STA $0259
D9A7: C8        INY
D9A8: B1 94     LDA ($94),Y
D9AA: 8D 5A 02  STA $025A
D9AD: C8        INY
D9AE: B1 94     LDA ($94),Y     ; record length
D9B0: AE 58 02  LDX $0258       ; last record len
D9B3: 8D 58 02  STA $0258
D9B6: 8A        TXA
D9B7: F0 0A     BEQ $D9C3
D9B9: CD 58 02  CMP $0258
D9BC: F0 05     BEQ $D9C3
D9BE: A9 50     LDA #$50
D9C0: 20 C8 C1  JSR $C1C8       ; 50, 'record not present'

Jump from $D9B7, $D9BC:

D9C3: AE 79 02  LDX $0279
D9C6: BD 80 02  LDA $0280,X     ; track
D9C9: 85 80     STA $80
D9CB: BD 85 02  LDA $0285,X     ; sector
D9CE: 85 81     STA $81
D9D0: 20 46 DC  JSR $DC46
D9D3: A4 82     LDY $82
D9D5: AE 79 02  LDX $0279
D9D8: B5 D8     LDA $D8,X
D9DA: 99 60 02  STA $0260,Y
D9DD: B5 DD     LDA $DD,X
D9DF: 99 66 02  STA $0266,Y
D9E2: 60        RTS



 $D9E3/55779:   Open file for writing

Jump from $D8D6, $D8DE:

D9E3: A5 E2     LDA $E2         ; drive number
D9E5: 29 01     AND #$01
D9E7: 85 7F     STA $7F
D9E9: 20 DA DC  JSR $DCDA
D9EC: 20 E4 D6  JSR $D6E4

Jump from $D93D, $D998:

D9EF: A5 83     LDA $83         ; channel number
D9F1: C9 02     CMP #$02
D9F3: B0 11     BCS $DA06
D9F5: 20 3E DE  JSR $DE3E
D9F8: A5 80     LDA $80
D9FA: 85 7E     STA $7E
D9FC: A5 7F     LDA $7F
D9FE: 8D 6E 02  STA $026E
DA01: A5 81     LDA $81
DA03: 8D 6F 02  STA $026F

Jump from $D9F3:

DA06: 4C 99 C1  JMP $C199



 $DA09/55817:   Check file type and control mode

Jump from $D866, $D873:

DA09: BC 7A 02  LDY $027A,X     ; pointer in command line
DA0C: B9 00 02  LDA $0200,Y     ; get characters from line
DA0F: A0 04     LDY #$04

Jump from $DA17:

DA11: 88        DEY
DA12: 30 08     BMI $DA1C
DA14: D9 B2 FE  CMP $FEB2,Y     ; control modes 'R', 'W', 'A', 'M'
DA17: D0 F8     BNE $DA11
DA19: 8C 97 02  STY $0297       ; save

Jump from $DA12:

DA1C: A0 05     LDY #$05

Jump from $DA24:

DA1E: 88        DEY
DA1F: 30 08     BMI $DA29
DA21: D9 B6 FE  CMP $FEB6,Y     ; file types 'D','S','P','U','L'
DA24: D0 F8     BNE $DA1E
DA26: 8C 4A 02  STY $024A       ; save

Jump from $DA1F:

DA29: 60        RTS



 $DA2A/55850:   Preparation for append

Jump from $DA32, $C996, $D99A:

DA2A: 20 39 CA  JSR $CA39       ; open channel to read, get byte
DA2D: A9 80     LDA #$80
DA2F: 20 A6 DD  JSR $DDA6       ; last byte?
DA32: F0 F6     BEQ $DA2A       ; no
DA34: 20 95 DE  JSR $DE95       ; get track and sector number
DA37: A6 81     LDX $81         ; sector number
DA39: E8        INX
DA3A: 8A        TXA
DA3B: D0 05     BNE $DA42       ; not $FF?
DA3D: 20 A3 D1  JSR $D1A3       ; close buffer, write block
DA40: A9 02     LDA #$02

Jump from $DA3B:

DA42: 20 C8 D4  JSR $D4C8       ; buffer pointer to 2
DA45: A6 82     LDX $82         ; channel number
DA47: A9 01     LDA #$01
DA49: 95 F2     STA $F2,X       ; set flag for WRITE
DA4B: A9 80     LDA #$80
DA4D: 05 82     ORA $82
DA4F: A6 83     LDX $83
DA51: 9D 2B 02  STA $022B,X     ; channel number in table
DA54: 60        RTS



 $DA55/55893:   Open directory

Jump from $D7FC:

DA55: A9 0C     LDA #$0C        ; command number 12
DA57: 8D 2A 02  STA $022A
DA5A: A9 00     LDA #$00
DA5C: AE 74 02  LDX $0274
DA5F: CA        DEX
DA60: F0 0B     BEQ $DA6D
DA62: CA        DEX
DA63: D0 21     BNE $DA86
DA65: AD 01 02  LDA $0201       ; second character
DA68: 20 BD C3  JSR $C3BD       ; get drive number
DA6B: 30 19     BMI $DA86       ; not a plain number?

Jump from $DA60:

DA6D: 85 E2     STA $E2
DA6F: EE 77 02  INC $0277
DA72: EE 78 02  INC $0278
DA75: EE 7A 02  INC $027A
DA78: A9 80     LDA #$80
DA7A: 85 E7     STA $E7         ; set wildcard flag
DA7C: A9 2A     LDA #$2A        ; '*'
DA7E: 8D 00 02  STA $0200       ; as file name in command buffer
DA81: 8D 01 02  STA $0201
DA84: D0 18     BNE $DA9E       ; absolute jump

Jump from $DA63, $DA6B:

DA86: 20 E5 C1  JSR $C1E5       ; test input line to ":"
DA89: D0 05     BNE $DA90       ; found?
DA8B: 20 DC C2  JSR $C2DC       ; erase flags
DA8E: A0 03     LDY #$03

Jump from $DA89:

DA90: 88        DEY
DA91: 88        DEY
DA92: 8C 7A 02  STY $027A       ; pointer to drive number in command
DA95: 20 00 C2  JSR $C200       ; analyze line
DA98: 20 98 C3  JSR $C398       ; ascertain file type
DA9B: 20 20 C3  JSR $C320       ; get drive number

Jump from $DA84:

DA9E: 20 CA C3  JSR $C3CA       ; initialize drive if necessary
DAA1: 20 B7 C7  JSR $C7B7       ; prepare disk title
DAA4: 20 9D C4  JSR $C49D       ; load directory
DAA7: 20 9E EC  JSR $EC9E       ; create and prepare directory
DAAA: 20 37 D1  JSR $D137       ; get byte from buffer
DAAD: A6 82     LDX $82         ; channel number
DAAF: 9D 3E 02  STA $023E,X     ; byte in output register
DAB2: A5 7F     LDA $7F         ; drive number
DAB4: 8D 8E 02  STA $028E       ; save as last drive number
DAB7: 09 04     ORA #$04
DAB9: 95 EC     STA $EC,X       ; PRG-flag
DABB: A9 00     LDA #$00
DABD: 85 A3     STA $A3         ; set pointer back in input buffer
DABF: 60        RTS



 $DAC0/56000:   Close routine

Jump from $E8CE:

DAC0: A9 00     LDA #$00
DAC2: 8D F9 02  STA $02F9
DAC5: A5 83     LDA $83         ; secondary address
DAC7: D0 0B     BNE $DAD4       ; not zero?
DAC9: A9 00     LDA #$00        ; secondary address 0, LOAD
DACB: 8D 54 02  STA $0254
DACE: 20 27 D2  JSR $D227       ; close channel

Jump from $DADF:

DAD1: 4C DA D4  JMP $D4DA       ; close internal channels 17 & 18

Jump from $DAC7:

DAD4: C9 0F     CMP #$0F        ; 15
DAD6: F0 14     BEQ $DAEC       ; yes, close all channels
DAD8: 20 02 DB  JSR $DB02       ; close file
DADB: A5 83     LDA $83         ; secondary address
DADD: C9 02     CMP #$02
DADF: 90 F0     BCC $DAD1       ; smaller than 2?
DAE1: AD 6C 02  LDA $026C
DAE4: D0 03     BNE $DAE9
DAE6: 4C 94 C1  JMP $C194       ; termination

Jump from $DAE4:

DAE9: 4C AD C1  JMP $C1AD

Jump from $DAD6:

DAEC: A9 0E     LDA #$0E        ; 14
DAEE: 85 83     STA $83         ; secondary address

Jump from $DAF5:

DAF0: 20 02 DB  JSR $DB02       ; close file
DAF3: C6 83     DEC $83         ; next secondary address
DAF5: 10 F9     BPL $DAF0
DAF7: AD 6C 02  LDA $026C
DAFA: D0 03     BNE $DAFF
DAFC: 4C 94 C1  JMP $C194       ; termination

Jump from $DAFA:

DAFF: 4C AD C1  JMP $C1AD



 $DB02/56066:   Close file

Jump from $C9F7, $DAD8, $DAF0:

DB02: A6 83     LDX $83         ; secondary address
DB04: BD 2B 02  LDA $022B,X     ; get channel number
DB07: C9 FF     CMP #$FF        ; no channel associated?
DB09: D0 01     BNE $DB0C
DB0B: 60        RTS             ; no, then none

Jump from $DB09:

DB0C: 29 0F     AND #$0F        ; isolate channel number
DB0E: 85 82     STA $82
DB10: 20 25 D1  JSR $D125       ; check data type
DB13: C9 07     CMP #$07        ; direct access?
DB15: F0 0F     BEQ $DB26       ; yes
DB17: C9 04     CMP #$04        ; rel-file?
DB19: F0 11     BEQ $DB2C       ; yes
DB1B: 20 07 D1  JSR $D107       ; channel for writing open
DB1E: B0 09     BCS $DB29       ; no file for writing?
DB20: 20 62 DB  JSR $DB62       ; write last block
DB23: 20 A5 DB  JSR $DBA5       ; write entry in directory and block

Jump from $DB15:

DB26: 20 F4 EE  JSR $EEF4       ; write BAM

Jump from $DB1E:

DB29: 4C 27 D2  JMP $D227       ; close channel

Jump from $DB19:

DB2C: 20 F1 DD  JSR $DDF1       ; get buffer number, write block
DB2F: 20 1E CF  JSR $CF1E       ; change buffer
DB32: 20 CB E1  JSR $E1CB       ; get last side-sector
DB35: A6 D5     LDX $D5         ; side-sector number
DB37: 86 73     STX $73
DB39: E6 73     INC $73
DB3B: A9 00     LDA #$00
DB3D: 85 70     STA $70
DB3F: 85 71     STA $71
DB41: A5 D6     LDA $D6
DB43: 38        SEC
DB44: E9 0E     SBC #$0E        ; minus 14 for pointer
DB46: 85 72     STA $72
DB48: 20 51 DF  JSR $DF51       ; calculate block number of file
DB4B: A6 82     LDX $82         ; channel number
DB4D: A5 70     LDA $70
DB4F: 95 B5     STA $B5,X       ; record number lo
DB51: A5 71     LDA $71
DB53: 95 BB     STA $BB,X       ; record number hi
DB55: A9 40     LDA #$40
DB57: 20 A6 DD  JSR $DDA6       ; bit 6 set?
DB5A: F0 03     BEQ $DB5F       ; no
DB5C: 20 A5 DB  JSR $DBA5       ; enter in directory

Jump from $DB5A:

DB5F: 4C 27 D2  JMP $D227       ; close channel



 $DB62/56162:   Write last block

Jump from $DB20:

DB62: A6 82     LDX $82         ; channel number
DB64: B5 B5     LDA $B5,X       ; record number lo
DB66: 15 BB     ORA $BB,X       ; record number hi
DB68: D0 0C     BNE $DB76       ; not zero?
DB6A: 20 E8 D4  JSR $D4E8       ; set buffer pointer
DB6D: C9 02     CMP #$02
DB6F: D0 05     BNE $DB76       ; not 2
DB71: A9 0D     LDA #$0D        ; CR
DB73: 20 F1 CF  JSR $CFF1       ; in buffer

Jump from $DB68, $DB6F:

DB76: 20 E8 D4  JSR $D4E8       ; set buffer pointer
DB79: C9 02     CMP #$02        ; now equal to 2?
DB7B: D0 0F     BNE $DB8C       ; no
DB7D: 20 1E CF  JSR $CF1E       ; change buffer
DB80: A6 82     LDX $82         ; channel number
DB82: B5 B5     LDA $B5,X       ; record number lo
DB84: D0 02     BNE $DB88
DB86: D6 BB     DEC $BB,X       ; decrement block number hi

Jump from $DB84:

DB88: D6 B5     DEC $B5,X       ; and block number lo
DB8A: A9 00     LDA #$00

Jump from $DB7B:

DB8C: 38        SEC
DB8D: E9 01     SBC #$01        ; set pointer
DB8F: 48        PHA
DB90: A9 00     LDA #$00
DB92: 20 C8 D4  JSR $D4C8       ; buffer pointer to zero
DB95: 20 F1 CF  JSR $CFF1       ; write zero in buffer
DB98: 68        PLA             ; second byte = pointer to end
DB99: 20 F1 CF  JSR $CFF1       ; write in buffer
DB9C: 20 C7 D0  JSR $D0C7       ; write block to disk
DB9F: 20 99 D5  JSR $D599       ; and verify
DBA2: 4C 1E CF  JMP $CF1E       ; change buffer



 $DBA5/56229:   Directory entry

Jump from $DB23, $DB5C:

DBA5: A6 82     LDX $82         ; channel number
DBA7: 8E 70 02  STX $0270       ; save
DBAA: A5 83     LDA $83         ; secondary address
DBAC: 48        PHA             ; save
DBAD: BD 60 02  LDA $0260,X     ; sector number in directory
DBB0: 85 81     STA $81         ; set
DBB2: BD 66 02  LDA $0266,X     ; pointer in directory
DBB5: 8D 94 02  STA $0294
DBB8: B5 EC     LDA $EC,X
DBBA: 29 01     AND #$01
DBBC: 85 7F     STA $7F         ; drive number
DBBE: AD 85 FE  LDA $FE85       ; 18, directory track
DBC1: 85 80     STA $80         ; set
DBC3: 20 93 DF  JSR $DF93       ; increment buffer number
DBC6: 48        PHA
DBC7: 85 F9     STA $F9
DBC9: 20 60 D4  JSR $D460       ; read directory block
DBCC: A0 00     LDY #$00
DBCE: BD E0 FE  LDA $FEE0,X     ; buffer address
DBD1: 85 87     STA $87
DBD3: AD 94 02  LDA $0294       ; buffer pointer
DBD6: 85 86     STA $86
DBD8: B1 86     LDA ($86),Y     ; file type
DBDA: 29 20     AND #$20        ; file closed?
DBDC: F0 43     BEQ $DC21       ; yes
DBDE: 20 25 D1  JSR $D125       ; check file type
DBE1: C9 04     CMP #$04        ; rel-file?
DBE3: F0 44     BEQ $DC29       ; yes
DBE5: B1 86     LDA ($86),Y
DBE7: 29 8F     AND #$8F        ; erase bits 4,5, and 6
DBE9: 91 86     STA ($86),Y     ; in file type
DBEB: C8        INY
DBEC: B1 86     LDA ($86),Y     ; track number
DBEE: 85 80     STA $80
DBF0: 84 71     STY $71
DBF2: A0 1B     LDY #$1B
DBF4: B1 86     LDA ($86),Y     ; sector number of the file for
DBF6: 48        PHA             ; overwriting
DBF7: 88        DEY
DBF8: B1 86     LDA ($86),Y     ; track number for overwriting
DBFA: D0 0A     BNE $DC06       ; set?
DBFC: 85 80     STA $80         ; set track number
DBFE: 68        PLA
DBFF: 85 81     STA $81         ; sector number
DC01: A9 67     LDA #$67
DC03: 20 45 E6  JSR $E645       ; 67, 'illegal track or sector'

Jump from $DBFA:

DC06: 48        PHA
DC07: A9 00     LDA #$00
DC09: 91 86     STA ($86),Y     ; erase track number
DC0B: C8        INY
DC0C: 91 86     STA ($86),Y     ; and sector number of the
DC0E: 68        PLA             ; substitute file
DC0F: A4 71     LDY $71
DC11: 91 86     STA ($86),Y
DC13: C8        INY             ; set track & sector number of the new file
DC14: B1 86     LDA ($86),Y
DC16: 85 81     STA $81
DC18: 68        PLA
DC19: 91 86     STA ($86),Y
DC1B: 20 7D C8  JSR $C87D       ; erase all files
DC1E: 4C 29 DC  JMP $DC29

Jump from $DBDC:

DC21: B1 86     LDA ($86),Y     ; get file type
DC23: 29 0F     AND #$0F        ; isolate bits 0-3
DC25: 09 80     ORA #$80        ; set bit 7 for closed file
DC27: 91 86     STA ($86),Y

Jump from $DBE3, $DC1E:

DC29: AE 70 02  LDX $0270       ; channel number
DC2C: A0 1C     LDY #$1C
DC2E: B5 B5     LDA $B5,X       ; block number lo
DC30: 91 86     STA ($86),Y     ; in directory entry
DC32: C8        INY
DC33: B5 BB     LDA $BB,X       ; and block number hi
DC35: 91 86     STA ($86),Y     ; write
DC37: 68        PLA             ; buffer number
DC38: AA        TAX
DC39: A9 90     LDA #$90        ; code for 'writing'
DC3B: 05 7F     ORA $7F
DC3D: 20 90 D5  JSR $D590       ; write block
DC40: 68        PLA
DC41: 85 83     STA $83         ; secondary address
DC43: 4C 07 D1  JMP $D107       ; open channel for writing



 $DC46/56390:   Read block, allocate buffer

Jump from $D47E, $D7E4, $D80B, $D9D0:

DC46: A9 01     LDA #$01
DC48: 20 E2 D1  JSR $D1E2       ; find channel and buffer for read
DC4B: 20 B6 DC  JSR $DCB6       ; set pointer
DC4E: AD 4A 02  LDA $024A       ; file type
DC51: 48        PHA             ; save
DC52: 0A        ASL
DC53: 05 7F     ORA $7F         ; drive number
DC55: 95 EC     STA $EC,X
DC57: 20 9B D0  JSR $D09B       ; read block in buffer
DC5A: A6 82     LDX $82         ; channel number
DC5C: A5 80     LDA $80         ; track
DC5E: D0 05     BNE $DC65       ; following track?
DC60: A5 81     LDA $81         ; sector
DC62: 9D 44 02  STA $0244,X     ; as end pointer

Jump from $DC5E:

DC65: 68        PLA             ; file type
DC66: C9 04     CMP #$04        ; rel-file?
DC68: D0 3F     BNE $DCA9       ; no
DC6A: A4 83     LDY $83         ; secondary address
DC6C: B9 2B 02  LDA $022B,Y     ; channel number
DC6F: 09 40     ORA #$40
DC71: 99 2B 02  STA $022B,Y     ; set flag for READ and WRITE
DC74: AD 58 02  LDA $0258       ; record length
DC77: 95 C7     STA $C7,X
DC79: 20 8E D2  JSR $D28E       ; find buffer for side-sector
DC7C: 10 03     BPL $DC81       ; found?
DC7E: 4C 0F D2  JMP $D20F       ; 70, 'no channel'

Jump from $DC7C:

DC81: A6 82     LDX $82         ; channel number
DC83: 95 CD     STA $CD,X
DC85: AC 59 02  LDY $0259
DC88: 84 80     STY $80         ; track for side-sector
DC8A: AC 5A 02  LDY $025A
DC8D: 84 81     STY $81         ; sector for side-sector
DC8F: 20 D3 D6  JSR $D6D3       ; transmit parameters to disk controller
DC92: 20 73 DE  JSR $DE73       ; read block
DC95: 20 99 D5  JSR $D599       ; and verify

Jump from $DD8A:

DC98: A6 82     LDX $82         ; channel number
DC9A: A9 02     LDA #$02
DC9C: 95 C1     STA $C1,X       ; pointer for writing
DC9E: A9 00     LDA #$00
DCA0: 20 C8 D4  JSR $D4C8       ; buffer pointer to zero
DCA3: 20 53 E1  JSR $E153       ; find next record
DCA6: 4C 3E DE  JMP $DE3E       ; get track and sector number

Jump from $DC68:

DCA9: 20 56 D1  JSR $D156       ; get byte from buffer
DCAC: A6 82     LDX $82         ; channel number
DCAE: 9D 3E 02  STA $023E,X     ; byte in output register
DCB1: A9 88     LDA #$88        ; set flag for READ
DCB3: 95 F2     STA $F2,X
DCB5: 60        RTS



 $DCB6/56502:   Reset pointer

Jump from $DC4B, $DCE5:

DCB6: A6 82     LDX $82         ; channel number
DCB8: B5 A7     LDA $A7,X       ; buffer number
DCBA: 0A        ASL             ; times 2
DCBB: A8        TAY
DCBC: A9 02     LDA #$02
DCBE: 99 99 00  STA $99,Y       ; buffer pointer lo
DCC1: B5 AE     LDA $AE,X
DCC3: 09 80     ORA #$80        ; set bit 7
DCC5: 95 AE     STA $AE,X
DCC7: 0A        ASL
DCC8: A8        TAY
DCC9: A9 02     LDA #$02
DCCB: 99 99 00  STA $99,Y       ; buffer pointer lo
DCCE: A9 00     LDA #$00
DCD0: 95 B5     STA $B5,X       ; block number lo
DCD2: 95 BB     STA $BB,X       ; block number hi
DCD4: A9 00     LDA #$00
DCD6: 9D 44 02  STA $0244,X     ; end pointer
DCD9: 60        RTS



 $DCDA/56538:   Construct a new block

Jump from $D48A, $D902, $D9E9:

DCDA: 20 A9 F1  JSR $F1A9       ; find free sector in BAM
DCDD: A9 01     LDA #$01
DCDF: 20 DF D1  JSR $D1DF       ; open channel
DCE2: 20 D0 D6  JSR $D6D0       ; transmit parameter to disk controller
DCE5: 20 B6 DC  JSR $DCB6       ; reset pointer
DCE8: A6 82     LDX $82         ; channel number
DCEA: AD 4A 02  LDA $024A       ; file type
DCED: 48        PHA
DCEE: 0A        ASL
DCEF: 05 7F     ORA $7F         ; drive number
DCF1: 95 EC     STA $EC,X       ; save as flag
DCF3: 68        PLA
DCF4: C9 04     CMP #$04        ; rel-file?
DCF6: F0 05     BEQ $DCFD       ; yes
DCF8: A9 01     LDA #$01
DCFA: 95 F2     STA $F2,X       ; set WRITE flag
DCFC: 60        RTS

Jump from $DCF6:

DCFD: A4 83     LDY $83         ; secondary address
DCFF: B9 2B 02  LDA $022B,Y     ; channel number in table
DD02: 29 3F     AND #$3F        ; erase the top two bits
DD04: 09 40     ORA #$40        ; set bit 6
DD06: 99 2B 02  STA $022B,Y     ; READ and WRITE flag
DD09: AD 58 02  LDA $0258       ; record length
DD0C: 95 C7     STA $C7,X       ; in table
DD0E: 20 8E D2  JSR $D28E       ; find buffer
DD11: 10 03     BPL $DD16       ; found?
DD13: 4C 0F D2  JMP $D20F       ; 70, 'no channel'

Jump from $DD11:

DD16: A6 82     LDX $82         ; channel number
DD18: 95 CD     STA $CD,X       ; buffer number for side-sector
DD1A: 20 C1 DE  JSR $DEC1       ; erase buffer
DD1D: 20 1E F1  JSR $F11E       ; find free block in BAM
DD20: A5 80     LDA $80         ; track
DD22: 8D 59 02  STA $0259       ; for side-sector
DD25: A5 81     LDA $81         ; sector
DD27: 8D 5A 02  STA $025A       ; for side-sector
DD2A: A6 82     LDX $82         ; channel number
DD2C: B5 CD     LDA $CD,X       ; buffer number
DD2E: 20 D3 D6  JSR $D6D3       ; transmit parameter to disk controller
DD31: A9 00     LDA #$00
DD33: 20 E9 DE  JSR $DEE9       ; buffer pointer to zero
DD36: A9 00     LDA #$00
DD38: 20 8D DD  JSR $DD8D
DD3B: A9 11     LDA #$11        ; 17
DD3D: 20 8D DD  JSR $DD8D       ; as end pointer in buffer
DD40: A9 00     LDA #$00        ; zero
DD42: 20 8D DD  JSR $DD8D       ; as side-sector number in buffer
DD45: AD 58 02  LDA $0258       ; record length
DD48: 20 8D DD  JSR $DD8D       ; in buffer
DD4B: A5 80     LDA $80         ; track number of this block
DD4D: 20 8D DD  JSR $DD8D       ; in buffer
DD50: A5 81     LDA $81         ; sector number
DD52: 20 8D DD  JSR $DD8D       ; in buffer
DD55: A9 10     LDA #$10        ; 16
DD57: 20 E9 DE  JSR $DEE9       ; buffer pointer to 16
DD5A: 20 3E DE  JSR $DE3E       ; get track and sector number
DD5D: A5 80     LDA $80         ; track number of the first data block
DD5F: 20 8D DD  JSR $DD8D       ; in buffer
DD62: A5 81     LDA $81         ; sector number of the first data block
DD64: 20 8D DD  JSR $DD8D       ; in buffer
DD67: 20 6C DE  JSR $DE6C       ; write block to disk
DD6A: 20 99 D5  JSR $D599       ; and check
DD6D: A9 02     LDA #$02
DD6F: 20 C8 D4  JSR $D4C8       ; buffer pointer to 2
DD72: A6 82     LDX $82         ; channel number
DD74: 38        SEC
DD75: A9 00     LDA #$00
DD77: F5 C7     SBC $C7,X       ; record length
DD79: 95 C1     STA $C1,X       ; pointer for writing
DD7B: 20 E2 E2  JSR $E2E2       ; erase buffer
DD7E: 20 19 DE  JSR $DE19       ; write link bytes in buffer
DD81: 20 5E DE  JSR $DE5E       ; write block to disk
DD84: 20 99 D5  JSR $D599       ; and check
DD87: 20 F4 EE  JSR $EEF4       ; write BAM
DD8A: 4C 98 DC  JMP $DC98       ; and done



 $DD8D/56717:   Write byte in side-sector block

Jump from $DD38, $DD3D, $DD42, $DD48, $DD4D, $DD52, $DD5F, $DD64, $E3FA,
          $E3FE:

DD8D: 48        PHA             ; save byte
DD8E: A6 82     LDX $82         ; channel number
DD90: B5 CD     LDA $CD,X       ; buffer number of the side-sector
DD92: 4C FD CF  JMP $CFFD       ; write byte in buffer



 $DD95/56725:   Manipulate flags

DD95: 90 06     BCC $DD9D

Jump from $CA4F, $E01A, $E0A0, $E107, $E25F, $E446:

DD97: A6 82     LDX $82         ; channel number
DD99: 15 EC     ORA $EC,X       ; set flag
DD9B: D0 06     BNE $DDA3

Jump from $DD95, $CFAC, $DFD2, $E003, $E0ED, $E21B:

DD9D: A6 82     LDX $82         ; channel number
DD9F: 49 FF     EOR #$FF
DDA1: 35 EC     AND $EC,X       ; erase flag

Jump from $DD9B:

DDA3: 95 EC     STA $EC,X
DDA5: 60        RTS



 $DDA6/56742:   ?

Jump from $C9DD, $DA2F, $DB57, $DFD7, $E0AD, $E0BE, $E0F5, $E122, $E26A:

DDA6: A6 82     LDX $82         ; channel number
DDA8: 35 EC     AND $EC,X       ; test flag
DDAA: 60        RTS



 $DDAB/56747:   Verify command code for writing

Jump from $CF4C, $E052, $E060:

DDAB: 20 93 DF  JSR $DF93       ; get buffer number
DDAE: AA        TAX
DDAF: BD 5B 02  LDA $025B,X
DDB2: 29 F0     AND #$F0        ; isolate command code
DDB4: C9 90     CMP #$90        ; code for writing?
DDB6: 60        RTS



 $DDB7/56759:   ?

Jump from $C835:

DDB7: A2 00     LDX #$00

Jump from $DDC7:

DDB9: 86 71     STX $71         ; counter for secondary address
DDBB: BD 2B 02  LDA $022B,X     ; get channel number from table
DDBE: C9 FF     CMP #$FF
DDC0: D0 08     BNE $DDCA       ; file open?

Jump from $DDDF, $DDE6, $DDED:

DDC2: A6 71     LDX $71
DDC4: E8        INX             ; increment counter
DDC5: E0 10     CPX #$10        ; smaller than 16?
DDC7: 90 F0     BCC $DDB9
DDC9: 60        RTS

Jump from $DDC0:

DDCA: 86 71     STX $71
DDCC: 29 3F     AND #$3F        ; isolate channel number
DDCE: A8        TAY
DDCF: B9 EC 00  LDA $EC,Y
DDD2: 29 01     AND #$01        ; isolate drive number
DDD4: 85 70     STA $70
DDD6: AE 53 02  LDX $0253
DDD9: B5 E2     LDA $E2,X
DDDB: 29 01     AND #$01        ; isolate drive number
DDDD: C5 70     CMP $70         ; same drive?
DDDF: D0 E1     BNE $DDC2       ; no
DDE1: B9 60 02  LDA $0260,Y     ; sector number in directory
DDE4: D5 D8     CMP $D8,X       ; same as file?
DDE6: D0 DA     BNE $DDC2       ; no
DDE8: B9 66 02  LDA $0266,Y
DDEB: D5 DD     CMP $DD,X       ; pointer same?
DDED: D0 D3     BNE $DDC2       ; no
DDEF: 18        CLC
DDF0: 60        RTS



 $DDF1/56817:   Write a block of a REL file

Jump from $DB2C, $E2AA, $E454:

DDF1: 20 9E DF  JSR $DF9E       ; get buffer number
DDF4: 50 06     BVC $DDFC       ; no rel-file?
DDF6: 20 5E DE  JSR $DE5E       ; write block
DDF9: 20 99 D5  JSR $D599       ; and verify

Jump from $DDF4:

DDFC: 60        RTS



 $DDFD/56829:   Write bytes for following track

Jump from $E3AC, $E3BF:

DDFD: 20 2B DE  JSR $DE2B       ; set buffer pointer
DE00: A5 80     LDA $80         ; track number
DE02: 91 94     STA ($94),Y     ; in buffer
DE04: C8        INY
DE05: A5 81     LDA $81         ; sector number
DE07: 91 94     STA ($94),Y     ; in buffer
DE09: 4C 05 E1  JMP $E105       ; set rel-flag



 $DE0C/56844:   Get following track and sector numbers

Jump from $E2AD, $E3D7:

DE0C: 20 2B DE  JSR $DE2B       ; set buffer pointer
DE0F: B1 94     LDA ($94),Y     ; following track number
DE11: 85 80     STA $80
DE13: C8        INY
DE14: B1 94     LDA ($94),Y     ; and get sector number
DE16: 85 81     STA $81
DE18: 60        RTS



 $DE19/56857:   Following track for last block

Jump from $DD7E, $E3D1:

DE19: 20 2B DE  JSR $DE2B       ; set buffer pointer
DE1C: A9 00     LDA #$00        ; zero
DE1E: 91 94     STA ($94),Y     ; as track number
DE20: C8        INY
DE21: A6 82     LDX $82         ; channel number
DE23: B5 C1     LDA $C1,X       ; pointer in block
DE25: AA        TAX
DE26: CA        DEX             ; minus 1
DE27: 8A        TXA
DE28: 91 94     STA ($94),Y     ; as pointer in block
DE2A: 60        RTS



 $DE2B/56875:   buffer pointer to zero

Jump from $DDFD, $DE0C, $DE19, $E1B2, $E2E2:

DE2B: 20 93 DF  JSR $DF93       ; get buffer number
DE2E: 0A        ASL             ; times 2
DE2F: AA        TAX
DE30: B5 9A     LDA $9A,X       ; buffer pointer hi
DE32: 85 95     STA $95
DE34: A9 00     LDA #$00
DE36: 85 94     STA $94         ; buffer pointer lo
DE38: A0 00     LDY #$00
DE3A: 60        RTS



 $DE3B/56891:   Get track and sector

Jump from $C5E8, $C634, $D48D, $D6F4, $D937, $D987:

DE3B: 20 EB D0  JSR $D0EB       ; get channel number

Jump from $D9F5, $DCA6, $DD5A, $E2D0, $E3E0, $E824, $E840, $F11E:

DE3E: 20 93 DF  JSR $DF93       ; get buffer number
DE41: 85 F9     STA $F9         ; save
DE43: 0A        ASL             ; times 2
DE44: A8        TAY
DE45: B9 06 00  LDA $06,Y       ; get track
DE48: 85 80     STA $80
DE4A: B9 07 00  LDA $07,Y       ; and sector number from disk controller
DE4D: 85 81     STA $81
DE4F: 60        RTS



 $DE50/56912:   Write

Jump from $E4A6:

DE50: A9 90     LDA #$90        ; command code for writing
DE52: 8D 4D 02  STA $024D
DE55: D0 28     BNE $DE7F



 $DE57/56919:   Read

Jump from $CAA9, $CF5A, $E057, $E065, $E075:

DE57: A9 80     LDA #$80        ; command code for reading
DE59: 8D 4D 02  STA $024D
DE5C: D0 21     BNE $DE7F



 $DE5E/56926:   Write

Jump from $C8BB, $CAC3, $DD81, $DDF6, $E047, $E3B3, $E3D4, $E4ED:

DE5E: A9 90     LDA #$90        ; command code for writing
DE60: 8D 4D 02  STA $024D
DE63: D0 26     BNE $DE8B



 $DE65/56933:   Read

DE65: A9 80     LDA #$80        ; command code for reading
DE67: 8D 4D 02  STA $024D
DE6A: D0 1F     BNE $DE8B



 $DE6C/56940:   Write

Jump from $DD67, $E42D:

DE6C: A9 90     LDA #$90        ; command code for writing
DE6E: 8D 4D 02  STA $024D
DE71: D0 02     BNE $DE75



 $DE73/56947:   Read

Jump from $DC92:

DE73: A9 80     LDA #$80        ; command code for reading

Jump from $DE71:

DE75: 8D 4D 02  STA $024D
DE78: A6 82     LDX $82         ; channel number
DE7A: B5 CD     LDA $CD,X       ; side-sector buffer number
DE7C: AA        TAX
DE7D: 10 13     BPL $DE92       ; buffer associated?

Jump from $DE55, $DE5C:

DE7F: 20 D0 D6  JSR $D6D0       ; generate header for disk controller
DE82: 20 93 DF  JSR $DF93       ; get buffer number
DE85: AA        TAX
DE86: A5 7F     LDA $7F         ; drive number
DE88: 9D 5B 02  STA $025B,X

Jump from $DE63, $DE6A:

DE8B: 20 15 E1  JSR $E115       ; buffer number
DE8E: 20 93 DF  JSR $DF93       ; get buffer number
DE91: AA        TAX

Jump from $DE7D:

DE92: 4C 06 D5  JMP $D506       ; write block



 $DE95/56981:   Get following track and sector from buffer

Jump from $DA34, $E03F, $E06B:

DE95: A9 00     LDA #$00
DE97: 20 C8 D4  JSR $D4C8       ; buffer pointer to zero
DE9A: 20 37 D1  JSR $D137       ; get byte
DE9D: 85 80     STA $80         ; save as track
DE9F: 20 37 D1  JSR $D137       ; get byte
DEA2: 85 81     STA $81         ; as sector
DEA4: 60        RTS



 $DEA5/56997:   Copy buffer contents

Jump from $E467:

DEA5: 48        PHA
DEA6: A9 00     LDA #$00
DEA8: 85 6F     STA $6F
DEAA: 85 71     STA $71
DEAC: B9 E0 FE  LDA $FEE0,Y     ; buffer address Y, hi
DEAF: 85 70     STA $70
DEB1: BD E0 FE  LDA $FEE0,X     ; buffer address X, lo
DEB4: 85 72     STA $72
DEB6: 68        PLA
DEB7: A8        TAY
DEB8: 88        DEY

Jump from $DEBE:

DEB9: B1 6F     LDA ($6F),Y
DEBB: 91 71     STA ($71),Y
DEBD: 88        DEY
DEBE: 10 F9     BPL $DEB9
DEC0: 60        RTS



 $DEC1/57025:   Erase buffer Y

Jump from $DD1A, $E45B:

DEC1: A8        TAY             ; buffer number
DEC2: B9 E0 FE  LDA $FEE0,Y     ; get hi-address
DEC5: 85 70     STA $70
DEC7: A9 00     LDA #$00        ; lo-address
DEC9: 85 6F     STA $6F
DECB: A8        TAY

Jump from $DECF:

DECC: 91 6F     STA ($6F),Y     ; erase buffer
DECE: C8        INY
DECF: D0 FB     BNE $DECC
DED1: 60        RTS



 $DED2/57042:   Get side-sector number

Jump from $DF66, $E1CB:

DED2: A9 00     LDA #$00
DED4: 20 DC DE  JSR $DEDC       ; buffer pointer to zero
DED7: A0 02     LDY #$02
DED9: B1 94     LDA ($94),Y     ; byte 2 contains the side-sector number
DEDB: 60        RTS



 $DEDC/57052:   Set buffer pointer to side-sector

Jump from $DED4, $DEEA, $E41E, $E46C:

DEDC: 85 94     STA $94         ; printer lo
DEDE: A6 82     LDX $82         ; channel number
DEE0: B5 CD     LDA $CD,X       ; buffer number
DEE2: AA        TAX
DEE3: BD E0 FE  LDA $FEE0,X     ; buffer address hi
DEE6: 85 95     STA $95         ; set
DEE8: 60        RTS



 $DEE9/57065:   Buffer pointer for side-sector

Jump from $DD33, $DD57, $DF14, $E1FF, $E35A, $E3F4:

DEE9: 48        PHA             ; pointer in side-sector
DEEA: 20 DC DE  JSR $DEDC       ; set buffer pointer
DEED: 48        PHA
DEEE: 8A        TXA             ; buffer number
DEEF: 0A        ASL             ; times 2
DEF0: AA        TAX
DEF1: 68        PLA
DEF2: 95 9A     STA $9A,X       ; buffer pointer hi
DEF4: 68        PLA
DEF5: 95 99     STA $99,X       ; buffer pointer lo
DEF7: 60        RTS



 $DEF8/57080:   Get side sector and buffer pointer

Jump from $E258, $E43C:

DEF8: 20 66 DF  JSR $DF66       ; is side-sector in buffer?
DEFB: 30 0E     BMI $DF0B       ; no
DEFD: 50 13     BVC $DF12       ; ok
DEFF: A6 82     LDX $82         ; channel number
DF01: B5 CD     LDA $CD,X       ; buffer number
DF03: 20 1B DF  JSR $DF1B       ; read side-sector
DF06: 20 66 DF  JSR $DF66       ; and check if in buffer
DF09: 10 07     BPL $DF12       ; yes?

Jump from $DEFB:

DF0B: 20 CB E1  JSR $E1CB       ; get last side-sector
DF0E: 2C CE FE  BIT $FECE       ; set V bit
DF11: 60        RTS

Jump from $DEFD, $DF09:

DF12: A5 D6     LDA $D6         ; side-sector and pointer
DF14: 20 E9 DE  JSR $DEE9       ; set pointer in side-sector
DF17: 2C CD FE  BIT $FECD       ; erase V bit
DF1A: 60        RTS



 $DF1B/57115:   Read side-sector

Jump from $DF03, $E1EC, $E4D6:

DF1B: 85 F9     STA $F9         ; buffer number
DF1D: A9 80     LDA #$80        ; command code for reading
DF1F: D0 04     BNE $DF25



 $DF21/57121:   Write side-sector

DF21: 85 F9     STA $F9         ; buffer number
DF23: A9 90     LDA #$90        ; command code for writing

Jump from $DF1F:

DF25: 48        PHA
DF26: B5 EC     LDA $EC,X
DF28: 29 01     AND #$01        ; isolate drive number
DF2A: 85 7F     STA $7F
DF2C: 68        PLA
DF2D: 05 7F     ORA $7F         ; command code plus drive number
DF2F: 8D 4D 02  STA $024D       ; save
DF32: B1 94     LDA ($94),Y     ; track number
DF34: 85 80     STA $80
DF36: C8        INY
DF37: B1 94     LDA ($94),Y     ; sector number
DF39: 85 81     STA $81
DF3B: A5 F9     LDA $F9         ; buffer number
DF3D: 20 D3 D6  JSR $D6D3       ; transmit parameter to disk controller
DF40: A6 F9     LDX $F9         ; buffer number
DF42: 4C 93 D5  JMP $D593       ; transmit command to disk controller



 $DF45/57157:   Set buffer pointer in side-sector

Jump from $E3E9, $E40F, $E418:

DF45: A6 82     LDX $82         ; channel number
DF47: B5 CD     LDA $CD,X       ; buffer number
DF49: 4C EB D4  JMP $D4EB       ; set buffer pointer



 $DF4C/57164:   Calculate number of blocks in a REL file

Jump from $DF52:

DF4C: A9 78     LDA #$78        ; 120 block pointers per side-sector
DF4E: 20 5C DF  JSR $DF5C       ; add to $70/$71

Jump from $DB48, $E381:

DF51: CA        DEX             ; side-sector number
DF52: 10 F8     BPL $DF4C       ; next side-sector?
DF54: A5 72     LDA $72         ; pointer value in last block
DF56: 4A        LSR             ; divided by 2
DF57: 20 5C DF  JSR $DF5C       ; add to previous sum
DF5A: A5 73     LDA $73         ; number of the side-sector block

Jump from $DF4E, $DF57:

DF5C: 18        CLC
DF5D: 65 70     ADC $70
DF5F: 85 70     STA $70         ; add
DF61: 90 02     BCC $DF65
DF63: E6 71     INC $71

Jump from $DF61:

DF65: 60        RTS



 $DF66/57190:   Verify side-sector in buffer

Jump from $DEF8, $DF06:

DF66: 20 D2 DE  JSR $DED2       ; get side-sector number
DF69: C5 D5     CMP $D5         ; = number of necessary block?
DF6B: D0 0E     BNE $DF7B       ; no
DF6D: A4 D6     LDY $D6         ; pointer in side-sector
DF6F: B1 94     LDA ($94),Y     ; track number
DF71: F0 04     BEQ $DF77
DF73: 2C CD FE  BIT $FECD       ; erase bits
DF76: 60        RTS

Jump from $DF71:

DF77: 2C CF FE  BIT $FECF       ; set N-bit
DF7A: 60        RTS

Jump from $DF6B:

DF7B: A5 D5     LDA $D5         ; side-sector number
DF7D: C9 06     CMP #$06        ; 6 or greater?
DF7F: B0 0A     BCS $DF8B       ; yes
DF81: 0A        ASL
DF82: A8        TAY
DF83: A9 04     LDA #$04
DF85: 85 94     STA $94
DF87: B1 94     LDA ($94),Y     ; track number
DF89: D0 04     BNE $DF8F

Jump from $DF7F:

DF8B: 2C D0 FE  BIT $FED0       ; set N and V bits
DF8E: 60        RTS

Jump from $DF89:

DF8F: 2C CE FE  BIT $FECE       ; set V bit
DF92: 60        RTS



 $DF93/57235:   Get buffer number

Jump from $CAB7, $CDEC, $CF6F, $CFF2, $D0CC, $D12F, $D1D3, $D324, $D44D,
          $D4CA, $D4E8, $D4F8, $D6D0, $D75E, $DBC3, $DDAB, $DE2B, $DE3E,
          $DE82, $DE8E, $E07F, $E457, $E4D1, $EC1F, $ECB3, $ECDC, $ED0D,
          $ED32, $ED46, $EEF4:

DF93: A6 82     LDX $82         ; channel number
DF95: B5 A7     LDA $A7,X       ; buffer number
DF97: 10 02     BPL $DF9B
DF99: B5 AE     LDA $AE,X       ; buffer number from second table

Jump from $DF97:

DF9B: 29 BF     AND #$BF        ; erase V bit
DF9D: 60        RTS



 $DF9E/57246:   ?

Jump from $DDF1, $E042, $E10A, $E115, $E4B1:

DF9E: A6 82     LDX $82         ; channel number
DFA0: 8E 57 02  STX $0257       ; save
DFA3: B5 A7     LDA $A7,X       ; get buffer number
DFA5: 10 09     BPL $DFB0       ; buffer allocated
DFA7: 8A        TXA
DFA8: 18        CLC
DFA9: 69 07     ADC #$07        ; increment number by 7
DFAB: 8D 57 02  STA $0257       ; and save
DFAE: B5 AE     LDA $AE,X       ; buffer number from table 2

Jump from $DFA5:

DFB0: 85 70     STA $70
DFB2: 29 1F     AND #$1F        ; erase the highest 3 bits
DFB4: 24 70     BIT $70
DFB6: 60        RTS



 $DFB7/57271:   ?

Jump from $CF21, $CF7E:

DFB7: A6 82     LDX $82         ; channel number
DFB9: B5 A7     LDA $A7,X       ; buffer number
DFBB: 30 02     BMI $DFBF       ; buffer free?
DFBD: B5 AE     LDA $AE,X       ; buffer number from table 2

Jump from $DFBB:

DFBF: C9 FF     CMP #$FF        ; free?
DFC1: 60        RTS



 $DFC2/57282:   ?

Jump from $CF2E, $CF88:

DFC2: A6 82     LDX $82
DFC4: 09 80     ORA #$80
DFC6: B4 A7     LDY $A7,X
DFC8: 10 03     BPL $DFCD
DFCA: 95 A7     STA $A7,X
DFCC: 60        RTS

Jump from $DFC8:

DFCD: 95 AE     STA $AE,X
DFCF: 60        RTS



 $DFD0/57296:   Get next record iin REL file

Jump from $E153:

DFD0: A9 20     LDA #$20
DFD2: 20 9D DD  JSR $DD9D       ; erase bit 5
DFD5: A9 80     LDA #$80
DFD7: 20 A6 DD  JSR $DDA6       ; test bit 7
DFDA: D0 41     BNE $E01D       ; set?
DFDC: A6 82     LDX $82         ; channel number
DFDE: F6 B5     INC $B5,X       ; increment record number
DFE0: D0 02     BNE $DFE4
DFE2: F6 BB     INC $BB,X       ; record number hi

Jump from $DFE0:

DFE4: A6 82     LDX $82         ; channel number
DFE6: B5 C1     LDA $C1,X       ; write pointer
DFE8: F0 2E     BEQ $E018       ; zero?
DFEA: 20 E8 D4  JSR $D4E8       ; set buffer pointer
DFED: A6 82     LDX $82         ; channel number
DFEF: D5 C1     CMP $C1,X       ; buffer pointer smaller than write pointer
DFF1: 90 03     BCC $DFF6       ; yes
DFF3: 20 3C E0  JSR $E03C       ; write block, read next block

Jump from $DFF1:

DFF6: A6 82     LDX $82         ; channel number
DFF8: B5 C1     LDA $C1,X       ; write pointer
DFFA: 20 C8 D4  JSR $D4C8       ; set buffer pointer = write pointer
DFFD: A1 99     LDA ($99,X)     ; byte from buffer
DFFF: 85 85     STA $85         ; put in output register
E001: A9 20     LDA #$20
E003: 20 9D DD  JSR $DD9D       ; erase bit 5
E006: 20 04 E3  JSR $E304       ; add record length to write pointer

Jump from $E291:

E009: 48        PHA             ; and save
E00A: 90 28     BCC $E034       ; not yet in last block?
E00C: A9 00     LDA #$00
E00E: 20 F6 D4  JSR $D4F6       ; get track number
E011: D0 21     BNE $E034       ; does block exist?
E013: 68        PLA             ; pointer
E014: C9 02     CMP #$02        ; = 2
E016: F0 12     BEQ $E02A       ; yes

Jump from $DFE8:

E018: A9 80     LDA #$80
E01A: 20 97 DD  JSR $DD97       ; set bit 7

Jump from $DFDA:

E01D: 20 2F D1  JSR $D12F       ; get byte from buffer
E020: B5 99     LDA $99,X       ; buffer pointer
E022: 99 44 02  STA $0244,Y     ; as end pointer
E025: A9 0D     LDA #$0D        ; CR
E027: 85 85     STA $85         ; in output register
E029: 60        RTS

Jump from $E016:

E02A: 20 35 E0  JSR $E035
E02D: A6 82     LDX $82         ; channel number
E02F: A9 00     LDA #$00
E031: 95 C1     STA $C1,X       ; write pointer to zero
E033: 60        RTS

Jump from $E00A, $E011:

E034: 68        PLA

Jump from $E02A:

E035: A6 82     LDX $82         ; channel number
E037: 95 C1     STA $C1,X       ; set write pointer
E039: 4C 6E E1  JMP $E16E



 $E03C/57404:   Write block and read next block

Jump from $DFF3, $E0A7, $E135:

E03C: 20 D3 D1  JSR $D1D3       ; get drive number
E03F: 20 95 DE  JSR $DE95       ; get track and sector number
E042: 20 9E DF  JSR $DF9E       ; get bufer number
E045: 50 16     BVC $E05D       ; no rel-file?
E047: 20 5E DE  JSR $DE5E       ; write block
E04A: 20 1E CF  JSR $CF1E       ; change buffer
E04D: A9 02     LDA #$02
E04F: 20 C8 D4  JSR $D4C8       ; buffer pointer to 2
E052: 20 AB DD  JSR $DDAB       ; command code for writing?
E055: D0 24     BNE $E07B       ; no
E057: 20 57 DE  JSR $DE57       ; read block
E05A: 4C 99 D5  JMP $D599       ; and verify

Jump from $E045:

E05D: 20 1E CF  JSR $CF1E       ; change buffer
E060: 20 AB DD  JSR $DDAB       ; command code for writing?
E063: D0 06     BNE $E06B       ; no
E065: 20 57 DE  JSR $DE57       ; read block
E068: 20 99 D5  JSR $D599       ; and verify

Jump from $E063:

E06B: 20 95 DE  JSR $DE95       ; get track and sector number
E06E: A5 80     LDA $80         ; track
E070: F0 09     BEQ $E07B       ; no following track
E072: 20 1E CF  JSR $CF1E       ; change buffer
E075: 20 57 DE  JSR $DE57       ; read block
E078: 20 1E CF  JSR $CF1E       ; change buffer

Jump from $E055, $E070:

E07B: 60        RTS



 $E07C/57468:   Write a byte in a record

Jump from $E0B4, $E0FE:

E07C: 20 05 E1  JSR $E105
E07F: 20 93 DF  JSR $DF93       ; get buffer number
E082: 0A        ASL             ; times 2
E083: AA        TAX
E084: A5 85     LDA $85         ; data byte
E086: 81 99     STA ($99,X)     ; write in buffer
E088: B4 99     LDY $99,X       ; buffer pointer
E08A: C8        INY             ; increment
E08B: D0 09     BNE $E096       ; not equal zero?
E08D: A4 82     LDY $82         ; channel number
E08F: B9 C1 00  LDA $C1,Y       ; write pointer
E092: F0 0A     BEQ $E09E       ; equal zero?
E094: A0 02     LDY #$02        ; buffer pointer to 2

Jump from $E08B:

E096: 98        TYA
E097: A4 82     LDY $82         ; channel number
E099: D9 C1 00  CMP $C1,Y       ; buffer pointer = write pointer?
E09C: D0 05     BNE $E0A3       ; no

Jump from $E092:

E09E: A9 20     LDA #$20
E0A0: 4C 97 DD  JMP $DD97       ; set bit 5

Jump from $E09C:

E0A3: F6 99     INC $99,X       ; increment buffer pointer
E0A5: D0 03     BNE $E0AA       ; not zero?
E0A7: 20 3C E0  JSR $E03C       ; else write block, read next one

Jump from $E0A5:

E0AA: 60        RTS



 $E0AB/57515:   Write byte in REL file

Jump from $CFCB:

E0AB: A9 A0     LDA #$A0
E0AD: 20 A6 DD  JSR $DDA6       ; test bits 6 & 7
E0B0: D0 27     BNE $E0D9       ; set?

Jump from $E0F0:

E0B2: A5 85     LDA $85         ; data byte
E0B4: 20 7C E0  JSR $E07C       ; write in record
E0B7: A5 F8     LDA $F8         ; end?
E0B9: F0 0D     BEQ $E0C8       ; yes
E0BB: 60        RTS

Jump from $E0DF:

E0BC: A9 20     LDA #$20
E0BE: 20 A6 DD  JSR $DDA6       ; test bit 5
E0C1: F0 05     BEQ $E0C8       ; not set
E0C3: A9 51     LDA #$51        ; 51, 'overflow in record'
E0C5: 8D 6C 02  STA $026C       ; set error flag

Jump from $E0B9, $E0C1:

E0C8: 20 F3 E0  JSR $E0F3       ; fill remainder with zeroes
E0CB: 20 53 E1  JSR $E153
E0CE: AD 6C 02  LDA $026C       ; error flag set?
E0D1: F0 03     BEQ $E0D6       ; no
E0D3: 4C C8 C1  JMP $C1C8       ; set error message

Jump from $E0D1:

E0D6: 4C BC E6  JMP $E6BC       ; error free execution

Jump from $E0B0:

E0D9: 29 80     AND #$80        ; bit 7 set?
E0DB: D0 05     BNE $E0E2       ; yes
E0DD: A5 F8     LDA $F8
E0DF: F0 DB     BEQ $E0BC       ; end?
E0E1: 60        RTS

Jump from $E0DB:

E0E2: A5 85     LDA $85         ; data byte
E0E4: 48        PHA
E0E5: 20 1C E3  JSR $E31C       ; expand side-sector
E0E8: 68        PLA
E0E9: 85 85     STA $85
E0EB: A9 80     LDA #$80
E0ED: 20 9D DD  JSR $DD9D       ; erase bit 7
E0F0: 4C B2 E0  JMP $E0B2       ; write byte in file



 $E0F3/57587:   Fill record with 0s

Jump from $E101, $E0C8:

E0F3: A9 20     LDA #$20
E0F5: 20 A6 DD  JSR $DDA6       ; test bit 5
E0F8: D0 0A     BNE $E104       ; set?
E0FA: A9 00     LDA #$00
E0FC: 85 85     STA $85         ; zero as data byte
E0FE: 20 7C E0  JSR $E07C       ; write in record
E101: 4C F3 E0  JMP $E0F3       ; until record full

Jump from $E0F8:

E104: 60        RTS



 $E105/57605:   Write buffer number in table

Jump from $DE09, $E07C:

E105: A9 40     LDA #$40
E107: 20 97 DD  JSR $DD97       ; set bit 6
E10A: 20 9E DF  JSR $DF9E       ; get buffer number
E10D: 09 40     ORA #$40        ; set bit 6
E10F: AE 57 02  LDX $0257       ; channel number + 7
E112: 95 A7     STA $A7,X       ; write in table
E114: 60        RTS

Jump from $DE8B:

E115: 20 9E DF  JSR $DF9E       ; get buffer number
E118: 29 BF     AND #$BF        ; erase bit 6
E11A: AE 57 02  LDX $0257       ; channel number
E11D: 95 A7     STA $A7,X       ; write in table
E11F: 60        RTS



 $E120/57632:   Get byte from REL file

Jump from $D3B1:

E120: A9 80     LDA #$80
E122: 20 A6 DD  JSR $DDA6       ; test bit 7
E125: D0 37     BNE $E15E       ; set?
E127: 20 2F D1  JSR $D12F       ; get byte from buffer
E12A: B5 99     LDA $99,X       ; buffer pointer
E12C: D9 44 02  CMP $0244,Y     ; compare to end pointer
E12F: F0 22     BEQ $E153       ; equal?
E131: F6 99     INC $99,X       ; increment buffer pointer
E133: D0 06     BNE $E13B       ; not zero?
E135: 20 3C E0  JSR $E03C       ; write block, read next one

Jump from $E294:

E138: 20 2F D1  JSR $D12F       ; get byte from buffer

Jump from $E133:

E13B: A1 99     LDA ($99,X)

Jump from $E15B:

E13D: 99 3E 02  STA $023E,Y     ; in output register
E140: A9 89     LDA #$89
E142: 99 F2 00  STA $F2,Y       ; set READ and WRITE flag
E145: B5 99     LDA $99,X       ; buffer pointer
E147: D9 44 02  CMP $0244,Y     ; compare to end pointer
E14A: F0 01     BEQ $E14D       ; same?
E14C: 60        RTS

Jump from $E14A:

E14D: A9 81     LDA #$81
E14F: 99 F2 00  STA $F2,Y       ; set flag for end
E152: 60        RTS

Jump from $E12F, $DCA3, $E0CB:

E153: 20 D0 DF  JSR $DFD0       ; find next record
E156: 20 2F D1  JSR $D12F       ; get buffer and channel number
E159: A5 85     LDA $85         ; data byte
E15B: 4C 3D E1  JMP $E13D       ; into output register

Jump from $E125, $E262, $E26F:

E15E: A6 82     LDX $82         ; channel number
E160: A9 0D     LDA #$0D        ; CR
E162: 9D 3E 02  STA $023E,X     ; into output register
E165: A9 81     LDA #$81
E167: 95 F2     STA $F2,X       ; set flag for end
E169: A9 50     LDA #$50
E16B: 20 C8 C1  JSR $C1C8       ; 50, 'record not present'

Jump from $E039:

E16E: A6 82     LDX $82         ; channel number
E170: B5 C1     LDA $C1,X       ; write pointer
E172: 85 87     STA $87         ; save
E174: C6 87     DEC $87
E176: C9 02     CMP #$02        ; equal 2?
E178: D0 04     BNE $E17E       ; no
E17A: A9 FF     LDA #$FF
E17C: 85 87     STA $87

Jump from $E178:

E17E: B5 C7     LDA $C7,X       ; record length
E180: 85 88     STA $88
E182: 20 E8 D4  JSR $D4E8       ; set buffer pointer
E185: A6 82     LDX $82         ; channel number
E187: C5 87     CMP $87         ; buffer pointer > write pointer?
E189: 90 19     BCC $E1A4
E18B: F0 17     BEQ $E1A4       ; no
E18D: 20 1E CF  JSR $CF1E       ; change buffer
E190: 20 B2 E1  JSR $E1B2
E193: 90 08     BCC $E19D
E195: A6 82     LDX $82         ; channel number
E197: 9D 44 02  STA $0244,X
E19A: 4C 1E CF  JMP $CF1E       ; change buffer

Jump from $E193:

E19D: 20 1E CF  JSR $CF1E       ; change buffer
E1A0: A9 FF     LDA #$FF
E1A2: 85 87     STA $87

Jump from $E189, $E18B:

E1A4: 20 B2 E1  JSR $E1B2
E1A7: B0 03     BCS $E1AC
E1A9: 20 E8 D4  JSR $D4E8       ; set buffer pointer

Jump from $E1A7:

E1AC: A6 82     LDX $82         ; channel number
E1AE: 9D 44 02  STA $0244,X     ; end pointer
E1B1: 60        RTS

Jump from $E190, $E1A4:

E1B2: 20 2B DE  JSR $DE2B       ; buffer pointer to zero
E1B5: A4 87     LDY $87

Jump from $E1C2:

E1B7: B1 94     LDA ($94),Y     ; byte from buffer
E1B9: D0 0D     BNE $E1C8       ; not zero?
E1BB: 88        DEY
E1BC: C0 02     CPY #$02
E1BE: 90 04     BCC $E1C4
E1C0: C6 88     DEC $88
E1C2: D0 F3     BNE $E1B7

Jump from $E1BE:

E1C4: C6 88     DEC $88
E1C6: 18        CLC
E1C7: 60        RTS

Jump from $E1B9:

E1C8: 98        TYA
E1C9: 38        SEC
E1CA: 60        RTS



 $E1CB/57803:   Get last side-sector

Jump from $CA56, $CA69, $DB32, $DF0B, $E31F:

E1CB: 20 D2 DE  JSR $DED2       ; get number of the side-sector
E1CE: 85 D5     STA $D5         ; save
E1D0: A9 04     LDA #$04
E1D2: 85 94     STA $94         ; pointer to side-sectors
E1D4: A0 0A     LDY #$0A
E1D6: D0 04     BNE $E1DC

Jump from $E1DE:

E1D8: 88        DEY
E1D9: 88        DEY
E1DA: 30 26     BMI $E202

Jump from $E1D6:

E1DC: B1 94     LDA ($94),Y     ; track number of the previous block
E1DE: F0 F8     BEQ $E1D8
E1E0: 98        TYA
E1E1: 4A        LSR             ; divide by 2
E1E2: C5 D5     CMP $D5         ; = number of the actual block?
E1E4: F0 09     BEQ $E1EF       ; yes
E1E6: 85 D5     STA $D5         ; else save all numbers
E1E8: A6 82     LDX $82         ; channel number
E1EA: B5 CD     LDA $CD,X       ; buffer number
E1EC: 20 1B DF  JSR $DF1B       ; read block

Jump from $E1E4:

E1EF: A0 00     LDY #$00
E1F1: 84 94     STY $94         ; buffer pointer
E1F3: B1 94     LDA ($94),Y     ; track number
E1F5: D0 0B     BNE $E202       ; another block?
E1F7: C8        INY
E1F8: B1 94     LDA ($94),Y     ; sector number = end pointer
E1FA: A8        TAY
E1FB: 88        DEY
E1FC: 84 D6     STY $D6         ; save end pointer
E1FE: 98        TYA
E1FF: 4C E9 DE  JMP $DEE9       ; set buffer pointer

Jump from $E1DA, $E1F5, $E286:

E202: A9 67     LDA #$67
E204: 20 45 E6  JSR $E645       ; 67, 'illegal track or sector'



 $E207/57863:   Perform [P] - Position command

E207: 20 B3 C2  JSR $C2B3       ; verify lines
E20A: AD 01 02  LDA $0201       ; secondary address
E20D: 85 83     STA $83
E20F: 20 EB D0  JSR $D0EB       ; find channel number
E212: 90 05     BCC $E219       ; found?
E214: A9 70     LDA #$70
E216: 20 C8 C1  JSR $C1C8       ; 70, 'no block'

Jump from $E212:

E219: A9 A0     LDA #$A0
E21B: 20 9D DD  JSR $DD9D       ; erase bits 6 & 7
E21E: 20 25 D1  JSR $D125       ; verify if 'REL'-file
E221: F0 05     BEQ $E228       ; yes
E223: A9 64     LDA #$64
E225: 20 C8 C1  JSR $C1C8       ; 64, 'file type mismatch'

Jump from $E221:

E228: B5 EC     LDA $EC,X
E22A: 29 01     AND #$01
E22C: 85 7F     STA $7F         ; drive number
E22E: AD 02 02  LDA $0202       ; record number lo
E231: 95 B5     STA $B5,X
E233: AD 03 02  LDA $0203       ; record number hi
E236: 95 BB     STA $BB,X
E238: A6 82     LDX $82         ; channel number
E23A: A9 89     LDA #$89
E23C: 95 F2     STA $F2,X       ; READ and WRITE flag
E23E: AD 04 02  LDA $0204       ; byte-pointer
E241: F0 10     BEQ $E253       ; zero?
E243: 38        SEC
E244: E9 01     SBC #$01
E246: F0 0B     BEQ $E253
E248: D5 C7     CMP $C7,X       ; compare with record length
E24A: 90 07     BCC $E253
E24C: A9 51     LDA #$51
E24E: 8D 6C 02  STA $026C       ; 51, 'overflow in record'
E251: A9 00     LDA #$00

Jump from $E241, $E246, $E24A:

E253: 85 D4     STA $D4
E255: 20 0E CE  JSR $CE0E       ; calculate pointer in rel-file
E258: 20 F8 DE  JSR $DEF8       ; and read appropriate side-sector
E25B: 50 08     BVC $E265       ; does block exist?
E25D: A9 80     LDA #$80
E25F: 20 97 DD  JSR $DD97       ; set bit 7
E262: 4C 5E E1  JMP $E15E       ; and 50, 'record not present'

Jump from $E25B:

E265: 20 75 E2  JSR $E275
E268: A9 80     LDA #$80
E26A: 20 A6 DD  JSR $DDA6       ; test bit 7
E26D: F0 03     BEQ $E272       ; not set
E26F: 4C 5E E1  JMP $E15E       ; 50, 'record not present'

Jump from $E26D:

E272: 4C 94 C1  JMP $C194       ; done

Jump from $E265, $E441:

E275: 20 9C E2  JSR $E29C
E278: A5 D7     LDA $D7         ; pointer in rel-file
E27A: 20 C8 D4  JSR $D4C8       ; set buffer pointer
E27D: A6 82     LDX $82         ; channel number
E27F: B5 C7     LDA $C7,X       ; record length
E281: 38        SEC
E282: E5 D4     SBC $D4         ; minus position
E284: B0 03     BCS $E289       ; positive?
E286: 4C 02 E2  JMP $E202       ; 67, 'illegal track or sector'

Jump from $E284:

E289: 18        CLC
E28A: 65 D7     ADC $D7         ; add pointer in data block
E28C: 90 03     BCC $E291       ; no overflow
E28E: 69 01     ADC #$01        ; plus 2
E290: 38        SEC

Jump from $E28C:

E291: 20 09 E0  JSR $E009       ; set pointer
E294: 4C 38 E1  JMP $E138       ; get byte from buffer
E297: A9 51     LDA #$51
E299: 20 C8 C1  JSR $C1C8       ; 51, 'overflow in record'

Jump from $E275, $CA6C, $E322:

E29C: A5 94     LDA $94         ; buffer pointer lo
E29E: 85 89     STA $89
E2A0: A5 95     LDA $95         ; buffer pointer hi
E2A2: 85 8A     STA $8A
E2A4: 20 D0 E2  JSR $E2D0       ; compare track and sector
E2A7: D0 01     BNE $E2AA       ; not equal?
E2A9: 60        RTS

Jump from $E2A7:

E2AA: 20 F1 DD  JSR $DDF1
E2AD: 20 0C DE  JSR $DE0C
E2B0: A5 80     LDA $80         ; track
E2B2: F0 0E     BEQ $E2C2       ; no block following?
E2B4: 20 D3 E2  JSR $E2D3       ; compare track and sector number
E2B7: D0 06     BNE $E2BF       ; not equal?
E2B9: 20 1E CF  JSR $CF1E       ; change buffer
E2BC: 4C DA D2  JMP $D2DA

Jump from $E2B7:

E2BF: 20 DA D2  JSR $D2DA

Jump from $E2B2:

E2C2: A0 00     LDY #$00
E2C4: B1 89     LDA ($89),Y     ; track
E2C6: 85 80     STA $80
E2C8: C8        INY
E2C9: B1 89     LDA ($89),Y     ; and sector of the next block
E2CB: 85 81     STA $81
E2CD: 4C AF D0  JMP $D0AF       ; read block

Jump from $E2A4:

E2D0: 20 3E DE  JSR $DE3E

Jump from $E2B4:

E2D3: A0 00     LDY #$00
E2D5: B1 89     LDA ($89),Y     ; track number
E2D7: C5 80     CMP $80         ; compare
E2D9: F0 01     BEQ $E2DC
E2DB: 60        RTS

Jump from $E2D9:

E2DC: C8        INY
E2DD: B1 89     LDA ($89),Y     ; sector number
E2DF: C5 81     CMP $81         ; compare
E2E1: 60        RTS



 $E2E2/58082:   Divide data blocks into records

Jump from $DD7B, $E3C2, $E3CE:

E2E2: 20 2B DE  JSR $DE2B       ; set buffer pointer
E2E5: A0 02     LDY #$02
E2E7: A9 00     LDA #$00

Jump from $E2EC:

E2E9: 91 94     STA ($94),Y     ; erase buffer
E2EB: C8        INY
E2EC: D0 FB     BNE $E2E9
E2EE: 20 04 E3  JSR $E304       ; set pointer to next record

Jump from $E2FB:

E2F1: 95 C1     STA $C1,X
E2F3: A8        TAY
E2F4: A9 FF     LDA #$FF
E2F6: 91 94     STA ($94),Y     ; $FF as 1st character in record
E2F8: 20 04 E3  JSR $E304       ; set pointer to next record
E2FB: 90 F4     BCC $E2F1       ; done in this block?
E2FD: D0 04     BNE $E303       ; block full?
E2FF: A9 00     LDA #$00
E301: 95 C1     STA $C1,X       ; write pointer to zero

Jump from $E2FD:

E303: 60        RTS



 $E304/58116:   Set pointer to next record

Jump from $E006, $E2EE, $E2F8:

E304: A6 82     LDX $82         ; channel number
E306: B5 C1     LDA $C1,X       ; write pointer
E308: 38        SEC
E309: F0 0D     BEQ $E318       ; equal zero?
E30B: 18        CLC
E30C: 75 C7     ADC $C7,X       ; add record length
E30E: 90 0B     BCC $E31B       ; smaller than 256?
E310: D0 06     BNE $E318       ; equal 256?
E312: A9 02     LDA #$02
E314: 2C CC FE  BIT $FECC
E317: 60        RTS

Jump from $E309, $E310:

E318: 69 01     ADC #$01        ; add two
E31A: 38        SEC

Jump from $E30E:

E31B: 60        RTS



 $E31C/58140:   Expand side-sector

Jump from $E0E5:

E31C: 20 D3 D1  JSR $D1D3       ; get drive number
E31F: 20 CB E1  JSR $E1CB       ; get last side-sector
E322: 20 9C E2  JSR $E29C
E325: 20 7B CF  JSR $CF7B
E328: A5 D6     LDA $D6
E32A: 85 87     STA $87
E32C: A5 D5     LDA $D5         ; side-sector number
E32E: 85 86     STA $86
E330: A9 00     LDA #$00
E332: 85 88     STA $88
E334: A9 00     LDA #$00
E336: 85 D4     STA $D4
E338: 20 0E CE  JSR $CE0E       ; calculate side-sector number and pointer

Jump from $CA85:

E33B: 20 4D EF  JSR $EF4D       ; number of free blocks
E33E: A4 82     LDY $82         ; channel number
E340: B6 C7     LDX $C7,Y       ; record length
E342: CA        DEX
E343: 8A        TXA
E344: 18        CLC
E345: 65 D7     ADC $D7         ; plus pointer in data block
E347: 90 0C     BCC $E355
E349: E6 D6     INC $D6
E34B: E6 D6     INC $D6         ; increment pointer to end by 2
E34D: D0 06     BNE $E355
E34F: E6 D5     INC $D5         ; increment side-sector number
E351: A9 10     LDA #$10
E353: 85 D6     STA $D6         ; set pointer to 16

Jump from $E347, $E34D:

E355: A5 87     LDA $87
E357: 18        CLC
E358: 69 02     ADC #$02
E35A: 20 E9 DE  JSR $DEE9       ; set buffer pointer for side-sector
E35D: A5 D5     LDA $D5         ; side-sector number
E35F: C9 06     CMP #$06
E361: 90 05     BCC $E368       ; smaller than 6?

Jump from $E394, $E39B:

E363: A9 52     LDA #$52
E365: 20 C8 C1  JSR $C1C8       ; 52, 'file too large'

Jump from $E361:

E368: A5 D6     LDA $D6         ; end pointer
E36A: 38        SEC
E36B: E5 87     SBC $87         ; minus last end pointer
E36D: B0 03     BCS $E372
E36F: E9 0F     SBC #$0F        ; minus 16
E371: 18        CLC

Jump from $E36D:

E372: 85 72     STA $72
E374: A5 D5     LDA $D5         ; side-sector number
E376: E5 86     SBC $86         ; minus last side-sector number
E378: 85 73     STA $73         ; save
E37A: A2 00     LDX #$00
E37C: 86 70     STX $70         ; erase sum for calculation
E37E: 86 71     STX $71
E380: AA        TAX
E381: 20 51 DF  JSR $DF51       ; calculate block # of rel-file
E384: A5 71     LDA $71
E386: D0 07     BNE $E38F
E388: A6 70     LDX $70
E38A: CA        DEX
E38B: D0 02     BNE $E38F
E38D: E6 88     INC $88

Jump from $E386, $E38B:

E38F: CD 73 02  CMP $0273       ; block number of rel-file
E392: 90 09     BCC $E39D       ; greater than free blocks on disk?
E394: D0 CD     BNE $E363       ; 52, 'file too large'
E396: AD 72 02  LDA $0272
E399: C5 70     CMP $70
E39B: 90 C6     BCC $E363       ; 52, 'file too large'

Jump from $E392:

E39D: A9 01     LDA #$01
E39F: 20 F6 D4  JSR $D4F6       ; get byte from buffer
E3A2: 18        CLC
E3A3: 69 01     ADC #$01        ; plus 1
E3A5: A6 82     LDX $82
E3A7: 95 C1     STA $C1,X       ; as write pointer
E3A9: 20 1E F1  JSR $F11E       ; find free block in BAM
E3AC: 20 FD DD  JSR $DDFD       ; track and sector in buffer
E3AF: A5 88     LDA $88
E3B1: D0 15     BNE $E3C8       ; only one block needed?
E3B3: 20 5E DE  JSR $DE5E       ; write block

Jump from $E40D, $E414:

E3B6: 20 1E CF  JSR $CF1E       ; change buffer
E3B9: 20 D0 D6  JSR $D6D0       ; transmit parameter to disk controller
E3BC: 20 1E F1  JSR $F11E       ; find free block in BAM
E3BF: 20 FD DD  JSR $DDFD       ; track and sector in buffer
E3C2: 20 E2 E2  JSR $E2E2       ; erase buffer
E3C5: 4C D4 E3  JMP $E3D4

Jump from $E3B1, $E416:

E3C8: 20 1E CF  JSR $CF1E       ; change buffer
E3CB: 20 D0 D6  JSR $D6D0       ; transmit parameter to disk controller
E3CE: 20 E2 E2  JSR $E2E2       ; erase buffer
E3D1: 20 19 DE  JSR $DE19       ; zero byte and end pointer in buffer

Jump from $E3C5:

E3D4: 20 5E DE  JSR $DE5E       ; write block
E3D7: 20 0C DE  JSR $DE0C       ; get track and sector
E3DA: A5 80     LDA $80         ; track
E3DC: 48        PHA
E3DD: A5 81     LDA $81         ; and sector
E3DF: 48        PHA             ; save
E3E0: 20 3E DE  JSR $DE3E       ; get track and sector from disk
E3E3: A5 81     LDA $81         ; controller
E3E5: 48        PHA
E3E6: A5 80     LDA $80         ; save track and sector
E3E8: 48        PHA
E3E9: 20 45 DF  JSR $DF45       ; set buffer pointer for side-sector
E3EC: AA        TAX
E3ED: D0 0A     BNE $E3F9       ; pointer not zero?
E3EF: 20 4E E4  JSR $E44E       ; write side-sector
E3F2: A9 10     LDA #$10
E3F4: 20 E9 DE  JSR $DEE9       ; buffer pointer to 16
E3F7: E6 86     INC $86         ; increment side-sector number

Jump from $E3ED:

E3F9: 68        PLA
E3FA: 20 8D DD  JSR $DD8D       ; track in side-sector
E3FD: 68        PLA
E3FE: 20 8D DD  JSR $DD8D       ; sector in side-sector
E401: 68        PLA
E402: 85 81     STA $81         ; sector
E404: 68        PLA
E405: 85 80     STA $80         ; and get track back
E407: F0 0F     BEQ $E418       ; no more blocks?
E409: A5 86     LDA $86         ; side-sector number
E40B: C5 D5     CMP $D5         ; changed?
E40D: D0 A7     BNE $E3B6       ; yes
E40F: 20 45 DF  JSR $DF45       ; set buffer pointer in side-sector
E412: C5 D6     CMP $D6         ; end pointer
E414: 90 A0     BCC $E3B6       ; smaller?
E416: F0 B0     BEQ $E3C8       ; same

Jump from $E407:

E418: 20 45 DF  JSR $DF45       ; set buffer pointer in side-sector
E41B: 48        PHA
E41C: A9 00     LDA #$00
E41E: 20 DC DE  JSR $DEDC       ; buffer pointer to zero
E421: A9 00     LDA #$00
E423: A8        TAY
E424: 91 94     STA ($94),Y     ; zero as track number
E426: C8        INY
E427: 68        PLA             ; end pointer
E428: 38        SEC
E429: E9 01     SBC #$01        ; minus one
E42B: 91 94     STA ($94),Y     ; as sector
E42D: 20 6C DE  JSR $DE6C       ; write block
E430: 20 99 D5  JSR $D599       ; and verify
E433: 20 F4 EE  JSR $EEF4       ; update BAM
E436: 20 0E CE  JSR $CE0E       ; update pointer for rel-file
E439: 20 1E CF  JSR $CF1E       ; change buffer
E43C: 20 F8 DE  JSR $DEF8       ; right side-sector?
E43F: 70 03     BVS $E444       ; no
E441: 4C 75 E2  JMP $E275

Jump from $E43F:

E444: A9 80     LDA #$80
E446: 20 97 DD  JSR $DD97       ; set bit 7
E449: A9 50     LDA #$50
E44B: 20 C8 C1  JSR $C1C8       ; 50, 'record not present'



 $E44E/58446:   Write side-sector and allocate new

Jump from $E3EF:

E44E: 20 1E F1  JSR $F11E       ; find free block in BAM
E451: 20 1E CF  JSR $CF1E       ; change buffer
E454: 20 F1 DD  JSR $DDF1       ; write block
E457: 20 93 DF  JSR $DF93       ; get buffer number
E45A: 48        PHA
E45B: 20 C1 DE  JSR $DEC1       ; erase buffer
E45E: A6 82     LDX $82         ; channel number
E460: B5 CD     LDA $CD,X       ; buffer number
E462: A8        TAY
E463: 68        PLA
E464: AA        TAX
E465: A9 10     LDA #$10        ; 16 bytes of the side-sector
E467: 20 A5 DE  JSR $DEA5       ; copy in buffer
E46A: A9 00     LDA #$00
E46C: 20 DC DE  JSR $DEDC       ; buffer pointer to 0, old side-sector
E46F: A0 02     LDY #$02
E471: B1 94     LDA ($94),Y     ; side-sector number
E473: 48        PHA
E474: A9 00     LDA #$00
E476: 20 C8 D4  JSR $D4C8       ; buffer pointer to 0, new side-sector
E479: 68        PLA
E47A: 18        CLC
E47B: 69 01     ADC #$01        ; increment side-sector number
E47D: 91 94     STA ($94),Y     ; and in buffer
E47F: 0A        ASL             ; times 2
E480: 69 04     ADC #$04        ; plus 4
E482: 85 89     STA $89
E484: A8        TAY
E485: 38        SEC
E486: E9 02     SBC #$02        ; minus 2
E488: 85 8A     STA $8A         ; same pointer to old side-sector
E48A: A5 80     LDA $80         ; track
E48C: 85 87     STA $87
E48E: 91 94     STA ($94),Y     ; in buffer
E490: C8        INY
E491: A5 81     LDA $81         ; sector
E493: 85 88     STA $88
E495: 91 94     STA ($94),Y     ; in buffer
E497: A0 00     LDY #$00
E499: 98        TYA
E49A: 91 94     STA ($94),Y     ; zero in buffer
E49C: C8        INY
E49D: A9 11     LDA #$11        ; 17
E49F: 91 94     STA ($94),Y     ; number of bytes in block
E4A1: A9 10     LDA #$10        ; 16
E4A3: 20 C8 D4  JSR $D4C8       ; buffer pointer to 16
E4A6: 20 50 DE  JSR $DE50       ; write block
E4A9: 20 99 D5  JSR $D599       ; and verify
E4AC: A6 82     LDX $82         ; channel number
E4AE: B5 CD     LDA $CD,X       ; buffer number of the side-sector
E4B0: 48        PHA
E4B1: 20 9E DF  JSR $DF9E       ; get buffer number
E4B4: A6 82     LDX $82         ; channel number
E4B6: 95 CD     STA $CD,X       ; write in table
E4B8: 68        PLA
E4B9: AE 57 02  LDX $0257       ; channel number + 7
E4BC: 95 A7     STA $A7,X       ; in table
E4BE: A9 00     LDA #$00
E4C0: 20 C8 D4  JSR $D4C8       ; buffer pointer to zero
E4C3: A0 00     LDY #$00
E4C5: A5 80     LDA $80         ; track
E4C7: 91 94     STA ($94),Y     ; in buffer
E4C9: C8        INY
E4CA: A5 81     LDA $81         ; sector
E4CC: 91 94     STA ($94),Y     ; in buffer
E4CE: 4C DE E4  JMP $E4DE

Jump from $E4F7:

E4D1: 20 93 DF  JSR $DF93       ; get buffer number
E4D4: A6 82     LDX $82         ; channel number
E4D6: 20 1B DF  JSR $DF1B       ; read block
E4D9: A9 00     LDA #$00
E4DB: 20 C8 D4  JSR $D4C8       ; buffer pointer to zero

Jump from $E4CE:

E4DE: C6 8A     DEC $8A
E4E0: C6 8A     DEC $8A         ; counter for side-sector blocks
E4E2: A4 89     LDY $89
E4E4: A5 87     LDA $87         ; track number
E4E6: 91 94     STA ($94),Y     ; in buffer
E4E8: C8        INY
E4E9: A5 88     LDA $88         ; sector number
E4EB: 91 94     STA ($94),Y     ; in buffer
E4ED: 20 5E DE  JSR $DE5E       ; write block
E4F0: 20 99 D5  JSR $D599       ; and verify
E4F3: A4 8A     LDY $8A         ; counter for side-sector blocks
E4F5: C0 03     CPY #$03
E4F7: B0 D8     BCS $E4D1       ; greater than or equal to 3?
E4F9: 4C 1E CF  JMP $CF1E       ; change buffer



 $E4FC/58620:   Table of Error Messages: 00,     Ok

E4FC: 00 A0 4F CB



 $E500/58624:   Error Message: 20,21,22,23,24,27, Read error

E500: 20 21 22 23 24 27 D2 45
E508: 41 44 89



 $E50B/58635:   Error Message: 52, File too large

E50B: 52 83 20 54 4F 4F 20 4C
E513: 41 52 47 C5



 $E517/58647:   Error Message: 50, Record not present

E517: 50 8B 06 20 50 52 45 53
E51F: 45 4E D4



 $E522/58658:   Error Message: 51, Overflow in record

E522: 51 CF 56 45 52 46 4C 4F
E52A: 57 20 49 4E 8B



 $E52F/58671:   Error Message: 25,28, Write error

E52F: 25 28 8A 89



 $E533/58675:   Error Message: 26, Write protect on

E533: 26 8A 20 50 52 4F 54 45
E53B: 43 54 20 4F CE



 $E540/58688:   Error Message: 29, Disk id mismatch

E540: 29 88 20 49 44 85



 $E546/58694:   Error Message: 30,31,32,33,34, Syntax error

E546: 30 31 32 33 34 D3 59 4E
E54E: 54 41 58 89



 $E552/58706:   Error Message: 60, Write file open

E552: 60 8A 03 84



 $E556/58710:   Error Message: 63, File exists

E556: 63 83 20 45 58 49 53 54
E55E: D3



 $E55F/58719:   Error Message: 64, File type mismatch

E55F: 64 83 20 54 59 50 45 85



 $E567/58727:   Error Message: 65, No block

E567: 65 CE 4F 20 42 4C 4F 43
E56F: CB



 $E570/58736:   Error Message: 66,67, Illegal track or sector

E570: 66 67 C9 4C 4C 45 47 41
E578: 4C 20 54 52 41 43 4B 20
E580: 4F 52 20 53 45 43 54 4F
E588: D2



 $E589/58761:   Error Message: 61, File not open

E589: 61 83 06 84



 $E58D/58765:   Error Message: 39,62, File not found

E58D: 39 62 83 06 87



 $E592/58770:   Error Message: 01, Files scratched

E592: 01 83 53 20 53 43 52 41
E59A: 54 43 48 45 C4



 $E59F/58783:   Error Message: 70, No channel

E59F: 70 CE 4F 20 43 48 41 4E
E5A7: 4E 45 CC



 $E5AA/58794:   Error Message: 71, Dir error

E5AA: 71 C4 49 52 89



 $E5AF/58799:   Error Message: 72, Disk full

E5AF: 72 88 20 46 55 4C CC



 $E5B6/58806:   Error Message: 73, Cbm dos v2.6 1541

E5B6: 73 C3 42 4D 20 44 4F 53
E5BE: 20 56 32 2E 36 20 31 35
E5C6: 34 B1



 $E5C8/58824:   Error Message: 74, Drive not ready

E5C8: 74 C4 52 49 56 45 06 20
E5D0: 52 45 41 44 D9



 $E5D5/58837:   Indexed words: 09 Error

E5D5: 09 C5 52 52 4F D2



 $E5DB/58843:   Indexed words: 0A Write

E5DB: 0A D7 52 49 54 C5



 $E5E1/58849:   Indexed words: 03 File

E5E1: 03 C6 49 4C C5



 $E5E6/58854:   Indexed words: 04 Open

E5E6: 04 CF 50 45 CE



 $E5EB/58859:   Indexed words: 05 Mismatch

E5EB: 05 CD 49 53 4D 41 54 43
E5F3: C8



 $E5F4/58868:   Indexed words: 06 Not

E5F4: 06 CE 4F D4



 $E5F8/58872:   Indexed words: 07 Found

E5F8: 07 C6 4F 55 4E C4



 $E5FE/58878:   Indexed words: 08 Disk

E5FE: 08 C4 49 53 CB



 $E603/58883:   Indexed words: 0B Record

E603: 0B D2 45 43 4F 52 C4



 $E60A/58890:   Prepare error number and message

Jump from $C8EC, $D641:

E60A: 48        PHA             ; save error code
E60B: 86 F9     STX $F9         ; drive number
E60D: 8A        TXA
E60E: 0A        ASL             ; times 2
E60F: AA        TAX             ; as pointer
E610: B5 06     LDA $06,X
E612: 85 80     STA $80         ; get track
E614: B5 07     LDA $07,X
E616: 85 81     STA $81         ; and sector number
E618: 68        PLA             ; get error code back
E619: 29 0F     AND #$0F        ; isolate bits 0-3
E61B: F0 08     BEQ $E625       ; zero, then 24, 'read error'
E61D: C9 0F     CMP #$0F        ; 15?
E61F: D0 06     BNE $E627
E621: A9 74     LDA #$74        ; 74, 'drive not ready'
E623: D0 08     BNE $E62D       ; 6

Jump from $E61B:

E625: A9 06     LDA #$06        ; add $20

Jump from $E61F:

E627: 09 20     ORA #$20
E629: AA        TAX
E62A: CA        DEX
E62B: CA        DEX             ; subtract two
E62C: 8A        TXA

Jump from $E623:

E62D: 48        PHA             ; save error number
E62E: AD 2A 02  LDA $022A       ; number of the disk command
E631: C9 00     CMP #$00        ; OPEN or VALIDATE?
E633: D0 0F     BNE $E644       ; no
E635: A9 FF     LDA #$FF
E637: 8D 2A 02  STA $022A
E63A: 68        PLA             ; get error number back
E63B: 20 C7 E6  JSR $E6C7       ; generate error message
E63E: 20 42 D0  JSR $D042       ; load BAM
E641: 4C 48 E6  JMP $E648       ; set error message

Jump from $E633:

E644: 68        PLA



 $E645/58949:   Print error message into error buffer

Jump from $C1CE, $CD2E, $D54F, $D577, $DC03, $E204, $E829, $E845, $F1DC,
          $F1F7, $F248:

E645: 20 C7 E6  JSR $E6C7       ; set error message

Jump from $D021, $E641, $F01F:

E648: 20 BD C1  JSR $C1BD       ; erase input buffer
E64B: A9 00     LDA #$00
E64D: 8D F9 02  STA $02F9       ; erase error flag
E650: 20 2C C1  JSR $C12C       ; turn LED off
E653: 20 DA D4  JSR $D4DA       ; close channels 17 and 18
E656: A9 00     LDA #$00
E658: 85 A3     STA $A3         ; input buffer pointer to zero
E65A: A2 45     LDX #$45
E65C: 9A        TXS             ; initialize stack pointer
E65D: A5 84     LDA $84         ; secondary address
E65F: 29 0F     AND #$0F
E661: 85 83     STA $83
E663: C9 0F     CMP #$0F        ; 15?
E665: F0 31     BEQ $E698       ; yes, command channel
E667: 78        SEI
E668: A5 79     LDA $79         ; LISTEN active?
E66A: D0 1C     BNE $E688       ; yes
E66C: A5 7A     LDA $7A         ; TALK active?
E66E: D0 10     BNE $E680       ; yes
E670: A6 83     LDX $83         ; channel number
E672: BD 2B 02  LDA $022B,X     ; open channel to this secondary addr
E675: C9 FF     CMP #$FF
E677: F0 1F     BEQ $E698       ; no
E679: 29 0F     AND #$0F
E67B: 85 82     STA $82         ; channel
E67D: 4C 8E E6  JMP $E68E



 $E680/59008:   TALK

Jump from $E66E:

E680: 20 EB D0  JSR $D0EB       ; open channel for reading
E683: EA        NOP             ; accept byte
E684: EA        NOP
E685: EA        NOP
E686: D0 06     BNE $E68E



 $E688/59016:   LISTEN

Jump from $E66A:

E688: 20 07 D1  JSR $D107       ; open channel for writing
E68B: EA        NOP             ; accept byte
E68C: EA        NOP
E68D: EA        NOP

Jump from $E67D, $E686:

E68E: 20 25 D1  JSR $D125       ; verify file type
E691: C9 04     CMP #$04        ; file type REL?
E693: B0 03     BCS $E698       ; yes
E695: 20 27 D2  JSR $D227       ; close channel

Jump from $E693, $E665, $E677:

E698: 4C E7 EB  JMP $EBE7



 $E69B/59035:   Convert BIN to 2-Ascii (error message buffer)

Jump from $E6EA, $E6F4:

E69B: AA        TAX
E69C: A9 00     LDA #$00
E69E: F8        SED

Jump from $E6A7:

E69F: E0 00     CPX #$00
E6A1: F0 07     BEQ $E6AA       ; convert hex to BCD
E6A3: 18        CLC
E6A4: 69 01     ADC #$01
E6A6: CA        DEX
E6A7: 4C 9F E6  JMP $E69F

Jump from $E6A1:

E6AA: D8        CLD



 $E6AB/59051:   Convert BCD to 2-Ascii (error message buffer)

Jump from $E6D1:

E6AB: AA        TAX
E6AC: 4A        LSR
E6AD: 4A        LSR             ; shift hi-nibble down
E6AE: 4A        LSR
E6AF: 4A        LSR
E6B0: 20 B4 E6  JSR $E6B4       ; convert to ASCII
E6B3: 8A        TXA

Jump from $E6B0:

E6B4: 29 0F     AND #$0F        ; erase top 4 bits
E6B6: 09 30     ORA #$30        ; add '0'
E6B8: 91 A5     STA ($A5),Y     ; write in buffer
E6BA: C8        INY             ; increment buffer pointer
E6BB: 60        RTS



 $E6BC/59068:   Write OK in buffer

Jump from $C150, $E0D6:

E6BC: 20 23 C1  JSR $C123       ; erase error flag
E6BF: A9 00     LDA #$00        ; error number 0



 $E6C1/59073:   Print error on track 00,00 to error buffer

Jump from $D42A, $EBD7:

E6C1: A0 00     LDY #$00
E6C3: 84 80     STY $80         ; track 0
E6C5: 84 81     STY $81         ; sector 0



 $E6C7/59079:   Print error on current track to error buffer

Jump from $C1A7, $E63B, $E645, $EFCB:

E6C7: A0 00     LDY #$00        ; buffer pointer
E6C9: A2 D5     LDX #$D5
E6CB: 86 A5     STX $A5         ; pointer $A5/$A6 to $2D5
E6CD: A2 02     LDX #$02
E6CF: 86 A6     STX $A6
E6D1: 20 AB E6  JSR $E6AB       ; error number to ASCII and in buffer
E6D4: A9 2C     LDA #$2C        ; ',' comma
E6D6: 91 A5     STA ($A5),Y     ; write in buffer
E6D8: C8        INY             ; increment buffer pointer
E6D9: AD D5 02  LDA $02D5       ; first digit of the disk status
E6DC: 8D 43 02  STA $0243       ; in output register
E6DF: 8A        TXA             ; error number in accumulator
E6E0: 20 06 E7  JSR $E706       ; error message in buffer
E6E3: A9 2C     LDA #$2C        ; ',' comma
E6E5: 91 A5     STA ($A5),Y     ; write in buffer
E6E7: C8        INY             ; and increment buffer pointer
E6E8: A5 80     LDA $80         ; track number
E6EA: 20 9B E6  JSR $E69B       ; to ASCII and in buffer
E6ED: A9 2C     LDA #$2C        ; ',' comma
E6EF: 91 A5     STA ($A5),Y     ; write in buffer
E6F1: C8        INY             ; increment buffer pointer
E6F2: A5 81     LDA $81         ; sector
E6F4: 20 9B E6  JSR $E69B       ; convert to ASCII and in buffer
E6F7: 88        DEY
E6F8: 98        TYA
E6F9: 18        CLC
E6FA: 69 D5     ADC #$D5
E6FC: 8D 49 02  STA $0249       ; end pointer
E6FF: E6 A5     INC $A5
E701: A9 88     LDA #$88        ; set READ flag
E703: 85 F7     STA $F7
E705: 60        RTS



 $E706/59142:   Write error message string to buffer

Jump from $E6E0, $E75F:

E706: AA        TAX             ; error code to X
E707: A5 86     LDA $86
E709: 48        PHA             ; preserve pointer $86/$87
E70A: A5 87     LDA $87
E70C: 48        PHA
E70D: A9 FC     LDA #$FC
E70F: 85 86     STA $86
E711: A9 E4     LDA #$E4        ; start of the error messages
E713: 85 87     STA $87         ; E4FC
E715: 8A        TXA             ; error number in accumulator
E716: A2 00     LDX #$00

Jump from $E736:

E718: C1 86     CMP ($86,X)     ; compare with error number in table
E71A: F0 21     BEQ $E73D
E71C: 48        PHA
E71D: 20 75 E7  JSR $E775       ; bit 7 into carry and erase
E720: 90 05     BCC $E727       ; not set?

Jump from $E725:

E722: 20 75 E7  JSR $E775       ; bit 7 into carry
E725: 90 FB     BCC $E722       ; wait for character with bit 7 set

Jump from $E720:

E727: A5 87     LDA $87
E729: C9 E6     CMP #$E6
E72B: 90 08     BCC $E735       ; $E60A, check to end of table
E72D: D0 0A     BNE $E739
E72F: A9 0A     LDA #$0A
E731: C5 86     CMP $86
E733: 90 04     BCC $E739

Jump from $E72B:

E735: 68        PLA
E736: 4C 18 E7  JMP $E718       ; no, continue

Jump from $E72D, $E733:

E739: 68        PLA
E73A: 4C 4D E7  JMP $E74D       ; done

Jump from $E71A, $E740:

E73D: 20 67 E7  JSR $E767       ; get a character, bit 7 in carry
E740: 90 FB     BCC $E73D       ; wait for character with bit 7 set

Jump from $E748:

E742: 20 54 E7  JSR $E754       ; and write in buffer
E745: 20 67 E7  JSR $E767       ; get next character
E748: 90 F8     BCC $E742       ; wait for character with bit 7 set
E74A: 20 54 E7  JSR $E754       ; put character in buffer

Jump from $E73A:

E74D: 68        PLA
E74E: 85 87     STA $87
E750: 68        PLA             ; get pointer $86/$87 back
E751: 85 86     STA $86
E753: 60        RTS



 $E754/59220:   Get character and in buffer

Jump from $E742, $E74A:

E754: C9 20     CMP #$20        ; ' ' blank
E756: B0 0B     BCS $E763       ; greater, then write in buffer
E758: AA        TAX             ; save code
E759: A9 20     LDA #$20        ; blank
E75B: 91 A5     STA ($A5),Y     ; write in buffer
E75D: C8        INY             ; increment buffer pointer
E75E: 8A        TXA             ; code in accumulator
E75F: 20 06 E7  JSR $E706       ; output previous text
E762: 60        RTS

Jump from $E756:

E763: 91 A5     STA ($A5),Y     ; write character in buffer
E765: C8        INY             ; and increment pointer
E766: 60        RTS



 $E767/59239:   Get a char of the error message

Jump from $E73D, $E745:

E767: E6 86     INC $86
E769: D0 02     BNE $E76D       ; increment pointer
E76B: E6 87     INC $87

Jump from $E769, $E775:

E76D: A1 86     LDA ($86,X)     ; get character
E76F: 0A        ASL             ; bit 7 into carry
E770: A1 86     LDA ($86,X)     ; get character
E772: 29 7F     AND #$7F        ; erase bit 7
E774: 60        RTS



 $E775/59253:   Increment pointer

Jump from $E71D, $E722:

E775: 20 6D E7  JSR $E76D       ; bit 7 into carry
E778: E6 86     INC $86
E77A: D0 02     BNE $E77E       ; increment pointer
E77C: E6 87     INC $87

Jump from $E77A:

E77E: 60        RTS



 $E77F/59263:   Dummy subroutine

Jump from $E786, $E78B:

E77F: 60        RTS



 $E780/59264:   Check for auto start - removed

Jump from $EBE4:

E780: 60        RTS
E781: EA EA EA EA EA EA EA EA
E789: EA EA EA EA EA EA EA EA
E791: EA EA EA EA EA EA EA EA
E799: EA EA EA EA EA EA EA EA
E7A1: EA 60

 For your interest, this routine was removed:

E780: AD 00 18  LDA $1800       ; read IEEE port
E783: AA        TAX
E784: 29 04     AND #$04        ; isolate 'CLOCK IN' bit
E786: F0 F7     BEQ $E77F       ; not set, then done
E788: 8A        TXA
E789: 29 01     AND #$01        ; isolate 'DATA IN' bit
E78B: F0 02     BEQ $E77F       ; not set, then done
E78D: 58        CLI
E78E: AD 00 18  LDA $1800       ; load IEEE port
E791: 29 05     AND #$05        ; test 'DATA IN' and 'CLOCK IN'
E793: F0 F9     BNE E78E        ; wait until both set
E795: EE 78 02  INC $0278       ; file name
E798: EE 74 02  INC $0274       ; character in the input line
E79B: A9 2A     LDA #$2A        ; '*' as filename
E79D: 8D 00 02  STA $0200       ; write in buffer
E7A0: 4C A8 E7  JMP $E7A8



 $E7A3/59299:   Perform [&] - USR file execute command

E7A3: A9 8D     LDA #$8D
E7A5: 20 68 C2  JSR $C268       ; check command line to end

Jump from $E7A0:

E7A8: 20 58 F2  JSR $F258       ; (RTS)
E7AB: AD 78 02  LDA $0278       ; number of file names
E7AE: 48        PHA             ; save
E7AF: A9 01     LDA #$01
E7B1: 8D 78 02  STA $0278       ; file name
E7B4: A9 FF     LDA #$FF
E7B6: 85 86     STA $86
E7B8: 20 4F C4  JSR $C44F       ; find file
E7BB: AD 80 02  LDA $0280
E7BE: D0 05     BNE $E7C5       ; found?
E7C0: A9 39     LDA #$39
E7C2: 20 C8 C1  JSR $C1C8       ; 39, 'file not found'

Jump from $E7BE:

E7C5: 68        PLA
E7C6: 8D 78 02  STA $0278       ; get number of file names back
E7C9: AD 80 02  LDA $0280
E7CC: 85 80     STA $80         ; track
E7CE: AD 85 02  LDA $0285
E7D1: 85 81     STA $81         ; and sector
E7D3: A9 03     LDA #$03        ; file type 'USR'
E7D5: 20 77 D4  JSR $D477       ; buffer allocated, read 1st block

Jump from $E82E:

E7D8: A9 00     LDA #$00
E7DA: 85 87     STA $87         ; erase checksum
E7DC: 20 39 E8  JSR $E839       ; get byte from file
E7DF: 85 88     STA $88         ; save as start address lo
E7E1: 20 4B E8  JSR $E84B       ; from checksum
E7E4: 20 39 E8  JSR $E839       ; get byte from file
E7E7: 85 89     STA $89         ; as start address hi
E7E9: 20 4B E8  JSR $E84B       ; form checksum
E7EC: A5 86     LDA $86
E7EE: F0 0A     BEQ $E7FA
E7F0: A5 88     LDA $88
E7F2: 48        PHA             ; save program start address
E7F3: A5 89     LDA $89
E7F5: 48        PHA
E7F6: A9 00     LDA #$00
E7F8: 85 86     STA $86

Jump from $E7EE:

E7FA: 20 39 E8  JSR $E839       ; get byte from file
E7FD: 85 8A     STA $8A         ; save as counter
E7FF: 20 4B E8  JSR $E84B       ; form checksum

Jump from $E819:

E802: 20 39 E8  JSR $E839       ; get byte from file
E805: A0 00     LDY #$00
E807: 91 88     STA ($88),Y     ; save as program bytes
E809: 20 4B E8  JSR $E84B       ; form checksum
E80C: A5 88     LDA $88
E80E: 18        CLC
E80F: 69 01     ADC #$01
E811: 85 88     STA $88         ; increment $88/$89
E813: 90 02     BCC $E817
E815: E6 89     INC $89

Jump from $E813:

E817: C6 8A     DEC $8A         ; decrement pointer
E819: D0 E7     BNE $E802
E81B: 20 35 CA  JSR $CA35       ; get next byte
E81E: A5 85     LDA $85         ; data byte
E820: C5 87     CMP $87         ; equal to checksum?
E822: F0 08     BEQ $E82C       ; yes
E824: 20 3E DE  JSR $DE3E       ; transmit parameter to disk controller
E827: A9 50     LDA #$50
E829: 20 45 E6  JSR $E645       ; 50, 'record not present'

Jump from $E822:

E82C: A5 F8     LDA $F8         ; end?
E82E: D0 A8     BNE $E7D8       ; no, next data block
E830: 68        PLA
E831: 85 89     STA $89
E833: 68        PLA             ; get program start address back
E834: 85 88     STA $88
E836: 6C 88 00  JMP ($0088)     ; and execute program

Jump from $E7DC, $E7E4, $E7FA, $E802:

E839: 20 35 CA  JSR $CA35       ; get byte from file
E83C: A5 F8     LDA $F8         ; end?
E83E: D0 08     BNE $E848       ; no
E840: 20 3E DE  JSR $DE3E       ; transmit parameter to disk controller
E843: A9 51     LDA #$51
E845: 20 45 E6  JSR $E645       ; 51, 'overflow in record'

Jump from $E83E:

E848: A5 85     LDA $85         ; data byte
E84A: 60        RTS



 $E84B/59467:   Generate checksum

Jump from $E7E1, $E7E9, $E7FF, $E809:

E84B: 18        CLC
E84C: 65 87     ADC $87
E84E: 69 00     ADC #$00
E850: 85 87     STA $87
E852: 60        RTS



 $E853/59475:   IRQ routine for serial bus

Jump from $FE73:

E853: AD 01 18  LDA $1801       ; read port A, erase IRQ flag
E856: A9 01     LDA #$01
E858: 85 7C     STA $7C         ; set flag for 'ATN received'
E85A: 60        RTS



 $E85B/59483:   Service the serial bus

Jump from $EA56, $EA68, $EC04:

E85B: 78        SEI
E85C: A9 00     LDA #$00
E85E: 85 7C     STA $7C         ; erase flag for 'ATN received'
E860: 85 79     STA $79         ; erase flag for LISTEN
E862: 85 7A     STA $7A         ; erase flag for TALK
E864: A2 45     LDX #$45
E866: 9A        TXS             ; initialize stack pointer
E867: A9 80     LDA #$80
E869: 85 F8     STA $F8         ; erase end flag
E86B: 85 7D     STA $7D         ; erase EOI flag
E86D: 20 B7 E9  JSR $E9B7       ; CLOCK OUT lo
E870: 20 A5 E9  JSR $E9A5       ; DATA OUT, bit '0', hi
E873: AD 00 18  LDA $1800
E876: 09 10     ORA #$10        ; switch data lines to input
E878: 8D 00 18  STA $1800

Jump from $E882:

E87B: AD 00 18  LDA $1800       ; read IEEE port
E87E: 10 57     BPL $E8D7       ; EOI?
E880: 29 04     AND #$04        ; CLOCK IN?
E882: D0 F7     BNE $E87B       ; no

Jump from $E8D5:

E884: 20 C9 E9  JSR $E9C9       ; get byte from bus
E887: C9 3F     CMP #$3F        ; unlisten?
E889: D0 06     BNE $E891       ; no
E88B: A9 00     LDA #$00
E88D: 85 79     STA $79         ; reset flag for LISTEN
E88F: F0 71     BEQ $E902

Jump from $E889:

E891: C9 5F     CMP #$5F        ; untalk?
E893: D0 06     BNE $E89B       ; no
E895: A9 00     LDA #$00
E897: 85 7A     STA $7A         ; reset flag for TALK
E899: F0 67     BEQ $E902

Jump from $E893:

E89B: C5 78     CMP $78         ; TALK address?
E89D: D0 0A     BNE $E8A9       ; no
E89F: A9 01     LDA #$01
E8A1: 85 7A     STA $7A         ; set flag for TALK
E8A3: A9 00     LDA #$00
E8A5: 85 79     STA $79         ; reset flag for LISTEN
E8A7: F0 29     BEQ $E8D2

Jump from $E89D:

E8A9: C5 77     CMP $77         ; LISTEN address?
E8AB: D0 0A     BNE $E8B7       ; no
E8AD: A9 01     LDA #$01
E8AF: 85 79     STA $79         ; set flag for LISTEN
E8B1: A9 00     LDA #$00
E8B3: 85 7A     STA $7A         ; reset flag for TALK
E8B5: F0 1B     BEQ $E8D2

Jump from $E8AB:

E8B7: AA        TAX
E8B8: 29 60     AND #$60
E8BA: C9 60     CMP #$60        ; set bit 5 and 6
E8BC: D0 3F     BNE $E8FD       ; no
E8BE: 8A        TXA
E8BF: 85 84     STA $84         ; byte is secondary address
E8C1: 29 0F     AND #$0F
E8C3: 85 83     STA $83         ; channel number
E8C5: A5 84     LDA $84
E8C7: 29 F0     AND #$F0
E8C9: C9 E0     CMP #$E0        ; CLOSE?
E8CB: D0 35     BNE $E902
E8CD: 58        CLI
E8CE: 20 C0 DA  JSR $DAC0       ; CLOSE routine
E8D1: 78        SEI

Jump from $E8A7, $E8B5:

E8D2: 2C 00 18  BIT $1800
E8D5: 30 AD     BMI $E884

Jump from $E87E, $E905, $EA6B:

E8D7: A9 00     LDA #$00
E8D9: 85 7D     STA $7D         ; set EOI
E8DB: AD 00 18  LDA $1800       ; IEEE port
E8DE: 29 EF     AND #$EF        ; switch data lines to output
E8E0: 8D 00 18  STA $1800
E8E3: A5 79     LDA $79         ; LISTEN active?
E8E5: F0 06     BEQ $E8ED       ; no
E8E7: 20 2E EA  JSR $EA2E       ; receive data
E8EA: 4C E7 EB  JMP $EBE7       ; to delay loop

Jump from $E8E5:

E8ED: A5 7A     LDA $7A         ; TALK active?
E8EF: F0 09     BEQ $E8FA       ; no
E8F1: 20 9C E9  JSR $E99C       ; DATA OUT, bit '1', lo
E8F4: 20 AE E9  JSR $E9AE       ; CLOCK OUT hi
E8F7: 20 09 E9  JSR $E909       ; send data

Jump from $E8EF:

E8FA: 4C 4E EA  JMP $EA4E       ; to delay loop

Jump from $E8BC:

E8FD: A9 10     LDA #$10        ; either TALK or LISTEN, ignore byte
E8FF: 8D 00 18  STA $1800       ; switch data lines to input

Jump from $E88F, $E899, $E8CB, $E907:

E902: 2C 00 18  BIT $1800
E905: 10 D0     BPL $E8D7
E907: 30 F9     BMI $E902       ; wait for handshake



 $E909/59657:   Send data

Jump from $E8F7:

E909: 78        SEI
E90A: 20 EB D0  JSR $D0EB       ; open channel for read
E90D: B0 06     BCS $E915       ; channel active

Jump from $E996:

E90F: A6 82     LDX $82         ; channel number
E911: B5 F2     LDA $F2,X       ; set READ flag?
E913: 30 01     BMI $E916       ; yes

Jump from $E90D:

E915: 60        RTS

Jump from $E913:

E916: 20 59 EA  JSR $EA59       ; check EOI
E919: 20 C0 E9  JSR $E9C0       ; read IEEE port
E91C: 29 01     AND #$01        ; isolate data bit
E91E: 08        PHP             ; and save
E91F: 20 B7 E9  JSR $E9B7       ; CLOCK OUT lo
E922: 28        PLP
E923: F0 12     BEQ $E937

Jump from $E92D:

E925: 20 59 EA  JSR $EA59       ; check EOI
E928: 20 C0 E9  JSR $E9C0       ; read IEEE port
E92B: 29 01     AND #$01        ; isolate data bit
E92D: D0 F6     BNE $E925
E92F: A6 82     LDX $82         ; channel number
E931: B5 F2     LDA $F2,X
E933: 29 08     AND #$08
E935: D0 14     BNE $E94B

Jump from $E923, $E93F:

E937: 20 59 EA  JSR $EA59       ; check EOI
E93A: 20 C0 E9  JSR $E9C0       ; read IEEE port
E93D: 29 01     AND #$01        ; isolate data bit
E93F: D0 F6     BNE $E937

Jump from $E949:

E941: 20 59 EA  JSR $EA59       ; check EOI
E944: 20 C0 E9  JSR $E9C0       ; read IEEE port
E947: 29 01     AND #$01        ; isolate data bit
E949: F0 F6     BEQ $E941

Jump from $E935, $E956:

E94B: 20 AE E9  JSR $E9AE       ; CLOCK OUT hi
E94E: 20 59 EA  JSR $EA59       ; check EOI
E951: 20 C0 E9  JSR $E9C0       ; read IEEE port
E954: 29 01     AND #$01        ; isolate data bit
E956: D0 F3     BNE $E94B
E958: A9 08     LDA #$08        ; counter to 8 bits for serial
E95A: 85 98     STA $98         ; transmission

Jump from $E985:

E95C: 20 C0 E9  JSR $E9C0       ; read IEEE port
E95F: 29 01     AND #$01        ; isolate data bit
E961: D0 36     BNE $E999
E963: A6 82     LDX $82
E965: BD 3E 02  LDA $023E,X
E968: 6A        ROR             ; lowest data bit in carry
E969: 9D 3E 02  STA $023E,X
E96C: B0 05     BCS $E973       ; set bit
E96E: 20 A5 E9  JSR $E9A5       ; DATA OUT, output bit '0'
E971: D0 03     BNE $E976       ; absolute jump

Jump from $E96C:

E973: 20 9C E9  JSR $E99C       ; DATA OUT, output bit '1'

Jump from $E971:

E976: 20 B7 E9  JSR $E9B7       ; set CLOCK OUT
E979: A5 23     LDA $23
E97B: D0 03     BNE $E980
E97D: 20 F3 FE  JSR $FEF3       ; delay for serial bus

Jump from $E97B:

E980: 20 FB FE  JSR $FEFB       ; set DATA OUT and CLOCK OUT
E983: C6 98     DEC $98         ; all bits output?
E985: D0 D5     BNE $E95C       ; no

Jump from $E98F:

E987: 20 59 EA  JSR $EA59       ; check EOI
E98A: 20 C0 E9  JSR $E9C0       ; read IEEE port
E98D: 29 01     AND #$01        ; isolate data bit
E98F: F0 F6     BEQ $E987
E991: 58        CLI
E992: 20 AA D3  JSR $D3AA       ; get next data byte
E995: 78        SEI
E996: 4C 0F E9  JMP $E90F       ; and output

Jump from $E961:

E999: 4C 4E EA  JMP $EA4E       ; to delay loop



 $E99C/59804:   DATA OUT lo

Jump from $E8F1, $E973, $E9D7, $E9FA, $FEFE:

E99C: AD 00 18  LDA $1800
E99F: 29 FD     AND #$FD        ; output bit '1'
E9A1: 8D 00 18  STA $1800
E9A4: 60        RTS



 $E9A5/59813:   DATA OUT hi

Jump from $E870, $E96E, $E9F2, $EA28:

E9A5: AD 00 18  LDA $1800
E9A8: 09 02     ORA #$02        ; output bit '0'
E9AA: 8D 00 18  STA $1800
E9AD: 60        RTS



 $E9AE/59822:   CLOCK OUT hi

Jump from $E8F4, $E94B, $FEFB:

E9AE: AD 00 18  LDA $1800
E9B1: 09 08     ORA #$08        ; set bit 3
E9B3: 8D 00 18  STA $1800
E9B6: 60        RTS



 $E9B7/59831:   CLOCK OUT lo

Jump from $E86D, $E91F, $E976:

E9B7: AD 00 18  LDA $1800
E9BA: 29 F7     AND #$F7        ; erase bit 3
E9BC: 8D 00 18  STA $1800
E9BF: 60        RTS



 $E9C0/59840:   Read IEEE port

Jump from $E9C6, $E919, $E928, $E93A, $E944, $E951, $E95C, $E98A, $E9D0,
          $E9E9, $EA00, $EA1D:

E9C0: AD 00 18  LDA $1800       ; read port
E9C3: CD 00 18  CMP $1800       ; wait for constants
E9C6: D0 F8     BNE $E9C0
E9C8: 60        RTS



 $E9C9/59849:   Get data byte from bus

Jump from $E884, $EA44:

E9C9: A9 08     LDA #$08
E9CB: 85 98     STA $98         ; bit counter for serial output

Jump from $E9D5:

E9CD: 20 59 EA  JSR $EA59       ; check EOI
E9D0: 20 C0 E9  JSR $E9C0       ; read IEEE port
E9D3: 29 04     AND #$04        ; CLOCK IN?
E9D5: D0 F6     BNE $E9CD       ; no, wait
E9D7: 20 9C E9  JSR $E99C       ; DATA OUT, bit '1'
E9DA: A9 01     LDA #$01
E9DC: 4C 20 FF  JMP $FF20       ; set timer

Jump from $E9EE, $FF2C:

E9DF: 20 59 EA  JSR $EA59       ; check EOI
E9E2: AD 0D 18  LDA $180D
E9E5: 29 40     AND #$40        ; timer run down?
E9E7: D0 09     BNE $E9F2       ; yes, EOI
E9E9: 20 C0 E9  JSR $E9C0       ; read IEEE port
E9EC: 29 04     AND #$04        ; CLOCK IN?
E9EE: F0 EF     BEQ $E9DF       ; no, wait
E9F0: D0 19     BNE $EA0B



 $E9F2/59890:   Accept byte with EOI

Jump from $E9E7:

E9F2: 20 A5 E9  JSR $E9A5       ; DATA OUT bit '0' hi
E9F5: A2 0A     LDX #$0A        ; 10

Jump from $E9F8:

E9F7: CA        DEX             ; delay loop, approx 50 micro sec.
E9F8: D0 FD     BNE $E9F7
E9FA: 20 9C E9  JSR $E99C       ; DATA OUT, bit '1', lo

Jump from $EA05:

E9FD: 20 59 EA  JSR $EA59       ; check EOI
EA00: 20 C0 E9  JSR $E9C0       ; read IEEE
EA03: 29 04     AND #$04        ; CLOCK IN?
EA05: F0 F6     BEQ $E9FD       ; no, wait
EA07: A9 00     LDA #$00
EA09: 85 F8     STA $F8         ; set EOI flag

Jump from $EA13, $EA26, $E9F0:

EA0B: AD 00 18  LDA $1800       ; IEEE port
EA0E: 49 01     EOR #$01        ; invert data byte
EA10: 4A        LSR
EA11: 29 02     AND #$02
EA13: D0 F6     BNE $EA0B       ; CLOCK IN?
EA15: EA        NOP
EA16: EA        NOP
EA17: EA        NOP
EA18: 66 85     ROR $85         ; prepare next bit

Jump from $EA22:

EA1A: 20 59 EA  JSR $EA59       ; check EOI
EA1D: 20 C0 E9  JSR $E9C0       ; read IEEE port
EA20: 29 04     AND #$04        ; CLOCK IN?
EA22: F0 F6     BEQ $EA1A       ; no
EA24: C6 98     DEC $98         ; decrement bit counter
EA26: D0 E3     BNE $EA0B       ; all bits output?
EA28: 20 A5 E9  JSR $E9A5       ; DATA OUT, bit '0', hi
EA2B: A5 85     LDA $85         ; load data byte again
EA2D: 60        RTS



 $EA2E/59950:   Accept data from serial bus

Jump from $EA4B, $E8E7:

EA2E: 78        SEI
EA2F: 20 07 D1  JSR $D107       ; open channel for writing
EA32: B0 05     BCS $EA39       ; channel not active?
EA34: B5 F2     LDA $F2,X       ; WRITE flag
EA36: 6A        ROR
EA37: B0 0B     BCS $EA44       ; not set?

Jump from $EA32:

EA39: A5 84     LDA $84         ; secondary address
EA3B: 29 F0     AND #$F0
EA3D: C9 F0     CMP #$F0        ; OPEN command?
EA3F: F0 03     BEQ $EA44       ; yes
EA41: 4C 4E EA  JMP $EA4E       ; to wait loop

Jump from $EA37, $EA3F:

EA44: 20 C9 E9  JSR $E9C9       ; get data byte from bus
EA47: 58        CLI
EA48: 20 B7 CF  JSR $CFB7       ; and write in buffer
EA4B: 4C 2E EA  JMP $EA2E       ; to loop beginning

Jump from $EA41, $E8FA, $E999:

EA4E: A9 00     LDA #$00
EA50: 8D 00 18  STA $1800       ; reset IEEE port
EA53: 4C E7 EB  JMP $EBE7       ; to wait loop
EA56: 4C 5B E8  JMP $E85B       ; to serial bus main loop



 $EA59/59993:   Test for ATN

Jump from $E916, $E925, $E937, $E941, $E94E, $E987, $E9CD, $E9DF, $E9FD,
          $EA1A:

EA59: A5 7D     LDA $7D         ; EOI received?
EA5B: F0 06     BEQ $EA63       ; yes
EA5D: AD 00 18  LDA $1800       ; IEEE port
EA60: 10 09     BPL $EA6B

Jump from $EA66:

EA62: 60        RTS

Jump from $EA5B:

EA63: AD 00 18  LDA $1800       ; IEEE port
EA66: 10 FA     BPL $EA62
EA68: 4C 5B E8  JMP $E85B       ; to serial bus main loop

Jump from $EA60:

EA6B: 4C D7 E8  JMP $E8D7       ; set EOI, serial bus



 $EA6E/60014:   Flash LED for hardware defects, self-test

Jump from $EAB5, $EABE, $EAC4:

EA6E: A2 00     LDX #$00        ; blink once, zero page
EA70: 2C        .BYTE $2C

Jump from $EB1F:

EA71: A6 6F     LDX $6F         ; blink X+1 times for RAM/ROM err
EA73: 9A        TXS

Jump from $EA9E:

EA74: BA        TSX

Jump from $EA98:

EA75: A9 08     LDA #$08        ; select LED bit in the port
EA77: 0D 00 1C  ORA $1C00
EA7A: 4C EA FE  JMP $FEEA       ; turn LED on, back to $EA7D

Jump from $FEF0:

EA7D: 98        TYA

Jump from $EA84:

EA7E: 18        CLC

Jump from $EA81:

EA7F: 69 01     ADC #$01
EA81: D0 FC     BNE $EA7F
EA83: 88        DEY
EA84: D0 F8     BNE $EA7E
EA86: AD 00 1C  LDA $1C00
EA89: 29 F7     AND #$F7        ; turn LED off
EA8B: 8D 00 1C  STA $1C00

Jump from $EA9C:

EA8E: 98        TYA

Jump from $EA95:

EA8F: 18        CLC

Jump from $EA92:

EA90: 69 01     ADC #$01
EA92: D0 FC     BNE $EA90       ; delay loop
EA94: 88        DEY
EA95: D0 F8     BNE $EA8F
EA97: CA        DEX
EA98: 10 DB     BPL $EA75
EA9A: E0 FC     CPX #$FC
EA9C: D0 F0     BNE $EA8E       ; wait for delay
EA9E: F0 D4     BEQ $EA74



 $EAA0/60064:   Power-up RESET routine

EAA0: 78        SEI
EAA1: D8        CLD
EAA2: A2 FF     LDX #$FF
EAA4: 4C 10 FF  JMP $FF10       ; port A to output

Jump from $FF1D:

EAA7: E8        INX
EAA8: A0 00     LDY #$00
EAAA: A2 00     LDX #$00

Jump from $EAB0:

EAAC: 8A        TXA
EAAD: 95 00     STA $00,X       ; erase zero page
EAAF: E8        INX
EAB0: D0 FA     BNE $EAAC

Jump from $EAC7:

EAB2: 8A        TXA
EAB3: D5 00     CMP $00,X       ; is byte erased?
EAB5: D0 B7     BNE $EA6E       ; no, then to error display (blink)

Jump from $EABA:

EAB7: F6 00     INC $00,X
EAB9: C8        INY
EABA: D0 FB     BNE $EAB7
EABC: D5 00     CMP $00,X
EABE: D0 AE     BNE $EA6E       ; error
EAC0: 94 00     STY $00,X
EAC2: B5 00     LDA $00,X
EAC4: D0 A8     BNE $EA6E       ; error
EAC6: E8        INX
EAC7: D0 E9     BNE $EAB2

Jump from $EAE8:

EAC9: E6 6F     INC $6F
EACB: 86 76     STX $76
EACD: A9 00     LDA #$00
EACF: 85 75     STA $75
EAD1: A8        TAY
EAD2: A2 20     LDX #$20        ; test 32 pages
EAD4: 18        CLC

Jump from $EADD:

EAD5: C6 76     DEC $76

Jump from $EADA:

EAD7: 71 75     ADC ($75),Y
EAD9: C8        INY
EADA: D0 FB     BNE $EAD7
EADC: CA        DEX
EADD: D0 F6     BNE $EAD5       ; test ROM
EADF: 69 00     ADC #$00
EAE1: AA        TAX
EAE2: C5 76     CMP $76
EAE4: D0 39     BNE $EB1F       ; ROM error
EAE6: E0 C0     CPX #$C0
EAE8: D0 DF     BNE $EAC9
EAEA: A9 01     LDA #$01
EAEC: 85 76     STA $76
EAEE: E6 6F     INC $6F
EAF0: A2 07     LDX #$07        ; test RAM, beginning at page 7

Jump from $EAF9, $EAFE:

EAF2: 98        TYA
EAF3: 18        CLC
EAF4: 65 76     ADC $76
EAF6: 91 75     STA ($75),Y
EAF8: C8        INY
EAF9: D0 F7     BNE $EAF2
EAFB: E6 76     INC $76
EAFD: CA        DEX
EAFE: D0 F2     BNE $EAF2
EB00: A2 07     LDX #$07

Jump from $EB1B:

EB02: C6 76     DEC $76

Jump from $EB18:

EB04: 88        DEY
EB05: 98        TYA
EB06: 18        CLC
EB07: 65 76     ADC $76
EB09: D1 75     CMP ($75),Y
EB0B: D0 12     BNE $EB1F       ; RAM error
EB0D: 49 FF     EOR #$FF
EB0F: 91 75     STA ($75),Y
EB11: 51 75     EOR ($75),Y
EB13: 91 75     STA ($75),Y
EB15: D0 08     BNE $EB1F       ; RAM error
EB17: 98        TYA
EB18: D0 EA     BNE $EB04
EB1A: CA        DEX
EB1B: D0 E5     BNE $EB02       ; continue test
EB1D: F0 03     BEQ $EB22       ; ok

Jump from $EAE4, $EB0B, $EB15:

EB1F: 4C 71 EA  JMP $EA71       ; to error display

Jump from $EB1D:

EB22: A2 45     LDX #$45
EB24: 9A        TXS             ; initialize stack pointer
EB25: AD 00 1C  LDA $1C00
EB28: 29 F7     AND #$F7        ; turn LED off
EB2A: 8D 00 1C  STA $1C00
EB2D: A9 01     LDA #$01
EB2F: 8D 0C 18  STA $180C       ; CA1 (ATN IN) trigger on positive edge
EB32: A9 82     LDA #$82
EB34: 8D 0D 18  STA $180D       ; interrupt possible through ATN IN
EB37: 8D 0E 18  STA $180E
EB3A: AD 00 18  LDA $1800       ; read port B
EB3D: 29 60     AND #$60        ; isolate bits 5 & 6 (device number)
EB3F: 0A        ASL
EB40: 2A        ROL
EB41: 2A        ROL             ; rotate to bit positions 0 & 1
EB42: 2A        ROL
EB43: 09 48     ORA #$48        ; add offset from 8 + $40 for TALK
EB45: 85 78     STA $78         ; device number for TALK (send)
EB47: 49 60     EOR #$60        ; erase bit 6, set bit 5
EB49: 85 77     STA $77         ; device number + $20 for LISTEN
EB4B: A2 00     LDX #$00
EB4D: A0 00     LDY #$00

Jump from $EB5D:

EB4F: A9 00     LDA #$00
EB51: 95 99     STA $99,X       ; low-byte of buffer address
EB53: E8        INX
EB54: B9 E0 FE  LDA $FEE0,Y     ; high-byte of address from table
EB57: 95 99     STA $99,X       ; save
EB59: E8        INX
EB5A: C8        INY
EB5B: C0 05     CPY #$05
EB5D: D0 F0     BNE $EB4F
EB5F: A9 00     LDA #$00
EB61: 95 99     STA $99,X
EB63: E8        INX             ; pointer $A3/$A4 to $200, input buffer
EB64: A9 02     LDA #$02
EB66: 95 99     STA $99,X
EB68: E8        INX
EB69: A9 D5     LDA #$D5
EB6B: 95 99     STA $99,X
EB6D: E8        INX             ; pointer $A5/$A6 to $2D5, error
EB6E: A9 02     LDA #$02        ; message pointer
EB70: 95 99     STA $99,X
EB72: A9 FF     LDA #$FF
EB74: A2 12     LDX #$12

Jump from $EB7A:

EB76: 9D 2B 02  STA $022B,X     ; fill channel table with $FF
EB79: CA        DEX
EB7A: 10 FA     BPL $EB76
EB7C: A2 05     LDX #$05

Jump from $EB85:

EB7E: 95 A7     STA $A7,X       ; erase buffer table
EB80: 95 AE     STA $AE,X
EB82: 95 CD     STA $CD,X       ; erase side-sector table
EB84: CA        DEX
EB85: 10 F7     BPL $EB7E
EB87: A9 05     LDA #$05        ; buffer 5
EB89: 85 AB     STA $AB         ; associate with channel 4
EB8B: A9 06     LDA #$06        ; buffer 4
EB8D: 85 AC     STA $AC         ; associate with channel 5
EB8F: A9 FF     LDA #$FF
EB91: 85 AD     STA $AD
EB93: 85 B4     STA $B4
EB95: A9 05     LDA #$05
EB97: 8D 3B 02  STA $023B       ; channel 5 WRITE flag erased
EB9A: A9 84     LDA #$84
EB9C: 8D 3A 02  STA $023A       ; channel 4 WRITE flag set
EB9F: A9 0F     LDA #$0F        ; initialize channel allocation register
EBA1: 8D 56 02  STA $0256       ; bit '1' equals channel free
EBA4: A9 01     LDA #$01
EBA6: 85 F6     STA $F6         ; WRITE flag
EBA8: A9 88     LDA #$88
EBAA: 85 F7     STA $F7         ; READ flag
EBAC: A9 E0     LDA #$E0        ; 5 buffers free
EBAE: 8D 4F 02  STA $024F       ; initialize buffer allocation register
EBB1: A9 FF     LDA #$FF        ; $24F/$250, 16 bit
EBB3: 8D 50 02  STA $0250
EBB6: A9 01     LDA #$01
EBB8: 85 1C     STA $1C         ; flag for WRITE protect
EBBA: 85 1D     STA $1D
EBBC: 20 63 CB  JSR $CB63       ; set vector for U0
EBBF: 20 FA CE  JSR $CEFA       ; initialize channel table
EBC2: 20 59 F2  JSR $F259       ; initialization for disk controller
EBC5: A9 22     LDA #$22
EBC7: 85 65     STA $65
EBC9: A9 EB     LDA #$EB        ; pointer $65/$66 to $EB22
EBCB: 85 66     STA $66
EBCD: A9 0A     LDA #$0A
EBCF: 85 69     STA $69         ; step width 10
EBD1: A9 05     LDA #$05        ; for sector assignment
EBD3: 85 6A     STA $6A         ; 5 read attempts
EBD5: A9 73     LDA #$73        ; prepare power-up message
EBD7: 20 C1 E6  JSR $E6C1       ; 73, 'cbm dos v2.6 1541'
EBDA: A9 00     LDA #$00        ; bit 1, 3 & 4 to output
EBDC: 8D 00 18  STA $1800       ; data direction of port B
EBDF: A9 1A     LDA #$1A
EBE1: 8D 02 18  STA $1802       ; erase data register
EBE4: 20 80 E7  JSR $E780       ; check for auto-start

Jump from $E698, $E8EA, $EA53:

EBE7: 58        CLI
EBE8: AD 00 18  LDA $1800
EBEB: 29 E5     AND #$E5        ; reset serial port
EBED: 8D 00 18  STA $1800
EBF0: AD 55 02  LDA $0255       ; command flag set?
EBF3: F0 0A     BEQ $EBFF       ; no
EBF5: A9 00     LDA #$00
EBF7: 8D 55 02  STA $0255       ; reset command flag
EBFA: 85 67     STA $67
EBFC: 20 46 C1  JSR $C146       ; analyze and execute command



 $EBFF/60415:   Wait loop

Jump from $EC9B, $EBF3:

EBFF: 58        CLI
EC00: A5 7C     LDA $7C         ; ATN signal discovered?
EC02: F0 03     BEQ $EC07       ; no
EC04: 4C 5B E8  JMP $E85B       ; to IEEE routine

Jump from $EC02:

EC07: 58        CLI
EC08: A9 0E     LDA #$0E        ; 14
EC0A: 85 72     STA $72         ; as secondary address
EC0C: A9 00     LDA #$00
EC0E: 85 6F     STA $6F         ; job counter
EC10: 85 70     STA $70

Jump from $EC2D:

EC12: A6 72     LDX $72
EC14: BD 2B 02  LDA $022B,X     ; secondary address
EC17: C9 FF     CMP #$FF        ; channel associated?
EC19: F0 10     BEQ $EC2B       ; no
EC1B: 29 3F     AND #$3F
EC1D: 85 82     STA $82         ; channel number
EC1F: 20 93 DF  JSR $DF93       ; get buffer number
EC22: AA        TAX
EC23: BD 5B 02  LDA $025B,X     ; drive number
EC26: 29 01     AND #$01
EC28: AA        TAX
EC29: F6 6F     INC $6F,X       ; increment job counter

Jump from $EC19:

EC2B: C6 72     DEC $72         ; lo address
EC2D: 10 E3     BPL $EC12       ; continue search
EC2F: A0 04     LDY #$04        ; buffer counter

Jump from $EC3C:

EC31: B9 00 00  LDA $00,Y       ; disk controller in action?
EC34: 10 05     BPL $EC3B       ; no
EC36: 29 01     AND #$01        ; isolate drive number
EC38: AA        TAX
EC39: F6 6F     INC $6F,X       ; increment job counter

Jump from $EC34:

EC3B: 88        DEY
EC3C: 10 F3     BPL $EC31       ; next buffer
EC3E: 78        SEI
EC3F: AD 00 1C  LDA $1C00
EC42: 29 F7     AND #$F7        ; erase LED bit
EC44: 48        PHA
EC45: A5 7F     LDA $7F         ; drive number
EC47: 85 86     STA $86
EC49: A9 00     LDA #$00
EC4B: 85 7F     STA $7F         ; drive 0
EC4D: A5 6F     LDA $6F         ; job for drive 0?
EC4F: F0 0B     BEQ $EC5C       ; no
EC51: A5 1C     LDA $1C         ; write protect for drive 0?
EC53: F0 03     BEQ $EC58       ; no
EC55: 20 13 D3  JSR $D313       ; close all channels to drive 0

Jump from $EC53:

EC58: 68        PLA
EC59: 09 08     ORA #$08        ; set LED bit
EC5B: 48        PHA

Jump from $EC4F:

EC5C: E6 7F     INC $7F         ; increment drive number
EC5E: A5 70     LDA $70         ; job for drive 1?
EC60: F0 0B     BEQ $EC6D       ; no
EC62: A5 1D     LDA $1D         ; write protect for drive 1?
EC64: F0 03     BEQ $EC69       ; no
EC66: 20 13 D3  JSR $D313       ; close all channels to drive 1

Jump from $EC64:

EC69: 68        PLA
EC6A: 09 00     ORA #$00
EC6C: 48        PHA

Jump from $EC60:

EC6D: A5 86     LDA $86
EC6F: 85 7F     STA $7F         ; get drive number back
EC71: 68        PLA             ; bit for LED
EC72: AE 6C 02  LDX $026C       ; interrupt counter
EC75: F0 21     BEQ $EC98       ; to zero?
EC77: AD 00 1C  LDA $1C00
EC7A: E0 80     CPX #$80
EC7C: D0 03     BNE $EC81
EC7E: 4C 8B EC  JMP $EC8B

Jump from $EC7C:

EC81: AE 05 18  LDX $1805       ; erase timer interrupt
EC84: 30 12     BMI $EC98
EC86: A2 A0     LDX #$A0
EC88: 8E 05 18  STX $1805       ; set timer

Jump from $EC7E:

EC8B: CE 6C 02  DEC $026C       ; decrement counter
EC8E: D0 08     BNE $EC98       ; not yet zero?
EC90: 4D 6D 02  EOR $026D
EC93: A2 10     LDX #$10
EC95: 8E 6C 02  STX $026C       ; reset counter

Jump from $EC75, $EC84, $EC8E:

EC98: 8D 00 1C  STA $1C00       ; turn LED on/off
EC9B: 4C FF EB  JMP $EBFF       ; back to wait loop



 $EC9E/60574:   Load dir

Jump from $DAA7:

EC9E: A9 00     LDA #$00
ECA0: 85 83     STA $83         ; secondary address 0
ECA2: A9 01     LDA #$01
ECA4: 20 E2 D1  JSR $D1E2       ; find channel and buffer
ECA7: A9 00     LDA #$00
ECA9: 20 C8 D4  JSR $D4C8       ; initialize buffer pointer
ECAC: A6 82     LDX $82         ; channel number
ECAE: A9 00     LDA #$00
ECB0: 9D 44 02  STA $0244,X     ; pointer to end = zero
ECB3: 20 93 DF  JSR $DF93       ; get buffer number
ECB6: AA        TAX
ECB7: A5 7F     LDA $7F         ; drive number
ECB9: 9D 5B 02  STA $025B,X     ; bring in table
ECBC: A9 01     LDA #$01        ; 1
ECBE: 20 F1 CF  JSR $CFF1       ; write in buffer
ECC1: A9 04     LDA #$04        ; 4, start address $0401
ECC3: 20 F1 CF  JSR $CFF1       ; write in buffer
ECC6: A9 01     LDA #$01        ; 2 times 1
ECC8: 20 F1 CF  JSR $CFF1
ECCB: 20 F1 CF  JSR $CFF1       ; write in buffer as link address
ECCE: AD 72 02  LDA $0272       ; drive number
ECD1: 20 F1 CF  JSR $CFF1       ; write in buffer as line number
ECD4: A9 00     LDA #$00        ; line number hi
ECD6: 20 F1 CF  JSR $CFF1       ; in buffer
ECD9: 20 59 ED  JSR $ED59       ; directory entry in buffer
ECDC: 20 93 DF  JSR $DF93       ; get buffer number
ECDF: 0A        ASL
ECE0: AA        TAX
ECE1: D6 99     DEC $99,X       ; decrement buffer pointer
ECE3: D6 99     DEC $99,X
ECE5: A9 00     LDA #$00
ECE7: 20 F1 CF  JSR $CFF1       ; 0 as line end in buffer

Jump from $ED0B, $ED7F:

ECEA: A9 01     LDA #$01
ECEC: 20 F1 CF  JSR $CFF1       ; 2 times 1 as link address
ECEF: 20 F1 CF  JSR $CFF1
ECF2: 20 CE C6  JSR $C6CE       ; directory entry in buffer
ECF5: 90 2C     BCC $ED23       ; another entry?
ECF7: AD 72 02  LDA $0272       ; block number lo
ECFA: 20 F1 CF  JSR $CFF1       ; in buffer
ECFD: AD 73 02  LDA $0273       ; block number hi
ED00: 20 F1 CF  JSR $CFF1       ; in buffer
ED03: 20 59 ED  JSR $ED59       ; directory entry in buffer
ED06: A9 00     LDA #$00
ED08: 20 F1 CF  JSR $CFF1       ; zero as end marker in buffer
ED0B: D0 DD     BNE $ECEA       ; buffer full? no

Jump from $ED56:

ED0D: 20 93 DF  JSR $DF93       ; get buffer number
ED10: 0A        ASL
ED11: AA        TAX
ED12: A9 00     LDA #$00
ED14: 95 99     STA $99,X       ; buffer pointer to zero
ED16: A9 88     LDA #$88        ; set READ flag
ED18: A4 82     LDY $82         ; channel number
ED1A: 8D 54 02  STA $0254
ED1D: 99 F2 00  STA $F2,Y       ; flag for channel
ED20: A5 85     LDA $85         ; data byte
ED22: 60        RTS



 $ED23/60707:   ?

Jump from $ECF5:

ED23: AD 72 02  LDA $0272       ; block number lo
ED26: 20 F1 CF  JSR $CFF1       ; write in buffer
ED29: AD 73 02  LDA $0273       ; block number hi
ED2C: 20 F1 CF  JSR $CFF1       ; in buffer
ED2F: 20 59 ED  JSR $ED59       ; 'blocks free.' in buffer
ED32: 20 93 DF  JSR $DF93       ; get buffer number
ED35: 0A        ASL
ED36: AA        TAX
ED37: D6 99     DEC $99,X
ED39: D6 99     DEC $99,X       ; buffer pointer minus 2
ED3B: A9 00     LDA #$00
ED3D: 20 F1 CF  JSR $CFF1
ED40: 20 F1 CF  JSR $CFF1       ; three zeroes as program end
ED43: 20 F1 CF  JSR $CFF1
ED46: 20 93 DF  JSR $DF93       ; get buffer number
ED49: 0A        ASL             ; times 2
ED4A: A8        TAY
ED4B: B9 99 00  LDA $99,Y       ; buffer pointer
ED4E: A6 82     LDX $82
ED50: 9D 44 02  STA $0244,X     ; as end marker
ED53: DE 44 02  DEC $0244,X
ED56: 4C 0D ED  JMP $ED0D



 $ED59/60761:   Transmit dir line

Jump from $ECD9, $ED03, $ED2F:

ED59: A0 00     LDY #$00

Jump from $ED64:

ED5B: B9 B1 02  LDA $02B1,Y     ; character from buffer
ED5E: 20 F1 CF  JSR $CFF1       ; write in output buffer
ED61: C8        INY
ED62: C0 1B     CPY #$1B        ; 27 characters?
ED64: D0 F5     BNE $ED5B
ED66: 60        RTS



 $ED67/60775:   Get byte from buffer

Jump from $D40E:

ED67: 20 37 D1  JSR $D137       ; get byte
ED6A: F0 01     BEQ $ED6D       ; buffer pointer zero?
ED6C: 60        RTS

Jump from $ED6A:

ED6D: 85 85     STA $85         ; save data byte
ED6F: A4 82     LDY $82         ; channel number
ED71: B9 44 02  LDA $0244,Y     ; set end marker
ED74: F0 08     BEQ $ED7E       ; zero (LOAD $)?
ED76: A9 80     LDA #$80
ED78: 99 F2 00  STA $F2,Y       ; set READ flag
ED7B: A5 85     LDA $85         ; data byte
ED7D: 60        RTS

Jump from $ED74:

ED7E: 48        PHA
ED7F: 20 EA EC  JSR $ECEA       ; create directory line in buffer
ED82: 68        PLA
ED83: 60        RTS



 $ED84/60804:   Perform [V] - Validate command

ED84: 20 D1 C1  JSR $C1D1       ; find drive number in input line
ED87: 20 42 D0  JSR $D042       ; load BAM
ED8A: A9 40     LDA #$40
ED8C: 8D F9 02  STA $02F9
ED8F: 20 B7 EE  JSR $EEB7       ; create new BAM in buffer
ED92: A9 00     LDA #$00
ED94: 8D 92 02  STA $0292
ED97: 20 AC C5  JSR $C5AC       ; load directory, find 1st flag
ED9A: D0 3D     BNE $EDD9       ; found?

Jump from $EDD7:

ED9C: A9 00     LDA #$00
ED9E: 85 81     STA $81         ; sector 0
EDA0: AD 85 FE  LDA $FE85       ; 18
EDA3: 85 80     STA $80         ; track 18 for BAM
EDA5: 20 E5 ED  JSR $EDE5       ; mark directory blocks as allocated
EDA8: A9 00     LDA #$00
EDAA: 8D F9 02  STA $02F9
EDAD: 20 FF EE  JSR $EEFF       ; write BAM back to disk
EDB0: 4C 94 C1  JMP $C194       ; done, prepare disk status



 $EDB3/60851:   ?

Jump from $EDDD:

EDB3: C8        INY
EDB4: B1 94     LDA ($94),Y     ; save track
EDB6: 48        PHA
EDB7: C8        INY
EDB8: B1 94     LDA ($94),Y     ; and sector
EDBA: 48        PHA
EDBB: A0 13     LDY #$13        ; pointer to side-sector block
EDBD: B1 94     LDA ($94),Y
EDBF: F0 0A     BEQ $EDCB       ; no track following?
EDC1: 85 80     STA $80         ; track and
EDC3: C8        INY
EDC4: B1 94     LDA ($94),Y
EDC6: 85 81     STA $81         ; sector of 1st side-sector block
EDC8: 20 E5 ED  JSR $EDE5       ; mark side-sector block as

Jump from $EDBF:

EDCB: 68        PLA             ; allocated
EDCC: 85 81     STA $81
EDCE: 68        PLA             ; get track and sector back
EDCF: 85 80     STA $80
EDD1: 20 E5 ED  JSR $EDE5       ; mark blocks of file as allocated

Jump from $EDE2:

EDD4: 20 04 C6  JSR $C604       ; read next entry in directory
EDD7: F0 C3     BEQ $ED9C       ; end of directory?

Jump from $ED9A:

EDD9: A0 00     LDY #$00
EDDB: B1 94     LDA ($94),Y     ; file type
EDDD: 30 D4     BMI $EDB3       ; bit 7 set, file closed?
EDDF: 20 B6 C8  JSR $C8B6       ; file type to zero and write BAM
EDE2: 4C D4 ED  JMP $EDD4



 $EDE5/60901:   Allocate file blocks in BAM

Jump from $EDA5, $EDC8, $EDD1:

EDE5: 20 5F D5  JSR $D55F       ; check track and sector number
EDE8: 20 90 EF  JSR $EF90       ; allocate block in BAM
EDEB: 20 75 D4  JSR $D475       ; read next block

Jump from $EE0A:

EDEE: A9 00     LDA #$00
EDF0: 20 C8 D4  JSR $D4C8       ; buffer pointer zero
EDF3: 20 37 D1  JSR $D137       ; get byte from buffer
EDF6: 85 80     STA $80         ; track
EDF8: 20 37 D1  JSR $D137       ; get byte from buffer
EDFB: 85 81     STA $81         ; sector
EDFD: A5 80     LDA $80         ; another block?
EDFF: D0 03     BNE $EE04       ; yes
EE01: 4C 27 D2  JMP $D227       ; close channel

Jump from $EDFF:

EE04: 20 90 EF  JSR $EF90       ; allocate block in BAM
EE07: 20 4D D4  JSR $D44D       ; read next block
EE0A: 4C EE ED  JMP $EDEE       ; continue



 $EE0D/60941:   Perform [N] - New (Format) command

EE0D: 20 12 C3  JSR $C312       ; get drive number
EE10: A5 E2     LDA $E2         ; drive number
EE12: 10 05     BPL $EE19       ; not clear?
EE14: A9 33     LDA #$33
EE16: 4C C8 C1  JMP $C1C8       ; 33, 'syntax error'

Jump from $EE12:

EE19: 29 01     AND #$01
EE1B: 85 7F     STA $7F         ; drive number
EE1D: 20 00 C1  JSR $C100       ; turn LED on
EE20: A5 7F     LDA $7F         ; drive number
EE22: 0A        ASL             ; times 2
EE23: AA        TAX
EE24: AC 7B 02  LDY $027B       ; comma position
EE27: CC 74 02  CPY $0274       ; compare with end name
EE2A: F0 1A     BEQ $EE46       ; format without ID
EE2C: B9 00 02  LDA $0200,Y     ; first character of ID
EE2F: 95 12     STA $12,X       ; save
EE31: B9 01 02  LDA $0201,Y     ; second character
EE34: 95 13     STA $13,X
EE36: 20 07 D3  JSR $D307       ; close all channels
EE39: A9 01     LDA #$01
EE3B: 85 80     STA $80         ; track 1
EE3D: 20 C6 C8  JSR $C8C6       ; format disk
EE40: 20 05 F0  JSR $F005       ; erase buffer
EE43: 4C 56 EE  JMP $EE56       ; continue as below

Jump from $EE2A:

EE46: 20 42 D0  JSR $D042       ; load BAM
EE49: A6 7F     LDX $7F         ; drive number
EE4B: BD 01 01  LDA $0101,X
EE4E: CD D5 FE  CMP $FED5       ; 'A', marker for 1541 format
EE51: F0 03     BEQ $EE56       ; ok
EE53: 4C 72 D5  JMP $D572       ; 73, 'cbm dos v2.6 1541'

Jump from $EE43, $EE51:

EE56: 20 B7 EE  JSR $EEB7       ; create BAM
EE59: A5 F9     LDA $F9         ; buffer number
EE5B: A8        TAY
EE5C: 0A        ASL
EE5D: AA        TAX
EE5E: AD 88 FE  LDA $FE88       ; $90, start of disk name
EE61: 95 99     STA $99,X       ; buffer pointer to name
EE63: AE 7A 02  LDX $027A
EE66: A9 1B     LDA #$1B        ; 27
EE68: 20 6E C6  JSR $C66E       ; write filenames in buffer
EE6B: A0 12     LDY #$12        ; position 18
EE6D: A6 7F     LDX $7F         ; drive number
EE6F: AD D5 FE  LDA $FED5       ; 'A', 1541 format
EE72: 9D 01 01  STA $0101,X
EE75: 8A        TXA
EE76: 0A        ASL             ; times 2
EE77: AA        TAX
EE78: B5 12     LDA $12,X       ; ID, first character
EE7A: 91 94     STA ($94),Y     ; in buffer
EE7C: C8        INY
EE7D: B5 13     LDA $13,X       ; and second character
EE7F: 91 94     STA ($94),Y     ; in buffer
EE81: C8        INY
EE82: C8        INY
EE83: A9 32     LDA #$32        ; '2'
EE85: 91 94     STA ($94),Y     ; in buffer
EE87: C8        INY
EE88: AD D5 FE  LDA $FED5       ; 'A' 1541 format
EE8B: 91 94     STA ($94),Y     ; in buffer
EE8D: A0 02     LDY #$02
EE8F: 91 6D     STA ($6D),Y     ; and at position 2
EE91: AD 85 FE  LDA $FE85       ; 18
EE94: 85 80     STA $80         ; track number
EE96: 20 93 EF  JSR $EF93       ; mark block as allocated
EE99: A9 01     LDA #$01        ; 1
EE9B: 85 81     STA $81         ; sector number
EE9D: 20 93 EF  JSR $EF93       ; mark block as allocated
EEA0: 20 FF EE  JSR $EEFF       ; write BAM
EEA3: 20 05 F0  JSR $F005       ; pointer $6D/$6E to buffer, erase buffer
EEA6: A0 01     LDY #$01
EEA8: A9 FF     LDA #$FF
EEAA: 91 6D     STA ($6D),Y     ; track following is zero
EEAC: 20 64 D4  JSR $D464       ; write BAM
EEAF: C6 81     DEC $81         ; decrement sector number, 0
EEB1: 20 60 D4  JSR $D460       ; read block
EEB4: 4C 94 C1  JMP $C194       ; prepare disk status



 $EEB7/61111:   Create BAM

Jump from $ED8F, $EE56:

EEB7: 20 D1 F0  JSR $F0D1
EEBA: A0 00     LDY #$00
EEBC: A9 12     LDA #$12        ; 18
EEBE: 91 6D     STA ($6D),Y     ; pointer to directory track
EEC0: C8        INY
EEC1: 98        TYA             ; 1
EEC2: 91 6D     STA ($6D),Y     ; pointer to directory sector
EEC4: C8        INY
EEC5: C8        INY
EEC6: C8        INY

Jump from $EEEF:

EEC7: A9 00     LDA #$00
EEC9: 85 6F     STA $6F
EECB: 85 70     STA $70         ; 3 bytes = 24 bits for sectors
EECD: 85 71     STA $71
EECF: 98        TYA             ; byte position
EED0: 4A        LSR
EED1: 4A        LSR             ; divided by 4 = track number
EED2: 20 4B F2  JSR $F24B       ; get number of sectors
EED5: 91 6D     STA ($6D),Y     ; and in BAM
EED7: C8        INY
EED8: AA        TAX

Jump from $EEE1:

EED9: 38        SEC
EEDA: 26 6F     ROL $6F
EEDC: 26 70     ROL $70         ; create bit model
EEDE: 26 71     ROL $71
EEE0: CA        DEX
EEE1: D0 F6     BNE $EED9

Jump from $EEEB:

EEE3: B5 6F     LDA $6F,X       ; 3 bytes
EEE5: 91 6D     STA ($6D),Y     ; the BAM in buffer
EEE7: C8        INY
EEE8: E8        INX
EEE9: E0 03     CPX #$03
EEEB: 90 F6     BCC $EEE3
EEED: C0 90     CPY #$90        ; position 144?
EEEF: 90 D6     BCC $EEC7       ; no, next track
EEF1: 4C 75 D0  JMP $D075       ; calculate number of free blocks



 $EEF4/61172:   Write BAM if needed

Jump from $C8A7, $DB26, $DD87, $E433:

EEF4: 20 93 DF  JSR $DF93       ; get buffer number
EEF7: AA        TAX
EEF8: BD 5B 02  LDA $025B,X     ; command for disk controller
EEFB: 29 01     AND #$01
EEFD: 85 7F     STA $7F         ; isolate drive number

Jump from $EDAD, $EEA0:

EEFF: A4 7F     LDY $7F
EF01: B9 51 02  LDA $0251,Y     ; BAM-changed flag set?
EF04: D0 01     BNE $EF07       ; yes
EF06: 60        RTS

Jump from $EF04:

EF07: A9 00     LDA #$00
EF09: 99 51 02  STA $0251,Y     ; reset BAM-changed flag
EF0C: 20 3A EF  JSR $EF3A       ; set buffer pointer for BAM
EF0F: A5 7F     LDA $7F         ; drive number
EF11: 0A        ASL             ; times 2
EF12: 48        PHA
EF13: 20 A5 F0  JSR $F0A5       ; verify BAM entry
EF16: 68        PLA
EF17: 18        CLC
EF18: 69 01     ADC #$01        ; inrement track number
EF1A: 20 A5 F0  JSR $F0A5       ; verify BAM entry
EF1D: A5 80     LDA $80         ; track
EF1F: 48        PHA
EF20: A9 01     LDA #$01        ; track 1
EF22: 85 80     STA $80

Jump from $EF32:

EF24: 0A        ASL             ; times 4
EF25: 0A        ASL
EF26: 85 6D     STA $6D
EF28: 20 20 F2  JSR $F220       ; verify BAM
EF2B: E6 80     INC $80         ; increment track number
EF2D: A5 80     LDA $80
EF2F: CD D7 FE  CMP $FED7       ; and compare with max val + 1 = 36
EF32: 90 F0     BCC $EF24       ; ok, next track
EF34: 68        PLA
EF35: 85 80     STA $80         ; get track number back
EF37: 4C 8A D5  JMP $D58A       ; write BAM to disk



 $EF3A/61242:   Set buffer pointer for BAM

Jump from $D075, $EF0C, $F005:

EF3A: 20 0F F1  JSR $F10F       ; get 6 for drive 0
EF3D: AA        TAX
EF3E: 20 DF F0  JSR $F0DF       ; allocate buffer
EF41: A6 F9     LDX $F9         ; buffer number
EF43: BD E0 FE  LDA $FEE0,X     ; buffer address, hi byte
EF46: 85 6E     STA $6E
EF48: A9 00     LDA #$00        ; lo byte
EF4A: 85 6D     STA $6D         ; pointer to $6D/$6E
EF4C: 60        RTS



 $EF4D/61261:   Get number of free blocks for dir

Jump from $C814, $E33B:

EF4D: A6 7F     LDX $7F         ; drive number
EF4F: BD FA 02  LDA $02FA,X     ; number of blocks, lo
EF52: 8D 72 02  STA $0272
EF55: BD FC 02  LDA $02FC,X     ; number of blocks, hi
EF58: 8D 73 02  STA $0273       ; in buffer for directory
EF5B: 60        RTS



 $EF5C/61276:   Mark block as free

EF5C: 20 F1 EF  JSR $EFF1       ; set buffer pointer

Jump from $C87D, $C8AD, $CCF8:

EF5F: 20 CF EF  JSR $EFCF       ; erase bit for sector in BAM
EF62: 38        SEC
EF63: D0 22     BNE $EF87       ; block already free, then done
EF65: B1 6D     LDA ($6D),Y     ; bit model of BAM
EF67: 1D E9 EF  ORA $EFE9,X     ; set bit X, marker for free
EF6A: 91 6D     STA ($6D),Y
EF6C: 20 88 EF  JSR $EF88       ; set flag for BAM changed
EF6F: A4 6F     LDY $6F
EF71: 18        CLC
EF72: B1 6D     LDA ($6D),Y
EF74: 69 01     ADC #$01        ; increment number of free blocks/track
EF76: 91 6D     STA ($6D),Y
EF78: A5 80     LDA $80         ; track
EF7A: CD 85 FE  CMP $FE85       ; equal to 18?
EF7D: F0 3B     BEQ $EFBA       ; then skip
EF7F: FE FA 02  INC $02FA,X     ; increment number of free blocks in disk
EF82: D0 03     BNE $EF87
EF84: FE FC 02  INC $02FC,X     ; increment number of blocks hi

Jump from $EF63, $EF82:

EF87: 60        RTS



 $EF88/61320:   Set flag for BAM changed

Jump from $EF6C, $EF9F:

EF88: A6 7F     LDX $7F         ; drive number
EF8A: A9 01     LDA #$01
EF8C: 9D 51 02  STA $0251,X     ; flag = 1
EF8F: 60        RTS



 $EF90/61328:   Mark block as allocated

Jump from $CD13, $EDE8, $EE04, $F19A, $F1F2:

EF90: 20 F1 EF  JSR $EFF1       ; set buffer pointer

Jump from $EE96, $EE9D:

EF93: 20 CF EF  JSR $EFCF       ; erase bit for sector in BAM
EF96: F0 36     BEQ $EFCE       ; already allocated, then done
EF98: B1 6D     LDA ($6D),Y
EF9A: 5D E9 EF  EOR $EFE9,X     ; erase bit for block
EF9D: 91 6D     STA ($6D),Y
EF9F: 20 88 EF  JSR $EF88       ; set flag for BAM changed
EFA2: A4 6F     LDY $6F
EFA4: B1 6D     LDA ($6D),Y
EFA6: 38        SEC
EFA7: E9 01     SBC #$01        ; decrement number of blocks per track
EFA9: 91 6D     STA ($6D),Y
EFAB: A5 80     LDA $80         ; track
EFAD: CD 85 FE  CMP $FE85       ; 18?
EFB0: F0 0B     BEQ $EFBD
EFB2: BD FA 02  LDA $02FA,X     ; number of free blocks lo
EFB5: D0 03     BNE $EFBA
EFB7: DE FC 02  DEC $02FC,X     ; decrement number of free blocks

Jump from $EFB5, $EF7D:

EFBA: DE FA 02  DEC $02FA,X

Jump from $EFB0:

EFBD: BD FC 02  LDA $02FC,X     ; number of free blocks hi
EFC0: D0 0C     BNE $EFCE       ; more than 255 blocks free?
EFC2: BD FA 02  LDA $02FA,X     ; free blocks lo
EFC5: C9 03     CMP #$03
EFC7: B0 05     BCS $EFCE       ; smaller than 3?
EFC9: A9 72     LDA #$72
EFCB: 20 C7 E6  JSR $E6C7       ; 72, 'disk full'

Jump from $EF96, $EFC0, $EFC7:

EFCE: 60        RTS



 $EFCF/61391:   Erase bit for sector in BAM entry

Jump from $EF5F, $EF93:

EFCF: 20 11 F0  JSR $F011       ; find BAM field for this track
EFD2: 98        TYA
EFD3: 85 6F     STA $6F

Jump from $F214:

EFD5: A5 81     LDA $81         ; sector
EFD7: 4A        LSR
EFD8: 4A        LSR             ; divide by 8
EFD9: 4A        LSR
EFDA: 38        SEC
EFDB: 65 6F     ADC $6F
EFDD: A8        TAY             ; byte number in BAM entry
EFDE: A5 81     LDA $81         ; sector number
EFE0: 29 07     AND #$07
EFE2: AA        TAX             ; bit number in BAM entry
EFE3: B1 6D     LDA ($6D),Y     ; byte in BAM
EFE5: 3D E9 EF  AND $EFE9,X     ; erase bit for corresponding sector
EFE8: 60        RTS



 $EFE9/61417:   Powers of 2

EFE9: 01 02 04 08 10 20 40 80



 $EFF1/61425:   Write BAM after change

Jump from $EF5C, $EF90:

EFF1: A9 FF     LDA #$FF
EFF3: 2C F9 02  BIT $02F9
EFF6: F0 0C     BEQ $F004
EFF8: 10 0A     BPL $F004
EFFA: 70 08     BVS $F004
EFFC: A9 00     LDA #$00
EFFE: 8D F9 02  STA $02F9       ; reset flag
F001: 4C 8A D5  JMP $D58A       ; write block

Jump from $EFF6, $EFF8, $EFFA:

F004: 60        RTS



 $F005/61445:   Erase BAM buffer

Jump from $EE40, $EEA3:

F005: 20 3A EF  JSR $EF3A       ; pointer $6D/$6E to BAM buffer
F008: A0 00     LDY #$00
F00A: 98        TYA

Jump from $F00E:

F00B: 91 6D     STA ($6D),Y     ; erase BAM buffer
F00D: C8        INY
F00E: D0 FB     BNE $F00B
F010: 60        RTS



 $F011/61457:   ?

Jump from $EFCF, $F130, $F1C4, $F1DF, $F1FA:

F011: A5 6F     LDA $6F
F013: 48        PHA
F014: A5 70     LDA $70
F016: 48        PHA
F017: A6 7F     LDX $7F         ; drive number
F019: B5 FF     LDA $FF,X
F01B: F0 05     BEQ $F022       ; drive zero?
F01D: A9 74     LDA #$74
F01F: 20 48 E6  JSR $E648       ; 'drive not ready'

Jump from $F01B:

F022: 20 0F F1  JSR $F10F       ; get buffer number for BAM
F025: 85 6F     STA $6F
F027: 8A        TXA
F028: 0A        ASL
F029: 85 70     STA $70
F02B: AA        TAX
F02C: A5 80     LDA $80         ; track
F02E: DD 9D 02  CMP $029D,X
F031: F0 0B     BEQ $F03E
F033: E8        INX
F034: 86 70     STX $70
F036: DD 9D 02  CMP $029D,X
F039: F0 03     BEQ $F03E
F03B: 20 5B F0  JSR $F05B

Jump from $F031, $F039:

F03E: A5 70     LDA $70
F040: A6 7F     LDX $7F         ; drive number
F042: 9D 9B 02  STA $029B,X
F045: 0A        ASL
F046: 0A        ASL             ; times 4
F047: 18        CLC
F048: 69 A1     ADC #$A1
F04A: 85 6D     STA $6D
F04C: A9 02     LDA #$02
F04E: 69 00     ADC #$00
F050: 85 6E     STA $6E
F052: A0 00     LDY #$00
F054: 68        PLA
F055: 85 70     STA $70
F057: 68        PLA
F058: 85 6F     STA $6F
F05A: 60        RTS



 $F05B/61531:   ?

Jump from $F03B:

F05B: A6 6F     LDX $6F
F05D: 20 DF F0  JSR $F0DF
F060: A5 7F     LDA $7F         ; drive number
F062: AA        TAX
F063: 0A        ASL
F064: 1D 9B 02  ORA $029B,X
F067: 49 01     EOR #$01
F069: 29 03     AND #$03
F06B: 85 70     STA $70
F06D: 20 A5 F0  JSR $F0A5
F070: A5 F9     LDA $F9         ; buffer number
F072: 0A        ASL
F073: AA        TAX
F074: A5 80     LDA $80         ; track
F076: 0A        ASL
F077: 0A        ASL             ; times 4
F078: 95 99     STA $99,X       ; equal pointer in BAM field
F07A: A5 70     LDA $70
F07C: 0A        ASL
F07D: 0A        ASL
F07E: A8        TAY

Jump from $F08E:

F07F: A1 99     LDA ($99,X)
F081: 99 A1 02  STA $02A1,Y
F084: A9 00     LDA #$00
F086: 81 99     STA ($99,X)     ; zero in buffer
F088: F6 99     INC $99,X       ; increment buffer pointer
F08A: C8        INY
F08B: 98        TYA
F08C: 29 03     AND #$03
F08E: D0 EF     BNE $F07F
F090: A6 70     LDX $70
F092: A5 80     LDA $80         ; track
F094: 9D 9D 02  STA $029D,X
F097: AD F9 02  LDA $02F9
F09A: D0 03     BNE $F09F
F09C: 4C 8A D5  JMP $D58A       ; write block

Jump from $F09A:

F09F: 09 80     ORA #$80
F0A1: 8D F9 02  STA $02F9
F0A4: 60        RTS

Jump from $F06D, $EF13, $EF1A:

F0A5: A8        TAY
F0A6: B9 9D 02  LDA $029D,Y
F0A9: F0 25     BEQ $F0D0
F0AB: 48        PHA
F0AC: A9 00     LDA #$00
F0AE: 99 9D 02  STA $029D,Y
F0B1: A5 F9     LDA $F9         ; buffer number
F0B3: 0A        ASL             ; times 2
F0B4: AA        TAX
F0B5: 68        PLA
F0B6: 0A        ASL
F0B7: 0A        ASL
F0B8: 95 99     STA $99,X
F0BA: 98        TYA
F0BB: 0A        ASL
F0BC: 0A        ASL
F0BD: A8        TAY

Jump from $F0CE:

F0BE: B9 A1 02  LDA $02A1,Y
F0C1: 81 99     STA ($99,X)     ; write in buffer
F0C3: A9 00     LDA #$00
F0C5: 99 A1 02  STA $02A1,Y
F0C8: F6 99     INC $99,X       ; increment buffer pointer
F0CA: C8        INY
F0CB: 98        TYA
F0CC: 29 03     AND #$03
F0CE: D0 EE     BNE $F0BE

Jump from $F0A9:

F0D0: 60        RTS



 $F0D1/61649:   ?

Jump from $C8F5, $D042, $EEB7:

F0D1: A5 7F     LDA $7F         ; drive number
F0D3: 0A        ASL
F0D4: AA        TAX
F0D5: A9 00     LDA #$00
F0D7: 9D 9D 02  STA $029D,X
F0DA: E8        INX
F0DB: 9D 9D 02  STA $029D,X
F0DE: 60        RTS



 $F0DF/61663:   ?

Jump from $C7BA, $EF3E, $F05D:

F0DF: B5 A7     LDA $A7,X
F0E1: C9 FF     CMP #$FF
F0E3: D0 25     BNE $F10A
F0E5: 8A        TXA
F0E6: 48        PHA
F0E7: 20 8E D2  JSR $D28E
F0EA: AA        TAX
F0EB: 10 05     BPL $F0F2
F0ED: A9 70     LDA #$70
F0EF: 20 C8 C1  JSR $C1C8       ; 70, 'no channel'

Jump from $F0EB:

F0F2: 86 F9     STX $F9
F0F4: 68        PLA
F0F5: A8        TAY
F0F6: 8A        TXA
F0F7: 09 80     ORA #$80
F0F9: 99 A7 00  STA $A7,Y
F0FC: 0A        ASL
F0FD: AA        TAX
F0FE: AD 85 FE  LDA $FE85       ; 18, directory track
F101: 95 06     STA $06,X       ; save
F103: A9 00     LDA #$00        ; 0
F105: 95 07     STA $07,X       ; as sector
F107: 4C 86 D5  JMP $D586       ; write block

Jump from $F0E3:

F10A: 29 0F     AND #$0F
F10C: 85 F9     STA $F9         ; buffer number
F10E: 60        RTS



 $F10F/61711:   Get buffer number for BAM

Jump from $D00E, $EF3A, $F022, $F119:

F10F: A9 06     LDA #$06
F111: A6 7F     LDX $7F         ; drive number
F113: D0 03     BNE $F118
F115: 18        CLC
F116: 69 07     ADC #$07        ; gives 13 for drive 0

Jump from $F113:

F118: 60        RTS



 $F119/61721:   Buffer number for BAM

Jump from $C7B7, $C883, $C8F8:

F119: 20 0F F1  JSR $F10F       ; get buffer number
F11C: AA        TAX
F11D: 60        RTS



 $F11E/61726:   Find and allocate free block

Jump from $D1A6, $DD1D, $E3A9, $E3BC, $E44E:

F11E: 20 3E DE  JSR $DE3E       ; get track and sector number
F121: A9 03     LDA #$03
F123: 85 6F     STA $6F         ; counter
F125: A9 01     LDA #$01
F127: 0D F9 02  ORA $02F9
F12A: 8D F9 02  STA $02F9

Jump from $F14A, $F158, $F161, $F16F, $D49B:

F12D: A5 6F     LDA $6F         ; save counter
F12F: 48        PHA
F130: 20 11 F0  JSR $F011       ; find BAM field for this track
F133: 68        PLA
F134: 85 6F     STA $6F         ; get counter back
F136: B1 6D     LDA ($6D),Y     ; number of free blocks in track
F138: D0 39     BNE $F173       ; blocks still free?
F13A: A5 80     LDA $80         ; track
F13C: CD 85 FE  CMP $FE85       ; 18, directory track?
F13F: F0 19     BEQ $F15A       ; yes, 'disk full'
F141: 90 1C     BCC $F15F       ; smaller, then next lower track
F143: E6 80     INC $80         ; increment track number
F145: A5 80     LDA $80
F147: CD D7 FE  CMP $FED7       ; 36, highest track number plus one
F14A: D0 E1     BNE $F12D       ; no, continue searching this track
F14C: AE 85 FE  LDX $FE85       ; 18, directory track
F14F: CA        DEX             ; decrement
F150: 86 80     STX $80         ; save as track number
F152: A9 00     LDA #$00
F154: 85 81     STA $81         ; begin with sector number zero
F156: C6 6F     DEC $6F         ; decrement counter
F158: D0 D3     BNE $F12D       ; not yet zero, then continue

Jump from $F13F, $F171:

F15A: A9 72     LDA #$72
F15C: 20 C8 C1  JSR $C1C8       ; 72, 'disk full'

Jump from $F141:

F15F: C6 80     DEC $80         ; decrement track number
F161: D0 CA     BNE $F12D       ; not yet 0, continue in this track
F163: AE 85 FE  LDX $FE85       ; 18, directory track
F166: E8        INX             ; increment
F167: 86 80     STX $80         ; save as track number
F169: A9 00     LDA #$00
F16B: 85 81     STA $81         ; begin with sector zero
F16D: C6 6F     DEC $6F         ; decrement counter
F16F: D0 BC     BNE $F12D       ; not yet zero, then continue
F171: F0 E7     BEQ $F15A       ; else 'disk full'

Jump from $F138:

F173: A5 81     LDA $81         ; sector number
F175: 18        CLC
F176: 65 69     ADC $69         ; plus step width (10)
F178: 85 81     STA $81         ; as new number
F17A: A5 80     LDA $80         ; track number
F17C: 20 4B F2  JSR $F24B       ; get maximum sector number
F17F: 8D 4E 02  STA $024E
F182: 8D 4D 02  STA $024D       ; and save
F185: C5 81     CMP $81         ; greater than selected sector number?
F187: B0 0C     BCS $F195       ; yes
F189: 38        SEC             ; else
F18A: A5 81     LDA $81         ; sector number
F18C: ED 4E 02  SBC $024E       ; minus maximum sector number
F18F: 85 81     STA $81         ; save as new sector number
F191: F0 02     BEQ $F195       ; zero?
F193: C6 81     DEC $81         ; else decrement sector number by one

Jump from $F187, $F191:

F195: 20 FA F1  JSR $F1FA       ; check BAM, find free sector
F198: F0 03     BEQ $F19D       ; not found?

Jump from $F1A4:

F19A: 4C 90 EF  JMP $EF90       ; allocate block in BAM

Jump from $F198:

F19D: A9 00     LDA #$00
F19F: 85 81     STA $81         ; sector zero
F1A1: 20 FA F1  JSR $F1FA       ; find free sector
F1A4: D0 F4     BNE $F19A       ; found?
F1A6: 4C F5 F1  JMP $F1F5       ; no, 'dir sector'



 $F1A9/61865:   Find free sector and allocate

Jump from $DCDA:

F1A9: A9 01     LDA #$01
F1AB: 0D F9 02  ORA $02F9
F1AE: 8D F9 02  STA $02F9
F1B1: A5 86     LDA $86
F1B3: 48        PHA
F1B4: A9 01     LDA #$01        ; track counter
F1B6: 85 86     STA $86

Jump from $F1E4:

F1B8: AD 85 FE  LDA $FE85       ; 18, directory track
F1BB: 38        SEC
F1BC: E5 86     SBC $86         ; minus counter
F1BE: 85 80     STA $80         ; save as track number
F1C0: 90 09     BCC $F1CB       ; result <= zero?
F1C2: F0 07     BEQ $F1CB       ; then try top half of directory
F1C4: 20 11 F0  JSR $F011       ; find BAM field for this track
F1C7: B1 6D     LDA ($6D),Y     ; number of free blocks in this track
F1C9: D0 1B     BNE $F1E6       ; free blocks exist

Jump from $F1C0, $F1C2:

F1CB: AD 85 FE  LDA $FE85       ; 18, directory track
F1CE: 18        CLC
F1CF: 65 86     ADC $86         ; plus counter
F1D1: 85 80     STA $80         ; save as track number
F1D3: E6 86     INC $86         ; increment counter
F1D5: CD D7 FE  CMP $FED7       ; 36, max track number plus one
F1D8: 90 05     BCC $F1DF       ; smaller, then ok
F1DA: A9 67     LDA #$67
F1DC: 20 45 E6  JSR $E645       ; 67, 'illegal track or sector'

Jump from $F1D8:

F1DF: 20 11 F0  JSR $F011       ; find BAM field for this track
F1E2: B1 6D     LDA ($6D),Y     ; number of free blocks?
F1E4: F0 D2     BEQ $F1B8       ; no more free blocks?

Jump from $F1C9:

F1E6: 68        PLA
F1E7: 85 86     STA $86
F1E9: A9 00     LDA #$00
F1EB: 85 81     STA $81         ; sector 0
F1ED: 20 FA F1  JSR $F1FA       ; find free sector
F1F0: F0 03     BEQ $F1F5       ; not found?
F1F2: 4C 90 EF  JMP $EF90       ; allocate block in BAM

Jump from $F1F0, $F1A6:

F1F5: A9 71     LDA #$71
F1F7: 20 45 E6  JSR $E645       ; 71, 'dir error'



 $F1FA/61946:   Find free sectors in current track

Jump from $CD09, $CD27, $F195, $F1A1, $F1ED:

F1FA: 20 11 F0  JSR $F011       ; find BAM field for this track
F1FD: 98        TYA             ; point to number of free blocks
F1FE: 48        PHA
F1FF: 20 20 F2  JSR $F220       ; verify BAM
F202: A5 80     LDA $80         ; track
F204: 20 4B F2  JSR $F24B       ; get max number of sectors of the track
F207: 8D 4E 02  STA $024E       ; save
F20A: 68        PLA
F20B: 85 6F     STA $6F         ; save pointer

Jump from $F21B:

F20D: A5 81     LDA $81         ; compare sector
F20F: CD 4E 02  CMP $024E       ; with maximum number
F212: B0 09     BCS $F21D       ; greater than or equal to?
F214: 20 D5 EF  JSR $EFD5       ; get bit number of sector
F217: D0 06     BNE $F21F       ; sector free?
F219: E6 81     INC $81         ; increment sector number
F21B: D0 F0     BNE $F20D       ; and check if free

Jump from $F212:

F21D: A9 00     LDA #$00        ; no sectors free

Jump from $F217:

F21F: 60        RTS



 $F220/61984:   Verify number of free blocks in BAM

Jump from $EF28, $F1FF:

F220: A5 6F     LDA $6F
F222: 48        PHA
F223: A9 00     LDA #$00
F225: 85 6F     STA $6F         ; counter to zero
F227: AC 86 FE  LDY $FE86       ; 4, number of bytes per track in BAM
F22A: 88        DEY

Jump from $F23A:

F22B: A2 07     LDX #$07

Jump from $F237:

F22D: B1 6D     LDA ($6D),Y
F22F: 3D E9 EF  AND $EFE9,X     ; isolate bit
F232: F0 02     BEQ $F236
F234: E6 6F     INC $6F         ; increment counter of free sectors

Jump from $F232:

F236: CA        DEX
F237: 10 F4     BPL $F22D
F239: 88        DEY
F23A: D0 EF     BNE $F22B
F23C: B1 6D     LDA ($6D),Y     ; compare with number on diskette
F23E: C5 6F     CMP $6F
F240: D0 04     BNE $F246       ; not equal, then error
F242: 68        PLA
F243: 85 6F     STA $6F
F245: 60        RTS

Jump from $F240:

F246: A9 71     LDA #$71
F248: 20 45 E6  JSR $E645       ; 71, 'dir error'



 $F24B/62027:   Establish number of sectors per track

Jump from $D540, $D568, $EED2, $F17C, $F204:

F24B: AE D6 FE  LDX $FED6       ; 4 different values

Jump from $F252:

F24E: DD D6 FE  CMP $FED6,X     ; track number
F251: CA        DEX
F252: B0 FA     BCS $F24E       ; not greater?
F254: BD D1 FE  LDA $FED1,X     ; get number of sectors
F257: 60        RTS



 $F258/62040:   Dummy subroutine

Jump from $CB12, $CDA3, $E7A8:

F258: 60        RTS



 $F259/62041:   Initialise disk controller

Jump from $EBC2:

F259: A9 6F     LDA #$6F        ; bit 4 (write prot) & 7 (SYNC)
F25B: 8D 02 1C  STA $1C02       ; data direction register port B
F25E: 29 F0     AND #$F0
F260: 8D 00 1C  STA $1C00       ; port B, control port
F263: AD 0C 1C  LDA $1C0C       ; PCR, control register
F266: 29 FE     AND #$FE
F268: 09 0E     ORA #$0E
F26A: 09 E0     ORA #$E0
F26C: 8D 0C 1C  STA $1C0C
F26F: A9 41     LDA #$41
F271: 8D 0B 1C  STA $1C0B       ; timer 1 free running, enable
F274: A9 00     LDA #$00        ; port A latch
F276: 8D 06 1C  STA $1C06       ; timer 1 lo latch
F279: A9 3A     LDA #$3A
F27B: 8D 07 1C  STA $1C07       ; timer 1 hi latch
F27E: 8D 05 1C  STA $1C05       ; timer 1 hi
F281: A9 7F     LDA #$7F
F283: 8D 0E 1C  STA $1C0E       ; erase IRQs
F286: A9 C0     LDA #$C0
F288: 8D 0D 1C  STA $1C0D
F28B: 8D 0E 1C  STA $1C0E       ; IER, allow interrupts
F28E: A9 FF     LDA #$FF
F290: 85 3E     STA $3E
F292: 85 51     STA $51         ; track counter for formatting
F294: A9 08     LDA #$08        ; 8
F296: 85 39     STA $39         ; constants for block header
F298: A9 07     LDA #$07        ; 7
F29A: 85 47     STA $47         ; constants for data block
F29C: A9 05     LDA #$05
F29E: 85 62     STA $62
F2A0: A9 FA     LDA #$FA        ; pointer $62/$63 to $FA05
F2A2: 85 63     STA $63
F2A4: A9 C8     LDA #$C8        ; 200
F2A6: 85 64     STA $64
F2A8: A9 04     LDA #$04
F2AA: 85 5E     STA $5E
F2AC: A9 04     LDA #$04
F2AE: 85 5F     STA $5F



 $F2B0/62128:   IRQ routine for disk controller

Jump from $FE7C:

F2B0: BA        TSX
F2B1: 86 49     STX $49         ; save stack pointer
F2B3: AD 04 1C  LDA $1C04
F2B6: AD 0C 1C  LDA $1C0C       ; erase interrupt flag from timer
F2B9: 09 0E     ORA #$0E
F2BB: 8D 0C 1C  STA $1C0C

Jump from $F97B:

F2BE: A0 05     LDY #$05

Jump from $F2F4:

F2C0: B9 00 00  LDA $00,Y       ; command for buffer Y?
F2C3: 10 2E     BPL $F2F3       ; no
F2C5: C9 D0     CMP #$D0        ; execute code for program in buffer
F2C7: D0 04     BNE $F2CD       ; no
F2C9: 98        TYA
F2CA: 4C 70 F3  JMP $F370       ; execute program in buffer

Jump from $F2C7:

F2CD: 29 01     AND #$01        ; isolate drive number
F2CF: F0 07     BEQ $F2D8       ; drive zero?
F2D1: 84 3F     STY $3F
F2D3: A9 0F     LDA #$0F        ; else
F2D5: 4C 69 F9  JMP $F969       ; 74, 'drive not ready'

Jump from $F2CF:

F2D8: AA        TAX
F2D9: 85 3D     STA $3D
F2DB: C5 3E     CMP $3E         ; motor running?
F2DD: F0 0A     BEQ $F2E9       ; yes
F2DF: 20 7E F9  JSR $F97E       ; turn drive motor on
F2E2: A5 3D     LDA $3D
F2E4: 85 3E     STA $3E         ; set flag
F2E6: 4C 9C F9  JMP $F99C       ; to job loop

Jump from $F2DD:

F2E9: A5 20     LDA $20
F2EB: 30 03     BMI $F2F0       ; head transport programmed?
F2ED: 0A        ASL
F2EE: 10 09     BPL $F2F9

Jump from $F2EB:

F2F0: 4C 9C F9  JMP $F99C       ; to job loop

Jump from $F2C3:

F2F3: 88        DEY
F2F4: 10 CA     BPL $F2C0       ; check next buffer
F2F6: 4C 9C F9  JMP $F99C       ; to job loop



 $F2F9/62201:   Head transport

Jump from $F2EE:

F2F9: A9 20     LDA #$20
F2FB: 85 20     STA $20         ; program head transport
F2FD: A0 05     LDY #$05
F2FF: 84 3F     STY $3F         ; initialize buffer counter

Jump from $F308:

F301: 20 93 F3  JSR $F393       ; set pointer in buffer
F304: 30 1A     BMI $F320       ; command for buffer?

Jump from $F324, $F339:

F306: C6 3F     DEC $3F         ; decrement counter
F308: 10 F7     BPL $F301       ; check next buffer
F30A: A4 41     LDY $41         ; buffer number
F30C: 20 95 F3  JSR $F395       ; set pointer in buffer
F30F: A5 42     LDA $42         ; track difference for last job
F311: 85 4A     STA $4A         ; as counter for head transport
F313: 06 4A     ASL $4A
F315: A9 60     LDA #$60        ; set flag for head transport
F317: 85 20     STA $20
F319: B1 32     LDA ($32),Y     ; get track number from buffer
F31B: 85 22     STA $22
F31D: 4C 9C F9  JMP $F99C       ; to job loop

Jump from $F304:

F320: 29 01     AND #$01        ; isolate drive number
F322: C5 3D     CMP $3D         ; equal drive number of last job?
F324: D0 E0     BNE $F306       ; no
F326: A5 22     LDA $22         ; last track number
F328: F0 12     BEQ $F33C       ; equal zero?
F32A: 38        SEC
F32B: F1 32     SBC ($32),Y     ; equal track number of this job?
F32D: F0 0D     BEQ $F33C       ; yes
F32F: 49 FF     EOR #$FF
F331: 85 42     STA $42
F333: E6 42     INC $42
F335: A5 3F     LDA $3F         ; drive number
F337: 85 41     STA $41
F339: 4C 06 F3  JMP $F306

Jump from $F328, $F32D:

F33C: A2 04     LDX #$04
F33E: B1 32     LDA ($32),Y     ; track number of the job
F340: 85 40     STA $40         ; save

Jump from $F346:

F342: DD D6 FE  CMP $FED6,X     ; compare with maximum track number
F345: CA        DEX
F346: B0 FA     BCS $F342       ; greater?
F348: BD D1 FE  LDA $FED1,X     ; get number of sectors per track
F34B: 85 43     STA $43         ; and save
F34D: 8A        TXA
F34E: 0A        ASL
F34F: 0A        ASL
F350: 0A        ASL
F351: 0A        ASL
F352: 0A        ASL
F353: 85 44     STA $44         ; gives 0, 32, 64, 96
F355: AD 00 1C  LDA $1C00
F358: 29 9F     AND #$9F
F35A: 05 44     ORA $44         ; generate control byte for motor
F35C: 8D 00 1C  STA $1C00
F35F: A6 3D     LDX $3D
F361: A5 45     LDA $45         ; command code
F363: C9 40     CMP #$40        ; position head?
F365: F0 15     BEQ $F37C       ; yes
F367: C9 60     CMP #$60        ; command code for program execution?
F369: F0 03     BEQ $F36E       ; yes
F36B: 4C B1 F3  JMP $F3B1       ; read block header



 $F36E/62318:   Execute program in buffer

Jump from $F369:

F36E: A5 3F     LDA $3F         ; buffer number

Jump from $F2CA:

F370: 18        CLC
F371: 69 03     ADC #$03        ; plus 3
F373: 85 31     STA $31
F375: A9 00     LDA #$00        ; equals address of buffer
F377: 85 30     STA $30
F379: 6C 30 00  JMP ($0030)     ; execute program in buffer



 $F37C/62332:   Bump, find track 1 (head at stop)

Jump from $F365:

F37C: A9 60     LDA #$60
F37E: 85 20     STA $20         ; set flag for head transport
F380: AD 00 1C  LDA $1C00
F383: 29 FC     AND #$FC        ; turn stepper motors on
F385: 8D 00 1C  STA $1C00
F388: A9 A4     LDA #$A4        ; 164
F38A: 85 4A     STA $4A         ; step counter for head transport
F38C: A9 01     LDA #$01
F38E: 85 22     STA $22         ; track number
F390: 4C 69 F9  JMP $F969       ; ok



 $F393/62355:   Initialise pointer in buffer

Jump from $F301, $F43A, $F48F:

F393: A4 3F     LDY $3F         ; buffer number

Jump from $F30C:

F395: B9 00 00  LDA $00,Y       ; command code
F398: 48        PHA             ; save
F399: 10 10     BPL $F3AB
F39B: 29 78     AND #$78        ; erase bits 0,1,2, and 7
F39D: 85 45     STA $45
F39F: 98        TYA             ; buffer number
F3A0: 0A        ASL             ; times two
F3A1: 69 06     ADC #$06        ; plus 6
F3A3: 85 32     STA $32         ; equals pointer to actual buffer
F3A5: 98        TYA             ; buffer number
F3A6: 18        CLC
F3A7: 69 03     ADC #$03        ; plus 3
F3A9: 85 31     STA $31         ; equals buffer address hi

Jump from $F399:

F3AB: A0 00     LDY #$00
F3AD: 84 30     STY $30         ; buffer address lo
F3AF: 68        PLA             ; get command code back
F3B0: 60        RTS



 $F3B1/62385:   Read block header, verify ID

Jump from $F36B, $F5E6:

F3B1: A2 5A     LDX #$5A        ; 90
F3B3: 86 4B     STX $4B         ; counter
F3B5: A2 00     LDX #$00
F3B7: A9 52     LDA #$52        ; 82
F3B9: 85 24     STA $24

Jump from $F409:

F3BB: 20 56 F5  JSR $F556       ; wait for SYNC

Jump from $F3BE:

F3BE: 50 FE     BVC $F3BE       ; byte ready?
F3C0: B8        CLV
F3C1: AD 01 1C  LDA $1C01       ; data from read head
F3C4: C5 24     CMP $24
F3C6: D0 3F     BNE $F407       ; 20, 'read error'

Jump from $F3C8, $F3D3:

F3C8: 50 FE     BVC $F3C8       ; byte ready?
F3CA: B8        CLV
F3CB: AD 01 1C  LDA $1C01       ; data byte from disk (block header)
F3CE: 95 25     STA $25,X       ; save 7 bytes
F3D0: E8        INX
F3D1: E0 07     CPX #$07
F3D3: D0 F3     BNE $F3C8       ; continue reading
F3D5: 20 97 F4  JSR $F497
F3D8: A0 04     LDY #$04        ; 4 bytes plus parity
F3DA: A9 00     LDA #$00

Jump from $F3E0:

F3DC: 59 16 00  EOR $16,Y       ; form checksum for header
F3DF: 88        DEY
F3E0: 10 FA     BPL $F3DC
F3E2: C9 00     CMP #$00        ; parity ok?
F3E4: D0 38     BNE $F41E       ; 27, 'read error'
F3E6: A6 3E     LDX $3E         ; drive number
F3E8: A5 18     LDA $18         ; track number of header
F3EA: 95 22     STA $22,X       ; use as actual track number
F3EC: A5 45     LDA $45
F3EE: C9 30     CMP #$30        ; code for 'preserve header'
F3F0: F0 1E     BEQ $F410       ; preserve header
F3F2: A5 3E     LDA $3E
F3F4: 0A        ASL
F3F5: A8        TAY
F3F6: B9 12 00  LDA $12,Y
F3F9: C5 16     CMP $16         ; command with ID1
F3FB: D0 1E     BNE $F41B
F3FD: B9 13 00  LDA $13,Y
F400: C5 17     CMP $17         ; command with ID2
F402: D0 17     BNE $F41B       ; <>, then 29, 'disk id mismatch'
F404: 4C 23 F4  JMP $F423

Jump from $F3C6:

F407: C6 4B     DEC $4B         ; decrement counter for attempts
F409: D0 B0     BNE $F3BB       ; and try again
F40B: A9 02     LDA #$02        ; else
F40D: 20 69 F9  JSR $F969       ; 20, 'read error'



 $F410/62480:   Preserve block header

Jump from $F3F0:

F410: A5 16     LDA $16         ; ID1
F412: 85 12     STA $12
F414: A5 17     LDA $17         ; and ID2
F416: 85 13     STA $13         ; preserve



 $F418/62488:   Work Return value 01 (OK) into queue

Jump from $F6C2, $F6CD:

F418: A9 01     LDA #$01        ; ok
F41A: 2C        .BYTE $2C



 $F41B/62491:   Work Return value 0B (READ ERROR) into queue

Jump from $F3FB, $F402:

F41B: A9 0B     LDA #$0B        ; 29, 'disk id mismatch'
F41D: 2C        .BYTE $2C



 $F41E/62494:   Work Return value 09 (READ ERROR) into queue

Jump from $F3E4:

F41E: A9 09     LDA #$09        ; 27, 'write error'
F420: 4C 69 F9  JMP $F969       ; done



 $F423/62499:   Job optimisation

Jump from $F404:

F423: A9 7F     LDA #$7F
F425: 85 4C     STA $4C
F427: A5 19     LDA $19
F429: 18        CLC
F42A: 69 02     ADC #$02
F42C: C5 43     CMP $43
F42E: 90 02     BCC $F432
F430: E5 43     SBC $43

Jump from $F42E:

F432: 85 4D     STA $4D
F434: A2 05     LDX #$05
F436: 86 3F     STX $3F
F438: A2 FF     LDX #$FF

Jump from $F485:

F43A: 20 93 F3  JSR $F393       ; set buffer pointer for disk controller
F43D: 10 44     BPL $F483
F43F: 85 44     STA $44
F441: 29 01     AND #$01
F443: C5 3E     CMP $3E
F445: D0 3C     BNE $F483
F447: A0 00     LDY #$00
F449: B1 32     LDA ($32),Y
F44B: C5 40     CMP $40
F44D: D0 34     BNE $F483
F44F: A5 45     LDA $45         ; command code
F451: C9 60     CMP #$60
F453: F0 0C     BEQ $F461
F455: A0 01     LDY #$01
F457: 38        SEC
F458: B1 32     LDA ($32),Y
F45A: E5 4D     SBC $4D
F45C: 10 03     BPL $F461
F45E: 18        CLC
F45F: 65 43     ADC $43

Jump from $F453, $F45C:

F461: C5 4C     CMP $4C
F463: B0 1E     BCS $F483
F465: 48        PHA
F466: A5 45     LDA $45
F468: F0 14     BEQ $F47E
F46A: 68        PLA
F46B: C9 09     CMP #$09
F46D: 90 14     BCC $F483
F46F: C9 0C     CMP #$0C
F471: B0 10     BCS $F483

Jump from $F481:

F473: 85 4C     STA $4C
F475: A5 3F     LDA $3F
F477: AA        TAX
F478: 69 03     ADC #$03
F47A: 85 31     STA $31
F47C: D0 05     BNE $F483

Jump from $F468:

F47E: 68        PLA
F47F: C9 06     CMP #$06
F481: 90 F0     BCC $F473

Jump from $F43D, $F445, $F44D, $F463, $F46D, $F471, $F47C:

F483: C6 3F     DEC $3F
F485: 10 B3     BPL $F43A
F487: 8A        TXA
F488: 10 03     BPL $F48D
F48A: 4C 9C F9  JMP $F99C       ; to job loop

Jump from $F488:

F48D: 86 3F     STX $3F
F48F: 20 93 F3  JSR $F393       ; get buffer number
F492: A5 45     LDA $45         ; command code
F494: 4C CA F4  JMP $F4CA       ; continue checking

Jump from $F3D5:

F497: A5 30     LDA $30
F499: 48        PHA             ; save pointer $30/$31
F49A: A5 31     LDA $31
F49C: 48        PHA
F49D: A9 24     LDA #$24
F49F: 85 30     STA $30
F4A1: A9 00     LDA #$00        ; pointer $30/$31 to $24
F4A3: 85 31     STA $31
F4A5: A9 00     LDA #$00
F4A7: 85 34     STA $34
F4A9: 20 E6 F7  JSR $F7E6
F4AC: A5 55     LDA $55
F4AE: 85 18     STA $18
F4B0: A5 54     LDA $54
F4B2: 85 19     STA $19
F4B4: A5 53     LDA $53
F4B6: 85 1A     STA $1A
F4B8: 20 E6 F7  JSR $F7E6
F4BB: A5 52     LDA $52
F4BD: 85 17     STA $17
F4BF: A5 53     LDA $53
F4C1: 85 16     STA $16
F4C3: 68        PLA
F4C4: 85 31     STA $31
F4C6: 68        PLA             ; get pointer $30/$31 back
F4C7: 85 30     STA $30
F4C9: 60        RTS



 $F4CA/62666:   Test command code further

Jump from $F494:

F4CA: C9 00     CMP #$00        ; command code for 'read'?
F4CC: F0 03     BEQ $F4D1       ; yes
F4CE: 4C 6E F5  JMP $F56E       ; continue checking command



 $F4D1/62673:   Read sector

Jump from $F4CC:

F4D1: 20 0A F5  JSR $F50A       ; find beginning of data block

Jump from $F4D4, $F4DD:

F4D4: 50 FE     BVC $F4D4       ; byte ready?
F4D6: B8        CLV
F4D7: AD 01 1C  LDA $1C01       ; get data byte
F4DA: 91 30     STA ($30),Y     ; and write in buffer
F4DC: C8        INY             ; 256 times
F4DD: D0 F5     BNE $F4D4
F4DF: A0 BA     LDY #$BA

Jump from $F4E1, $F4EB:

F4E1: 50 FE     BVC $F4E1       ; byte ready?
F4E3: B8        CLV
F4E4: AD 01 1C  LDA $1C01       ; read bytes
F4E7: 99 00 01  STA $0100,Y     ; from $1BA to $1FF
F4EA: C8        INY
F4EB: D0 F4     BNE $F4E1
F4ED: 20 E0 F8  JSR $F8E0
F4F0: A5 38     LDA $38
F4F2: C5 47     CMP $47         ; equal 7, beginning of data block?
F4F4: F0 05     BEQ $F4FB       ; yes
F4F6: A9 04     LDA #$04        ; 22, 'read error'
F4F8: 4C 69 F9  JMP $F969       ; error termination

Jump from $F4F4:

F4FB: 20 E9 F5  JSR $F5E9       ; calculate parity of data block
F4FE: C5 3A     CMP $3A         ; agreement?
F500: F0 03     BEQ $F505       ; yes
F502: A9 05     LDA #$05        ; 23, 'read error'
F504: 2C        .BYTE $2C

Jump from $F500:

F505: A9 01     LDA #$01        ; ok
F507: 4C 69 F9  JMP $F969       ; prepare error message



 $F50A/62730:   Find start of data block

Jump from $F4D1, $F6A0:

F50A: 20 10 F5  JSR $F510       ; read block header
F50D: 4C 56 F5  JMP $F556       ; wait for SYNC



 $F510/62736:   Read block header

Jump from $F50A, $F589, $F6CA:

F510: A5 3D     LDA $3D         ; drive number
F512: 0A        ASL
F513: AA        TAX
F514: B5 12     LDA $12,X       ; ID1
F516: 85 16     STA $16         ; save
F518: B5 13     LDA $13,X       ; ID2
F51A: 85 17     STA $17         ; save
F51C: A0 00     LDY #$00
F51E: B1 32     LDA ($32),Y     ; get track and
F520: 85 18     STA $18
F522: C8        INY
F523: B1 32     LDA ($32),Y     ; sector number from buffer
F525: 85 19     STA $19
F527: A9 00     LDA #$00
F529: 45 16     EOR $16
F52B: 45 17     EOR $17         ; calculate parity for block header
F52D: 45 18     EOR $18
F52F: 45 19     EOR $19
F531: 85 1A     STA $1A         ; and save
F533: 20 34 F9  JSR $F934
F536: A2 5A     LDX #$5A        ; 90 attempts

Jump from $F54F:

F538: 20 56 F5  JSR $F556       ; wait for SYNC
F53B: A0 00     LDY #$00

Jump from $F53D, $F54B:

F53D: 50 FE     BVC $F53D       ; byte ready?
F53F: B8        CLV
F540: AD 01 1C  LDA $1C01       ; read data from block header
F543: D9 24 00  CMP $24,Y       ; compare with saved data
F546: D0 06     BNE $F54E       ; not the same, try again
F548: C8        INY
F549: C0 08     CPY #$08        ; 8 bytes read?
F54B: D0 F0     BNE $F53D       ; no
F54D: 60        RTS

Jump from $F546:

F54E: CA        DEX             ; decrement counter
F54F: D0 E7     BNE $F538       ; not yet zero?
F551: A9 02     LDA #$02

Jump from $F560:

F553: 4C 69 F9  JMP $F969       ; 20, 'read error'



 $F556/62806:   Wait for SYNC

Jump from $F3BB, $F50D, $F538, $FB1D, $FD39, $FD62:

F556: A9 D0     LDA #$D0        ; 208
F558: 8D 05 18  STA $1805       ; start timer
F55B: A9 03     LDA #$03        ; error code

Jump from $F565:

F55D: 2C 05 18  BIT $1805
F560: 10 F1     BPL $F553       ; timer run down, then 'read error'
F562: 2C 00 1C  BIT $1C00       ; SYNC signal
F565: 30 F6     BMI $F55D       ; not yet found?
F567: AD 01 1C  LDA $1C01       ; read byte
F56A: B8        CLV
F56B: A0 00     LDY #$00
F56D: 60        RTS



 $F56E/62830:   Test command code further

Jump from $F4CE:

F56E: C9 10     CMP #$10        ; command code for 'write'
F570: F0 03     BEQ $F575       ; yes
F572: 4C 91 F6  JMP $F691       ; continue checking command code



 $F575/62837:   Write data block to disk

Jump from $F570:

F575: 20 E9 F5  JSR $F5E9       ; calculate parity for buffer
F578: 85 3A     STA $3A         ; and save
F57A: AD 00 1C  LDA $1C00       ; read port B
F57D: 29 10     AND #$10        ; isolate bit for 'write protect'
F57F: D0 05     BNE $F586       ; not set, ok
F581: A9 08     LDA #$08
F583: 4C 69 F9  JMP $F969       ; 26, 'write protect'

Jump from $F57F:

F586: 20 8F F7  JSR $F78F
F589: 20 10 F5  JSR $F510       ; find block header
F58C: A2 09     LDX #$09

Jump from $F58E, $F592:

F58E: 50 FE     BVC $F58E       ; byte ready?
F590: B8        CLV
F591: CA        DEX
F592: D0 FA     BNE $F58E
F594: A9 FF     LDA #$FF
F596: 8D 03 1C  STA $1C03       ; port A (read/write head) to output
F599: AD 0C 1C  LDA $1C0C
F59C: 29 1F     AND #$1F
F59E: 09 C0     ORA #$C0        ; change PCR to output
F5A0: 8D 0C 1C  STA $1C0C
F5A3: A9 FF     LDA #$FF
F5A5: A2 05     LDX #$05
F5A7: 8D 01 1C  STA $1C01       ; write $FF to disk 5 times
F5AA: B8        CLV

Jump from $F5AB, $F5AF:

F5AB: 50 FE     BVC $F5AB       ; as SYNC characters
F5AD: B8        CLV
F5AE: CA        DEX
F5AF: D0 FA     BNE $F5AB
F5B1: A0 BB     LDY #$BB

Jump from $F5BD:

F5B3: B9 00 01  LDA $0100,Y     ; bytes $1BB to $1FF to disk

Jump from $F5B6:

F5B6: 50 FE     BVC $F5B6
F5B8: B8        CLV
F5B9: 8D 01 1C  STA $1C01
F5BC: C8        INY
F5BD: D0 F4     BNE $F5B3

Jump from $F5C8:

F5BF: B1 30     LDA ($30),Y     ; write data buffer (256 bytes)

Jump from $F5C1:

F5C1: 50 FE     BVC $F5C1
F5C3: B8        CLV
F5C4: 8D 01 1C  STA $1C01
F5C7: C8        INY
F5C8: D0 F5     BNE $F5BF

Jump from $F5CA:

F5CA: 50 FE     BVC $F5CA       ; byte ready?
F5CC: AD 0C 1C  LDA $1C0C
F5CF: 09 E0     ORA #$E0        ; PCR to input again
F5D1: 8D 0C 1C  STA $1C0C
F5D4: A9 00     LDA #$00
F5D6: 8D 03 1C  STA $1C03       ; port A (read/write head) to input
F5D9: 20 F2 F5  JSR $F5F2
F5DC: A4 3F     LDY $3F
F5DE: B9 00 00  LDA $00,Y
F5E1: 49 30     EOR #$30        ; convert command code 'write' to 'verify'
F5E3: 99 00 00  STA $00,Y
F5E6: 4C B1 F3  JMP $F3B1



 $F5E9/62953:   Calculate parity for data buffer

Jump from $F4FB, $F575, $F698, $FCA2:

F5E9: A9 00     LDA #$00
F5EB: A8        TAY

Jump from $F5EF:

F5EC: 51 30     EOR ($30),Y
F5EE: C8        INY
F5EF: D0 FB     BNE $F5EC
F5F1: 60        RTS



 $F5F2/62962:   Convert buffer of GCR data into binary

Jump from $F5D9, $F972:

F5F2: A9 00     LDA #$00
F5F4: 85 2E     STA $2E
F5F6: 85 30     STA $30
F5F8: 85 4F     STA $4F
F5FA: A5 31     LDA $31
F5FC: 85 4E     STA $4E
F5FE: A9 01     LDA #$01
F600: 85 31     STA $31
F602: 85 2F     STA $2F
F604: A9 BB     LDA #$BB
F606: 85 34     STA $34
F608: 85 36     STA $36
F60A: 20 E6 F7  JSR $F7E6
F60D: A5 52     LDA $52
F60F: 85 38     STA $38
F611: A4 36     LDY $36
F613: A5 53     LDA $53
F615: 91 2E     STA ($2E),Y
F617: C8        INY
F618: A5 54     LDA $54
F61A: 91 2E     STA ($2E),Y
F61C: C8        INY
F61D: A5 55     LDA $55
F61F: 91 2E     STA ($2E),Y
F621: C8        INY
F622: 84 36     STY $36

Jump from $F641:

F624: 20 E6 F7  JSR $F7E6
F627: A4 36     LDY $36
F629: A5 52     LDA $52
F62B: 91 2E     STA ($2E),Y
F62D: C8        INY
F62E: A5 53     LDA $53
F630: 91 2E     STA ($2E),Y
F632: C8        INY
F633: F0 0E     BEQ $F643
F635: A5 54     LDA $54
F637: 91 2E     STA ($2E),Y
F639: C8        INY
F63A: A5 55     LDA $55
F63C: 91 2E     STA ($2E),Y
F63E: C8        INY
F63F: 84 36     STY $36
F641: D0 E1     BNE $F624

Jump from $F633:

F643: A5 54     LDA $54
F645: 91 30     STA ($30),Y
F647: C8        INY
F648: A5 55     LDA $55
F64A: 91 30     STA ($30),Y
F64C: C8        INY
F64D: 84 36     STY $36

Jump from $F66C:

F64F: 20 E6 F7  JSR $F7E6
F652: A4 36     LDY $36
F654: A5 52     LDA $52
F656: 91 30     STA ($30),Y
F658: C8        INY
F659: A5 53     LDA $53
F65B: 91 30     STA ($30),Y
F65D: C8        INY
F65E: A5 54     LDA $54
F660: 91 30     STA ($30),Y
F662: C8        INY
F663: A5 55     LDA $55
F665: 91 30     STA ($30),Y
F667: C8        INY
F668: 84 36     STY $36
F66A: C0 BB     CPY #$BB
F66C: 90 E1     BCC $F64F
F66E: A9 45     LDA #$45
F670: 85 2E     STA $2E
F672: A5 31     LDA $31
F674: 85 2F     STA $2F
F676: A0 BA     LDY #$BA

Jump from $F67D:

F678: B1 30     LDA ($30),Y
F67A: 91 2E     STA ($2E),Y
F67C: 88        DEY
F67D: D0 F9     BNE $F678
F67F: B1 30     LDA ($30),Y
F681: 91 2E     STA ($2E),Y
F683: A2 BB     LDX #$BB

Jump from $F68C:

F685: BD 00 01  LDA $0100,X
F688: 91 30     STA ($30),Y
F68A: C8        INY
F68B: E8        INX
F68C: D0 F7     BNE $F685
F68E: 86 50     STX $50
F690: 60        RTS



 $F691/63121:   Test command code further

Jump from $F572:

F691: C9 20     CMP #$20        ; command code for 'verify'?
F693: F0 03     BEQ $F698       ; yes
F695: 4C CA F6  JMP $F6CA       ; continue checking command code



 $F698/63128:   Compare written data with data on disk

Jump from $F693:

F698: 20 E9 F5  JSR $F5E9       ; calculate parity for data buffer
F69B: 85 3A     STA $3A         ; and save
F69D: 20 8F F7  JSR $F78F
F6A0: 20 0A F5  JSR $F50A       ; find start of data block
F6A3: A0 BB     LDY #$BB

Jump from $F6B1:

F6A5: B9 00 01  LDA $0100,Y     ; data from buffer

Jump from $F6A8:

F6A8: 50 FE     BVC $F6A8       ; byte ready?
F6AA: B8        CLV
F6AB: 4D 01 1C  EOR $1C01       ; compare with data from disk
F6AE: D0 15     BNE $F6C5       ; not equal, then error
F6B0: C8        INY
F6B1: D0 F2     BNE $F6A5

Jump from $F6C0:

F6B3: B1 30     LDA ($30),Y     ; data from buffer

Jump from $F6B5:

F6B5: 50 FE     BVC $F6B5
F6B7: B8        CLV
F6B8: 4D 01 1C  EOR $1C01       ; compare with data from disk
F6BB: D0 08     BNE $F6C5       ; not equal, then error
F6BD: C8        INY
F6BE: C0 FD     CPY #$FD
F6C0: D0 F1     BNE $F6B3
F6C2: 4C 18 F4  JMP $F418       ; error free termination

Jump from $F6AE, $F6BB:

F6C5: A9 07     LDA #$07
F6C7: 4C 69 F9  JMP $F969       ; 25, 'write error'



 $F6CA/63178:   Command code for find sector

Jump from $F695:

F6CA: 20 10 F5  JSR $F510       ; read block header
F6CD: 4C 18 F4  JMP $F418       ; done



 $F6D0/63184:   Convert 4 binary bytes to 5 GCR bytes

Jump from $F7BC, $F7E3, $F950, $F961, $FE5E, $FE64:

F6D0: A9 00     LDA #$00
F6D2: 85 57     STA $57
F6D4: 85 5A     STA $5A
F6D6: A4 34     LDY $34
F6D8: A5 52     LDA $52
F6DA: 29 F0     AND #$F0        ; isolate hi-nibble
F6DC: 4A        LSR
F6DD: 4A        LSR             ; and rotate to lower nibble
F6DE: 4A        LSR
F6DF: 4A        LSR
F6E0: AA        TAX             ; as index in table
F6E1: BD 7F F7  LDA $F77F,X
F6E4: 0A        ASL
F6E5: 0A        ASL             ; times 8
F6E6: 0A        ASL
F6E7: 85 56     STA $56
F6E9: A5 52     LDA $52
F6EB: 29 0F     AND #$0F        ; isolate lower nibble
F6ED: AA        TAX             ; as index in table
F6EE: BD 7F F7  LDA $F77F,X
F6F1: 6A        ROR
F6F2: 66 57     ROR $57
F6F4: 6A        ROR
F6F5: 66 57     ROR $57
F6F7: 29 07     AND #$07
F6F9: 05 56     ORA $56
F6FB: 91 30     STA ($30),Y     ; in buffer
F6FD: C8        INY             ; increment buffer
F6FE: A5 53     LDA $53
F700: 29 F0     AND #$F0        ; isolate upper nibble
F702: 4A        LSR
F703: 4A        LSR
F704: 4A        LSR             ; shift to upper nibble
F705: 4A        LSR
F706: AA        TAX             ; as index in table
F707: BD 7F F7  LDA $F77F,X
F70A: 0A        ASL
F70B: 05 57     ORA $57
F70D: 85 57     STA $57
F70F: A5 53     LDA $53
F711: 29 0F     AND #$0F        ; lower nibble
F713: AA        TAX             ; as index
F714: BD 7F F7  LDA $F77F,X
F717: 2A        ROL
F718: 2A        ROL
F719: 2A        ROL
F71A: 2A        ROL
F71B: 85 58     STA $58
F71D: 2A        ROL
F71E: 29 01     AND #$01
F720: 05 57     ORA $57
F722: 91 30     STA ($30),Y     ; in buffer
F724: C8        INY             ; increment buffer
F725: A5 54     LDA $54
F727: 29 F0     AND #$F0        ; isolate hi-nibble
F729: 4A        LSR
F72A: 4A        LSR
F72B: 4A        LSR
F72C: 4A        LSR
F72D: AA        TAX
F72E: BD 7F F7  LDA $F77F,X
F731: 18        CLC
F732: 6A        ROR
F733: 05 58     ORA $58
F735: 91 30     STA ($30),Y     ; in buffer
F737: C8        INY             ; increment buffer pointer
F738: 6A        ROR
F739: 29 80     AND #$80
F73B: 85 59     STA $59
F73D: A5 54     LDA $54
F73F: 29 0F     AND #$0F        ; lower nibble
F741: AA        TAX             ; as index
F742: BD 7F F7  LDA $F77F,X
F745: 0A        ASL
F746: 0A        ASL
F747: 29 7C     AND #$7C
F749: 05 59     ORA $59
F74B: 85 59     STA $59
F74D: A5 55     LDA $55
F74F: 29 F0     AND #$F0        ; isolate hi-nibble
F751: 4A        LSR
F752: 4A        LSR             ; shift to lower nibble
F753: 4A        LSR
F754: 4A        LSR
F755: AA        TAX             ; as index in table
F756: BD 7F F7  LDA $F77F,X
F759: 6A        ROR
F75A: 66 5A     ROR $5A
F75C: 6A        ROR
F75D: 66 5A     ROR $5A
F75F: 6A        ROR
F760: 66 5A     ROR $5A
F762: 29 03     AND #$03
F764: 05 59     ORA $59
F766: 91 30     STA ($30),Y     ; in buffer
F768: C8        INY             ; increment buffer pointer
F769: D0 04     BNE $F76F
F76B: A5 2F     LDA $2F
F76D: 85 31     STA $31

Jump from $F769:

F76F: A5 55     LDA $55
F771: 29 0F     AND #$0F        ; lower nibble
F773: AA        TAX             ; as index
F774: BD 7F F7  LDA $F77F,X
F777: 05 5A     ORA $5A
F779: 91 30     STA ($30),Y     ; in buffer
F77B: C8        INY             ; increment buffer pointer
F77C: 84 34     STY $34         ; and save
F77E: 60        RTS



 $F77F/63359:   GCR (5-bit) nybble table

F77F: 0A 0B 12 13 0E 0F 16 17
F787: 09 19 1A 1B 0D 1D 1E 15



 $F78F/63375:   Convert 260 bytes to 325 bytes group code

Jump from $F586, $F69D, $FCA7:

F78F: A9 00     LDA #$00
F791: 85 30     STA $30
F793: 85 2E     STA $2E
F795: 85 36     STA $36
F797: A9 BB     LDA #$BB
F799: 85 34     STA $34
F79B: 85 50     STA $50
F79D: A5 31     LDA $31
F79F: 85 2F     STA $2F
F7A1: A9 01     LDA #$01
F7A3: 85 31     STA $31
F7A5: A5 47     LDA $47
F7A7: 85 52     STA $52
F7A9: A4 36     LDY $36
F7AB: B1 2E     LDA ($2E),Y
F7AD: 85 53     STA $53
F7AF: C8        INY
F7B0: B1 2E     LDA ($2E),Y
F7B2: 85 54     STA $54
F7B4: C8        INY
F7B5: B1 2E     LDA ($2E),Y
F7B7: 85 55     STA $55
F7B9: C8        INY

Jump from $F7D7:

F7BA: 84 36     STY $36
F7BC: 20 D0 F6  JSR $F6D0
F7BF: A4 36     LDY $36
F7C1: B1 2E     LDA ($2E),Y
F7C3: 85 52     STA $52
F7C5: C8        INY
F7C6: F0 11     BEQ $F7D9
F7C8: B1 2E     LDA ($2E),Y
F7CA: 85 53     STA $53
F7CC: C8        INY
F7CD: B1 2E     LDA ($2E),Y
F7CF: 85 54     STA $54
F7D1: C8        INY
F7D2: B1 2E     LDA ($2E),Y
F7D4: 85 55     STA $55
F7D6: C8        INY
F7D7: D0 E1     BNE $F7BA

Jump from $F7C6:

F7D9: A5 3A     LDA $3A
F7DB: 85 53     STA $53
F7DD: A9 00     LDA #$00
F7DF: 85 54     STA $54
F7E1: 85 55     STA $55
F7E3: 4C D0 F6  JMP $F6D0



 $F7E6/63462:   Convert 5 GCR bytes to 4 binary bytes

Jump from $F4A9, $F4B8, $F60A, $F624, $F64F, $F8F4, $F90E:

F7E6: A4 34     LDY $34
F7E8: B1 30     LDA ($30),Y
F7EA: 29 F8     AND #$F8
F7EC: 4A        LSR
F7ED: 4A        LSR
F7EE: 4A        LSR
F7EF: 85 56     STA $56
F7F1: B1 30     LDA ($30),Y
F7F3: 29 07     AND #$07
F7F5: 0A        ASL
F7F6: 0A        ASL
F7F7: 85 57     STA $57
F7F9: C8        INY
F7FA: D0 06     BNE $F802
F7FC: A5 4E     LDA $4E
F7FE: 85 31     STA $31
F800: A4 4F     LDY $4F

Jump from $F7FA:

F802: B1 30     LDA ($30),Y
F804: 29 C0     AND #$C0
F806: 2A        ROL
F807: 2A        ROL
F808: 2A        ROL
F809: 05 57     ORA $57
F80B: 85 57     STA $57
F80D: B1 30     LDA ($30),Y
F80F: 29 3E     AND #$3E
F811: 4A        LSR
F812: 85 58     STA $58
F814: B1 30     LDA ($30),Y
F816: 29 01     AND #$01
F818: 0A        ASL
F819: 0A        ASL
F81A: 0A        ASL
F81B: 0A        ASL
F81C: 85 59     STA $59
F81E: C8        INY
F81F: B1 30     LDA ($30),Y
F821: 29 F0     AND #$F0
F823: 4A        LSR
F824: 4A        LSR
F825: 4A        LSR
F826: 4A        LSR
F827: 05 59     ORA $59
F829: 85 59     STA $59
F82B: B1 30     LDA ($30),Y
F82D: 29 0F     AND #$0F
F82F: 0A        ASL
F830: 85 5A     STA $5A
F832: C8        INY
F833: B1 30     LDA ($30),Y
F835: 29 80     AND #$80
F837: 18        CLC
F838: 2A        ROL
F839: 2A        ROL
F83A: 29 01     AND #$01
F83C: 05 5A     ORA $5A
F83E: 85 5A     STA $5A
F840: B1 30     LDA ($30),Y
F842: 29 7C     AND #$7C
F844: 4A        LSR
F845: 4A        LSR
F846: 85 5B     STA $5B
F848: B1 30     LDA ($30),Y
F84A: 29 03     AND #$03
F84C: 0A        ASL
F84D: 0A        ASL
F84E: 0A        ASL
F84F: 85 5C     STA $5C
F851: C8        INY
F852: D0 06     BNE $F85A
F854: A5 4E     LDA $4E
F856: 85 31     STA $31
F858: A4 4F     LDY $4F

Jump from $F852:

F85A: B1 30     LDA ($30),Y
F85C: 29 E0     AND #$E0
F85E: 2A        ROL
F85F: 2A        ROL
F860: 2A        ROL
F861: 2A        ROL
F862: 05 5C     ORA $5C
F864: 85 5C     STA $5C
F866: B1 30     LDA ($30),Y
F868: 29 1F     AND #$1F
F86A: 85 5D     STA $5D
F86C: C8        INY
F86D: 84 34     STY $34
F86F: A6 56     LDX $56
F871: BD A0 F8  LDA $F8A0,X
F874: A6 57     LDX $57
F876: 1D C0 F8  ORA $F8C0,X
F879: 85 52     STA $52
F87B: A6 58     LDX $58
F87D: BD A0 F8  LDA $F8A0,X
F880: A6 59     LDX $59
F882: 1D C0 F8  ORA $F8C0,X
F885: 85 53     STA $53
F887: A6 5A     LDX $5A
F889: BD A0 F8  LDA $F8A0,X
F88C: A6 5B     LDX $5B
F88E: 1D C0 F8  ORA $F8C0,X
F891: 85 54     STA $54
F893: A6 5C     LDX $5C
F895: BD A0 F8  LDA $F8A0,X
F898: A6 5D     LDX $5D
F89A: 1D C0 F8  ORA $F8C0,X
F89D: 85 55     STA $55
F89F: 60        RTS



 $F8A0/63648:   Conversion table GCR to binary - high nybble

F8A0: FF FF FF FF FF FF FF FF
F8A8: FF 80 00 10 FF C0 40 50
F8B0: FF FF 20 30 FF F0 60 70
F8B8: FF 90 A0 B0 FF D0 E0 FF



 $F8C0/63680:   Conversion table GCR to binary - low nybble

F8C0: FF FF FF FF FF FF FF FF
F8C8: FF 08 00 01 FF 0C 04 05
F8D0: FF FF 02 03 FF 0F 06 07
F8D8: FF 09 0A 0B FF 0D 0E FF



 $F8E0/63712:   Decode 69 GCR bytes

Jump from $F4ED:

F8E0: A9 00     LDA #$00
F8E2: 85 34     STA $34
F8E4: 85 2E     STA $2E
F8E6: 85 36     STA $36
F8E8: A9 01     LDA #$01
F8EA: 85 4E     STA $4E
F8EC: A9 BA     LDA #$BA
F8EE: 85 4F     STA $4F
F8F0: A5 31     LDA $31
F8F2: 85 2F     STA $2F
F8F4: 20 E6 F7  JSR $F7E6
F8F7: A5 52     LDA $52
F8F9: 85 38     STA $38
F8FB: A4 36     LDY $36
F8FD: A5 53     LDA $53
F8FF: 91 2E     STA ($2E),Y
F901: C8        INY
F902: A5 54     LDA $54
F904: 91 2E     STA ($2E),Y
F906: C8        INY
F907: A5 55     LDA $55
F909: 91 2E     STA ($2E),Y
F90B: C8        INY

Jump from $F929:

F90C: 84 36     STY $36
F90E: 20 E6 F7  JSR $F7E6
F911: A4 36     LDY $36
F913: A5 52     LDA $52
F915: 91 2E     STA ($2E),Y
F917: C8        INY
F918: F0 11     BEQ $F92B
F91A: A5 53     LDA $53
F91C: 91 2E     STA ($2E),Y
F91E: C8        INY
F91F: A5 54     LDA $54
F921: 91 2E     STA ($2E),Y
F923: C8        INY
F924: A5 55     LDA $55
F926: 91 2E     STA ($2E),Y
F928: C8        INY
F929: D0 E1     BNE $F90C

Jump from $F918:

F92B: A5 53     LDA $53
F92D: 85 3A     STA $3A
F92F: A5 2F     LDA $2F
F931: 85 31     STA $31
F933: 60        RTS



 $F934/63796:   Convert block header to GCR code

Jump from $F533:

F934: A5 31     LDA $31
F936: 85 2F     STA $2F
F938: A9 00     LDA #$00
F93A: 85 31     STA $31
F93C: A9 24     LDA #$24
F93E: 85 34     STA $34
F940: A5 39     LDA $39
F942: 85 52     STA $52
F944: A5 1A     LDA $1A
F946: 85 53     STA $53
F948: A5 19     LDA $19
F94A: 85 54     STA $54
F94C: A5 18     LDA $18
F94E: 85 55     STA $55
F950: 20 D0 F6  JSR $F6D0
F953: A5 17     LDA $17
F955: 85 52     STA $52
F957: A5 16     LDA $16
F959: 85 53     STA $53
F95B: A9 00     LDA #$00
F95D: 85 54     STA $54
F95F: 85 55     STA $55
F961: 20 D0 F6  JSR $F6D0
F964: A5 2F     LDA $2F
F966: 85 31     STA $31
F968: 60        RTS



 $F969/63849:   Error entry disk controller

Jump from $F2D5, $F390, $F40D, $F420, $F4F8, $F507, $F553, $F583, $F6C7,
          $FDA0, $FDE2:

F969: A4 3F     LDY $3F
F96B: 99 00 00  STA $00,Y
F96E: A5 50     LDA $50
F970: F0 03     BEQ $F975
F972: 20 F2 F5  JSR $F5F2

Jump from $F970:

F975: 20 8F F9  JSR $F98F
F978: A6 49     LDX $49         ; get stack pointer back
F97A: 9A        TXS
F97B: 4C BE F2  JMP $F2BE



 $F97E/63870:   Turn drive motor on

Jump from $F2DF:

F97E: A9 A0     LDA #$A0
F980: 85 20     STA $20
F982: AD 00 1C  LDA $1C00
F985: 09 04     ORA #$04        ; turn drive motor on
F987: 8D 00 1C  STA $1C00
F98A: A9 3C     LDA #$3C
F98C: 85 48     STA $48
F98E: 60        RTS



 $F98F/63887:   Turn drive motor off

Jump from $F975:

F98F: A6 3E     LDX $3E
F991: A5 20     LDA $20
F993: 09 10     ORA #$10        ; turn drive motor off
F995: 85 20     STA $20
F997: A9 FF     LDA #$FF
F999: 85 48     STA $48
F99B: 60        RTS



 $F99C/63900:   Job loop disk controller

Jump from $F2E6, $F2F0, $F2F6, $F31D, $F48A, $FAF2, $FAFD, $FD93, $FDD8:

F99C: AD 07 1C  LDA $1C07
F99F: 8D 05 1C  STA $1C05
F9A2: AD 00 1C  LDA $1C00
F9A5: 29 10     AND #$10        ; write protect?
F9A7: C5 1E     CMP $1E
F9A9: 85 1E     STA $1E
F9AB: F0 04     BEQ $F9B1
F9AD: A9 01     LDA #$01
F9AF: 85 1C     STA $1C

Jump from $F9AB:

F9B1: AD FE 02  LDA $02FE
F9B4: F0 15     BEQ $F9CB
F9B6: C9 02     CMP #$02
F9B8: D0 07     BNE $F9C1
F9BA: A9 00     LDA #$00
F9BC: 8D FE 02  STA $02FE
F9BF: F0 0A     BEQ $F9CB

Jump from $F9B8:

F9C1: 85 4A     STA $4A
F9C3: A9 02     LDA #$02
F9C5: 8D FE 02  STA $02FE
F9C8: 4C 2E FA  JMP $FA2E



 $F9CB/63947:   ?

Jump from $F9B4, $F9BF:

F9CB: A6 3E     LDX $3E
F9CD: 30 07     BMI $F9D6
F9CF: A5 20     LDA $20
F9D1: A8        TAY
F9D2: C9 20     CMP #$20
F9D4: D0 03     BNE $F9D9

Jump from $F9CD, $F9F8:

F9D6: 4C BE FA  JMP $FABE



 $F9D9/63961:   ?

Jump from $F9D4:

F9D9: C6 48     DEC $48
F9DB: D0 1D     BNE $F9FA
F9DD: 98        TYA
F9DE: 10 04     BPL $F9E4
F9E0: 29 7F     AND #$7F
F9E2: 85 20     STA $20

Jump from $F9DE:

F9E4: 29 10     AND #$10
F9E6: F0 12     BEQ $F9FA
F9E8: AD 00 1C  LDA $1C00
F9EB: 29 FB     AND #$FB        ; drive motor off
F9ED: 8D 00 1C  STA $1C00
F9F0: A9 FF     LDA #$FF
F9F2: 85 3E     STA $3E
F9F4: A9 00     LDA #$00
F9F6: 85 20     STA $20
F9F8: F0 DC     BEQ $F9D6

Jump from $F9DB, $F9E6:

F9FA: 98        TYA
F9FB: 29 40     AND #$40
F9FD: D0 03     BNE $FA02
F9FF: 4C BE FA  JMP $FABE

Jump from $F9FD:

FA02: 6C 62 00  JMP ($0062)



 $FA05/64005:   Move head to next track

FA05: A5 4A     LDA $4A
FA07: 10 05     BPL $FA0E
FA09: 49 FF     EOR #$FF
FA0B: 18        CLC
FA0C: 69 01     ADC #$01

Jump from $FA07:

FA0E: C5 64     CMP $64
FA10: B0 0A     BCS $FA1C
FA12: A9 3B     LDA #$3B
FA14: 85 62     STA $62
FA16: A9 FA     LDA #$FA        ; pointer $62/$63 to $FA3B
FA18: 85 63     STA $63
FA1A: D0 12     BNE $FA2E



 $FA1C/64028:   Calculate number of head steps

Jump from $FA10:

FA1C: E5 5E     SBC $5E
FA1E: E5 5E     SBC $5E
FA20: 85 61     STA $61
FA22: A5 5E     LDA $5E
FA24: 85 60     STA $60
FA26: A9 7B     LDA #$7B
FA28: 85 62     STA $62
FA2A: A9 FA     LDA #$FA        ; pointer $62/$63 to $FA7B
FA2C: 85 63     STA $63

Jump from $F9C8, $FA1A, $FA3D, $FA94:

FA2E: A5 4A     LDA $4A         ; step counter for head transport
FA30: 10 31     BPL $FA63
FA32: E6 4A     INC $4A         ; increment
FA34: AE 00 1C  LDX $1C00
FA37: CA        DEX
FA38: 4C 69 FA  JMP $FA69



 $FA3B/64059:   Move stepper motor short distance

FA3B: A5 4A     LDA $4A         ; step counter for head transport
FA3D: D0 EF     BNE $FA2E       ; not yet zero?
FA3F: A9 4E     LDA #$4E
FA41: 85 62     STA $62
FA43: A9 FA     LDA #$FA        ; pointer $62/$63 to $FA4E
FA45: 85 63     STA $63
FA47: A9 05     LDA #$05
FA49: 85 60     STA $60         ; counter to 5
FA4B: 4C BE FA  JMP $FABE



 $FA4E/64078:   Load head

FA4E: C6 60     DEC $60         ; decrement counter
FA50: D0 6C     BNE $FABE       ; not yet zero?
FA52: A5 20     LDA $20
FA54: 29 BF     AND #$BF        ; erase bit 6
FA56: 85 20     STA $20
FA58: A9 05     LDA #$05
FA5A: 85 62     STA $62
FA5C: A9 FA     LDA #$FA        ; pointer $62/$63 to $FA05
FA5E: 85 63     STA $63
FA60: 4C BE FA  JMP $FABE



 $FA63/64099:   ?

Jump from $FA30:

FA63: C6 4A     DEC $4A         ; step counter for head transport
FA65: AE 00 1C  LDX $1C00
FA68: E8        INX

Jump from $FA38:

FA69: 8A        TXA
FA6A: 29 03     AND #$03
FA6C: 85 4B     STA $4B
FA6E: AD 00 1C  LDA $1C00
FA71: 29 FC     AND #$FC
FA73: 05 4B     ORA $4B         ; stepper motor off
FA75: 8D 00 1C  STA $1C00
FA78: 4C BE FA  JMP $FABE



 $FA7B/64123:   Prepare fast head movement

FA7B: 38        SEC
FA7C: AD 07 1C  LDA $1C07
FA7F: E5 5F     SBC $5F
FA81: 8D 05 1C  STA $1C05
FA84: C6 60     DEC $60         ; decrement counter
FA86: D0 0C     BNE $FA94       ; not yet zero?
FA88: A5 5E     LDA $5E
FA8A: 85 60     STA $60
FA8C: A9 97     LDA #$97
FA8E: 85 62     STA $62
FA90: A9 FA     LDA #$FA        ; pointer $62/$63 to $FA97
FA92: 85 63     STA $63

Jump from $FA86, $FA99, $FAA3, $FAB0:

FA94: 4C 2E FA  JMP $FA2E



 $FA97/64151:   Fast head movement

FA97: C6 61     DEC $61
FA99: D0 F9     BNE $FA94
FA9B: A9 A5     LDA #$A5
FA9D: 85 62     STA $62
FA9F: A9 FA     LDA #$FA        ; pointer $62/$63 to $FAA5
FAA1: 85 63     STA $63
FAA3: D0 EF     BNE $FA94



 $FAA5/64165:   Prepare slow head movement

FAA5: AD 07 1C  LDA $1C07
FAA8: 18        CLC
FAA9: 65 5F     ADC $5F
FAAB: 8D 05 1C  STA $1C05
FAAE: C6 60     DEC $60         ; decrement counter
FAB0: D0 E2     BNE $FA94       ; not yet zero?
FAB2: A9 4E     LDA #$4E
FAB4: 85 62     STA $62
FAB6: A9 FA     LDA #$FA        ; pointer $62/$63 to $FA4E
FAB8: 85 63     STA $63
FABA: A9 05     LDA #$05
FABC: 85 60     STA $60         ; counter to 5

Jump from $F9D6, $F9FF, $FA4B, $FA50, $FA60, $FA78:

FABE: AD 0C 1C  LDA $1C0C
FAC1: 29 FD     AND #$FD        ; erase bit 1
FAC3: 8D 0C 1C  STA $1C0C
FAC6: 60        RTS



 $FAC7/64199:   Formatting

FAC7: A5 51     LDA $51         ; track number
FAC9: 10 2A     BPL $FAF5       ; formatting already in progress
FACB: A6 3D     LDX $3D         ; drive number
FACD: A9 60     LDA #$60        ; flag for head transport
FACF: 95 20     STA $20,X       ; set
FAD1: A9 01     LDA #$01
FAD3: 95 22     STA $22,X       ; set destination track
FAD5: 85 51     STA $51         ; running track number for format
FAD7: A9 A4     LDA #$A4        ; 164
FAD9: 85 4A     STA $4A         ; step counter for head transport
FADB: AD 00 1C  LDA $1C00
FADE: 29 FC     AND #$FC        ; stepper motor on
FAE0: 8D 00 1C  STA $1C00
FAE3: A9 0A     LDA #$0A        ; 10
FAE5: 8D 20 06  STA $0620       ; error counter
FAE8: A9 A0     LDA #$A0        ; $621/$622 = 4000
FAEA: 8D 21 06  STA $0621       ; initialize track capacity
FAED: A9 0F     LDA #$0F        ; 4000 < capacity < 2*4000 bytes
FAEF: 8D 22 06  STA $0622
FAF2: 4C 9C F9  JMP $F99C       ; back in job loop

Jump from $FAC9:

FAF5: A0 00     LDY #$00
FAF7: D1 32     CMP ($32),Y
FAF9: F0 05     BEQ $FB00
FAFB: 91 32     STA ($32),Y
FAFD: 4C 9C F9  JMP $F99C       ; to job loop

Jump from $FAF9:

FB00: AD 00 1C  LDA $1C00
FB03: 29 10     AND #$10        ; write protect?
FB05: D0 05     BNE $FB0C       ; no
FB07: A9 08     LDA #$08
FB09: 4C D3 FD  JMP $FDD3       ; 26, 'write protect on'

Jump from $FB05, $FBB3:

FB0C: 20 A3 FD  JSR $FDA3       ; write $FF to disk 10240 times
FB0F: 20 C3 FD  JSR $FDC3       ; code ($621/$622) times to disk
FB12: A9 55     LDA #$55        ; $55
FB14: 8D 01 1C  STA $1C01       ; to write head
FB17: 20 C3 FD  JSR $FDC3       ; and ($621/$622) times to disk
FB1A: 20 00 FE  JSR $FE00       ; switch to read
FB1D: 20 56 F5  JSR $F556       ; set timer, find $FF (SYNC)
FB20: A9 40     LDA #$40
FB22: 0D 0B 18  ORA $180B       ; timer 1 free running
FB25: 8D 0B 18  STA $180B
FB28: A9 62     LDA #$62        ; 98 cycles, about 0.1 ms
FB2A: 8D 06 18  STA $1806
FB2D: A9 00     LDA #$00
FB2F: 8D 07 18  STA $1807
FB32: 8D 05 18  STA $1805       ; start timer
FB35: A0 00     LDY #$00        ; counter to zero
FB37: A2 00     LDX #$00

Jump from $FB3C:

FB39: 2C 00 1C  BIT $1C00       ; SYNC found?
FB3C: 30 FB     BMI $FB39       ; no, wait

Jump from $FB41:

FB3E: 2C 00 1C  BIT $1C00       ; SYNC found?
FB41: 10 FB     BPL $FB3E       ; wait for SYNC

Jump from $FB52, $FB55:

FB43: AD 04 18  LDA $1804       ; reset interrupt flag timer

Jump from $FB4F:

FB46: 2C 00 1C  BIT $1C00       ; SYNC found?
FB49: 10 11     BPL $FB5C       ; not SYNC ($55)?
FB4B: AD 0D 18  LDA $180D       ; interrupt flag register
FB4E: 0A        ASL             ; shift timer flag
FB4F: 10 F5     BPL $FB46       ; timer not run down yet?
FB51: E8        INX             ; increment counter
FB52: D0 EF     BNE $FB43
FB54: C8        INY             ; increment hi-byte of counter
FB55: D0 EC     BNE $FB43
FB57: A9 02     LDA #$02        ; overflow, then error
FB59: 4C D3 FD  JMP $FDD3       ; 20, 'read error'

Jump from $FB49:

FB5C: 86 71     STX $71
FB5E: 84 72     STY $72
FB60: A2 00     LDX #$00
FB62: A0 00     LDY #$00        ; counter to zero again

Jump from $FB73, $FB76:

FB64: AD 04 18  LDA $1804       ; reset timer 1 interrupt flag

Jump from $FB70:

FB67: 2C 00 1C  BIT $1C00       ; SYNC found?
FB6A: 30 11     BMI $FB7D       ; yes
FB6C: AD 0D 18  LDA $180D       ; interrupt-flag register
FB6F: 0A        ASL             ; timer flag to bit 7
FB70: 10 F5     BPL $FB67       ; no, wait until timer run down
FB72: E8        INX
FB73: D0 EF     BNE $FB64       ; increment counter
FB75: C8        INY
FB76: D0 EC     BNE $FB64
FB78: A9 02     LDA #$02        ; overflow, then error
FB7A: 4C D3 FD  JMP $FDD3       ; 20, 'read error'

Jump from $FB6A:

FB7D: 38        SEC
FB7E: 8A        TXA
FB7F: E5 71     SBC $71         ; difference between counter
FB81: AA        TAX
FB82: 85 70     STA $70
FB84: 98        TYA             ; and value for $FF-storage
FB85: E5 72     SBC $72
FB87: A8        TAY             ; bring to $70/$71
FB88: 85 71     STA $71
FB8A: 10 0B     BPL $FB97       ; difference positive?
FB8C: 49 FF     EOR #$FF
FB8E: A8        TAY
FB8F: 8A        TXA
FB90: 49 FF     EOR #$FF        ; calculate absolute value of difference
FB92: AA        TAX
FB93: E8        INX
FB94: D0 01     BNE $FB97
FB96: C8        INY

Jump from $FB8A, $FB94:

FB97: 98        TYA
FB98: D0 04     BNE $FB9E
FB9A: E0 04     CPX #$04        ; difference less than 4 * 0.1 ms
FB9C: 90 18     BCC $FBB6       ; yes

Jump from $FB98:

FB9E: 06 70     ASL $70
FBA0: 26 71     ROL $71         ; double difference
FBA2: 18        CLC
FBA3: A5 70     LDA $70
FBA5: 6D 21 06  ADC $0621
FBA8: 8D 21 06  STA $0621       ; add to 4000
FBAB: A5 71     LDA $71
FBAD: 6D 22 06  ADC $0622
FBB0: 8D 22 06  STA $0622
FBB3: 4C 0C FB  JMP $FB0C       ; repeat until difference < 4 * 0.1 ms

Jump from $FB9C:

FBB6: A2 00     LDX #$00
FBB8: A0 00     LDY #$00        ; counter to zero
FBBA: B8        CLV

Jump from $FBC0, $FBC4, $FBC7:

FBBB: AD 00 1C  LDA $1C00       ; SYNC?
FBBE: 10 0E     BPL $FBCE       ; no
FBC0: 50 F9     BVC $FBBB       ; byte ready?
FBC2: B8        CLV
FBC3: E8        INX
FBC4: D0 F5     BNE $FBBB       ; increment counter
FBC6: C8        INY
FBC7: D0 F2     BNE $FBBB
FBC9: A9 03     LDA #$03        ; overflow, then error
FBCB: 4C D3 FD  JMP $FDD3       ; 21, 'read error'

Jump from $FBBE:

FBCE: 8A        TXA
FBCF: 0A        ASL             ; double counter
FBD0: 8D 25 06  STA $0625
FBD3: 98        TYA
FBD4: 2A        ROL
FBD5: 8D 24 06  STA $0624       ; and to $624/$625 as track capacity
FBD8: A9 BF     LDA #$BF
FBDA: 2D 0B 18  AND $180B
FBDD: 8D 0B 18  STA $180B
FBE0: A9 66     LDA #$66        ; 102
FBE2: 8D 26 06  STA $0626
FBE5: A6 43     LDX $43         ; number of sectors in this track
FBE7: A0 00     LDY #$00
FBE9: 98        TYA

Jump from $FBF3:

FBEA: 18        CLC
FBEB: 6D 26 06  ADC $0626
FBEE: 90 01     BCC $FBF1
FBF0: C8        INY

Jump from $FBEE:

FBF1: C8        INY
FBF2: CA        DEX
FBF3: D0 F5     BNE $FBEA       ; calculate number of bytes
FBF5: 49 FF     EOR #$FF
FBF7: 38        SEC
FBF8: 69 00     ADC #$00
FBFA: 18        CLC
FBFB: 6D 25 06  ADC $0625
FBFE: B0 03     BCS $FC03
FC00: CE 24 06  DEC $0624

Jump from $FBFE:

FC03: AA        TAX
FC04: 98        TYA
FC05: 49 FF     EOR #$FF
FC07: 38        SEC
FC08: 69 00     ADC #$00
FC0A: 18        CLC
FC0B: 6D 24 06  ADC $0624       ; result in A/X
FC0E: 10 05     BPL $FC15
FC10: A9 04     LDA #$04
FC12: 4C D3 FD  JMP $FDD3       ; 22, 'read error'

Jump from $FC0E:

FC15: A8        TAY
FC16: 8A        TXA
FC17: A2 00     LDX #$00

Jump from $FC22:

FC19: 38        SEC             ; total divided by number
FC1A: E5 43     SBC $43         ; of sectors ($43)
FC1C: B0 03     BCS $FC21
FC1E: 88        DEY
FC1F: 30 03     BMI $FC24

Jump from $FC1C:

FC21: E8        INX
FC22: D0 F5     BNE $FC19

Jump from $FC1F:

FC24: 8E 26 06  STX $0626       ; compare number of bytes per interval
FC27: E0 04     CPX #$04        ; with minimum value
FC29: B0 05     BCS $FC30       ; ok
FC2B: A9 05     LDA #$05
FC2D: 4C D3 FD  JMP $FDD3       ; 23, 'read error'

Jump from $FC29:

FC30: 18        CLC             ; remainder of division
FC31: 65 43     ADC $43         ; plus number of sectors
FC33: 8D 27 06  STA $0627       ; save
FC36: A9 00     LDA #$00
FC38: 8D 28 06  STA $0628       ; counter for sectors
FC3B: A0 00     LDY #$00        ; counter lo
FC3D: A6 3D     LDX $3D         ; drive number

Jump from $FC82:

FC3F: A5 39     LDA $39         ; constant 8, marker for header
FC41: 99 00 03  STA $0300,Y     ; in buffer
FC44: C8        INY
FC45: C8        INY
FC46: AD 28 06  LDA $0628       ; sector number
FC49: 99 00 03  STA $0300,Y     ; in buffer
FC4C: C8        INY
FC4D: A5 51     LDA $51         ; track number
FC4F: 99 00 03  STA $0300,Y     ; in buffer
FC52: C8        INY
FC53: B5 13     LDA $13,X       ; ID 2
FC55: 99 00 03  STA $0300,Y     ; in buffer
FC58: C8        INY
FC59: B5 12     LDA $12,X       ; ID 1
FC5B: 99 00 03  STA $0300,Y     ; in buffer
FC5E: C8        INY
FC5F: A9 0F     LDA #$0F        ; 15
FC61: 99 00 03  STA $0300,Y     ; in buffer
FC64: C8        INY
FC65: 99 00 03  STA $0300,Y     ; 15 in buffer
FC68: C8        INY
FC69: A9 00     LDA #$00
FC6B: 59 FA 02  EOR $02FA,Y
FC6E: 59 FB 02  EOR $02FB,Y
FC71: 59 FC 02  EOR $02FC,Y     ; generate checksum
FC74: 59 FD 02  EOR $02FD,Y
FC77: 99 F9 02  STA $02F9,Y
FC7A: EE 28 06  INC $0628       ; increment counter
FC7D: AD 28 06  LDA $0628       ; counter
FC80: C5 43     CMP $43         ; compare with number of sectors
FC82: 90 BB     BCC $FC3F       ; smaller, then continue
FC84: 98        TYA
FC85: 48        PHA
FC86: E8        INX
FC87: 8A        TXA

Jump from $FC8C:

FC88: 9D 00 05  STA $0500,X
FC8B: E8        INX
FC8C: D0 FA     BNE $FC88
FC8E: A9 03     LDA #$03        ; buffer pointer to $300
FC90: 85 31     STA $31
FC92: 20 30 FE  JSR $FE30
FC95: 68        PLA
FC96: A8        TAY
FC97: 88        DEY
FC98: 20 E5 FD  JSR $FDE5       ; copy buffer data
FC9B: 20 F5 FD  JSR $FDF5       ; copy data in buffer
FC9E: A9 05     LDA #$05
FCA0: 85 31     STA $31         ; buffer pointer to $500
FCA2: 20 E9 F5  JSR $F5E9       ; calculate parity for data buffer
FCA5: 85 3A     STA $3A         ; and save
FCA7: 20 8F F7  JSR $F78F
FCAA: A9 00     LDA #$00
FCAC: 85 32     STA $32
FCAE: 20 0E FE  JSR $FE0E

Jump from $FD1C:

FCB1: A9 FF     LDA #$FF
FCB3: 8D 01 1C  STA $1C01       ; to write head
FCB6: A2 05     LDX #$05        ; write $FF 5 times

Jump from $FCB8, $FCBC:

FCB8: 50 FE     BVC $FCB8       ; byte ready
FCBA: B8        CLV
FCBB: CA        DEX
FCBC: D0 FA     BNE $FCB8
FCBE: A2 0A     LDX #$0A        ; 10 times
FCC0: A4 32     LDY $32         ; buffer pointer

Jump from $FCC2, $FCCD:

FCC2: 50 FE     BVC $FCC2       ; byte ready?
FCC4: B8        CLV
FCC5: B9 00 03  LDA $0300,Y     ; data from buffer
FCC8: 8D 01 1C  STA $1C01       ; write
FCCB: C8        INY
FCCC: CA        DEX             ; 10 data written?
FCCD: D0 F3     BNE $FCC2
FCCF: A2 09     LDX #$09        ; 9 times

Jump from $FCD1, $FCDA:

FCD1: 50 FE     BVC $FCD1       ; byte ready?
FCD3: B8        CLV
FCD4: A9 55     LDA #$55        ; $55
FCD6: 8D 01 1C  STA $1C01       ; write
FCD9: CA        DEX
FCDA: D0 F5     BNE $FCD1       ; 9 times?
FCDC: A9 FF     LDA #$FF        ; $FF
FCDE: A2 05     LDX #$05        ; 5 times

Jump from $FCE0, $FCE7:

FCE0: 50 FE     BVC $FCE0       ; byte ready?
FCE2: B8        CLV
FCE3: 8D 01 1C  STA $1C01       ; to write head
FCE6: CA        DEX
FCE7: D0 F7     BNE $FCE0
FCE9: A2 BB     LDX #$BB

Jump from $FCEB, $FCF5:

FCEB: 50 FE     BVC $FCEB
FCED: B8        CLV
FCEE: BD 00 01  LDA $0100,X     ; area $1BB to $1FF
FCF1: 8D 01 1C  STA $1C01       ; save
FCF4: E8        INX
FCF5: D0 F4     BNE $FCEB
FCF7: A0 00     LDY #$00

Jump from $FCF9, $FD02:

FCF9: 50 FE     BVC $FCF9       ; byte ready?
FCFB: B8        CLV
FCFC: B1 30     LDA ($30),Y     ; 256 bytes of data
FCFE: 8D 01 1C  STA $1C01       ; write byte to disk
FD01: C8        INY
FD02: D0 F5     BNE $FCF9
FD04: A9 55     LDA #$55        ; $55
FD06: AE 26 06  LDX $0626       ; ($626) times

Jump from $FD09, $FD10:

FD09: 50 FE     BVC $FD09
FD0B: B8        CLV
FD0C: 8D 01 1C  STA $1C01       ; write
FD0F: CA        DEX
FD10: D0 F7     BNE $FD09
FD12: A5 32     LDA $32
FD14: 18        CLC
FD15: 69 0A     ADC #$0A        ; plus 10
FD17: 85 32     STA $32
FD19: CE 28 06  DEC $0628       ; decrement sector number
FD1C: D0 93     BNE $FCB1

Jump from $FD1E:

FD1E: 50 FE     BVC $FD1E       ; byte ready?
FD20: B8        CLV

Jump from $FD21:

FD21: 50 FE     BVC $FD21       ; byte ready?
FD23: B8        CLV
FD24: 20 00 FE  JSR $FE00       ; switch to reading
FD27: A9 C8     LDA #$C8        ; 200
FD29: 8D 23 06  STA $0623

Jump from $FD5B:

FD2C: A9 00     LDA #$00
FD2E: 85 30     STA $30
FD30: A9 03     LDA #$03        ; buffer pointer to $300
FD32: 85 31     STA $31
FD34: A5 43     LDA $43         ; number of sectors per track
FD36: 8D 28 06  STA $0628

Jump from $FD89:

FD39: 20 56 F5  JSR $F556       ; wait for SYNC
FD3C: A2 0A     LDX #$0A        ; 10 data
FD3E: A0 00     LDY #$00

Jump from $FD40, $FD4C:

FD40: 50 FE     BVC $FD40       ; byte ready?
FD42: B8        CLV
FD43: AD 01 1C  LDA $1C01       ; read byte
FD46: D1 30     CMP ($30),Y     ; compare with data in buffer
FD48: D0 0E     BNE $FD58       ; not equal, error
FD4A: C8        INY
FD4B: CA        DEX
FD4C: D0 F2     BNE $FD40
FD4E: 18        CLC
FD4F: A5 30     LDA $30
FD51: 69 0A     ADC #$0A        ; increment pointer by 10
FD53: 85 30     STA $30
FD55: 4C 62 FD  JMP $FD62

Jump from $FD48, $FD70, $FD80:

FD58: CE 23 06  DEC $0623       ; decrement counter for attempts
FD5B: D0 CF     BNE $FD2C       ; not yet zero?
FD5D: A9 06     LDA #$06        ; else error
FD5F: 4C D3 FD  JMP $FDD3       ; 24, 'read error'

Jump from $FD55:

FD62: 20 56 F5  JSR $F556       ; wait for SYNC
FD65: A0 BB     LDY #$BB

Jump from $FD67, $FD73:

FD67: 50 FE     BVC $FD67       ; byte ready?
FD69: B8        CLV
FD6A: AD 01 1C  LDA $1C01       ; read byte
FD6D: D9 00 01  CMP $0100,Y     ; compare with buffer contents
FD70: D0 E6     BNE $FD58       ; not equal, error
FD72: C8        INY
FD73: D0 F2     BNE $FD67       ; next byte
FD75: A2 FC     LDX #$FC

Jump from $FD77, $FD84:

FD77: 50 FE     BVC $FD77       ; byte ready?
FD79: B8        CLV
FD7A: AD 01 1C  LDA $1C01       ; read byte
FD7D: D9 00 05  CMP $0500,Y     ; compare with buffer contents
FD80: D0 D6     BNE $FD58       ; not equal, then error
FD82: C8        INY
FD83: CA        DEX             ; next byte
FD84: D0 F1     BNE $FD77
FD86: CE 28 06  DEC $0628       ; decrement sector counter
FD89: D0 AE     BNE $FD39       ; not yet zero?
FD8B: E6 51     INC $51         ; increment track number
FD8D: A5 51     LDA $51
FD8F: C9 24     CMP #$24        ; compare with 36, highest track number + 1
FD91: B0 03     BCS $FD96       ; greater, then formatting done
FD93: 4C 9C F9  JMP $F99C       ; continue

Jump from $FD91:

FD96: A9 FF     LDA #$FF
FD98: 85 51     STA $51         ; track number to $FF
FD9A: A9 00     LDA #$00
FD9C: 85 50     STA $50
FD9E: A9 01     LDA #$01
FDA0: 4C 69 F9  JMP $F969       ; ok



 $FDA3/64931:   Write SYNC 10240 times, erase track

Jump from $FB0C:

FDA3: AD 0C 1C  LDA $1C0C
FDA6: 29 1F     AND #$1F        ; switch PCR to writing
FDA8: 09 C0     ORA #$C0
FDAA: 8D 0C 1C  STA $1C0C
FDAD: A9 FF     LDA #$FF
FDAF: 8D 03 1C  STA $1C03       ; port A (read/write head) to output
FDB2: 8D 01 1C  STA $1C01       ; write $FF to disk
FDB5: A2 28     LDX #$28        ; 40
FDB7: A0 00     LDY #$00

Jump from $FDB9, $FDBD, $FDC0:

FDB9: 50 FE     BVC $FDB9       ; byte ready?
FDBB: B8        CLV
FDBC: 88        DEY
FDBD: D0 FA     BNE $FDB9
FDBF: CA        DEX
FDC0: D0 F7     BNE $FDB9
FDC2: 60        RTS



 $FDC3/64963:   Read/write ($621/$622) times

Jump from $FB0F, $FB17:

FDC3: AE 21 06  LDX $0621
FDC6: AC 22 06  LDY $0622

Jump from $FDC9, $FDCD, $FDD0:

FDC9: 50 FE     BVC $FDC9       ; byte ready?
FDCB: B8        CLV
FDCC: CA        DEX
FDCD: D0 FA     BNE $FDC9
FDCF: 88        DEY
FDD0: 10 F7     BPL $FDC9
FDD2: 60        RTS



 $FDD3/64979:   Attempt counter for formatting

Jump from $FB09, $FB59, $FB7A, $FBCB, $FC12, $FC2D, $FD5F:

FDD3: CE 20 06  DEC $0620       ; decrement number of attempts
FDD6: F0 03     BEQ $FDDB       ; zero, then error
FDD8: 4C 9C F9  JMP $F99C       ; continue

Jump from $FDD6:

FDDB: A0 FF     LDY #$FF
FDDD: 84 51     STY $51         ; flag for end of formatting
FDDF: C8        INY
FDE0: 84 50     STY $50
FDE2: 4C 69 F9  JMP $F969       ; error termination



 $FDE5/64997:   ?

Jump from $FDEC, $FC98:

FDE5: B9 00 03  LDA $0300,Y
FDE8: 99 45 03  STA $0345,Y
FDEB: 88        DEY             ; copy buffer contents
FDEC: D0 F7     BNE $FDE5
FDEE: AD 00 03  LDA $0300
FDF1: 8D 45 03  STA $0345
FDF4: 60        RTS



 $FDF5/65013:   Copy data from overflow buffer

Jump from $FC9B:

FDF5: A0 44     LDY #$44

Jump from $FDFD:

FDF7: B9 BB 01  LDA $01BB,Y     ; $1BB to $1FF
FDFA: 91 30     STA ($30),Y     ; write in buffer $30/$31
FDFC: 88        DEY
FDFD: 10 F8     BPL $FDF7
FDFF: 60        RTS



 $FE00/65024:   Switch to reading

Jump from $FB1A, $FD24:

FE00: AD 0C 1C  LDA $1C0C
FE03: 09 E0     ORA #$E0        ; switch PCR to reading
FE05: 8D 0C 1C  STA $1C0C
FE08: A9 00     LDA #$00
FE0A: 8D 03 1C  STA $1C03       ; port A to input
FE0D: 60        RTS



 $FE0E/65038:   Write $55 10240 times

Jump from $FCAE:

FE0E: AD 0C 1C  LDA $1C0C
FE11: 29 1F     AND #$1F
FE13: 09 C0     ORA #$C0        ; switch PCR to writing
FE15: 8D 0C 1C  STA $1C0C
FE18: A9 FF     LDA #$FF
FE1A: 8D 03 1C  STA $1C03       ; port A to output (write head)
FE1D: A9 55     LDA #$55        ; %01010101
FE1F: 8D 01 1C  STA $1C01       ; to port A (write head)
FE22: A2 28     LDX #$28
FE24: A0 00     LDY #$00

Jump from $FE26, $FE2A, $FE2D:

FE26: 50 FE     BVC $FE26       ; byte ready for write electronics
FE28: B8        CLV
FE29: 88        DEY
FE2A: D0 FA     BNE $FE26       ; 10240 times
FE2C: CA        DEX
FE2D: D0 F7     BNE $FE26
FE2F: 60        RTS



 $FE30/65072:   Convert header in buffer 0 to GCR code

Jump from $FC92:

FE30: A9 00     LDA #$00
FE32: 85 30     STA $30
FE34: 85 2E     STA $2E
FE36: 85 36     STA $36
FE38: A9 BB     LDA #$BB
FE3A: 85 34     STA $34
FE3C: A5 31     LDA $31
FE3E: 85 2F     STA $2F
FE40: A9 01     LDA #$01
FE42: 85 31     STA $31

Jump from $FE61:

FE44: A4 36     LDY $36
FE46: B1 2E     LDA ($2E),Y
FE48: 85 52     STA $52
FE4A: C8        INY
FE4B: B1 2E     LDA ($2E),Y
FE4D: 85 53     STA $53
FE4F: C8        INY
FE50: B1 2E     LDA ($2E),Y
FE52: 85 54     STA $54
FE54: C8        INY
FE55: B1 2E     LDA ($2E),Y
FE57: 85 55     STA $55
FE59: C8        INY
FE5A: F0 08     BEQ $FE64
FE5C: 84 36     STY $36
FE5E: 20 D0 F6  JSR $F6D0
FE61: 4C 44 FE  JMP $FE44

Jump from $FE5A:

FE64: 4C D0 F6  JMP $F6D0



 $FE67/65127:   Interrupt routine

FE67: 48        PHA
FE68: 8A        TXA
FE69: 48        PHA             ; save registers
FE6A: 98        TYA
FE6B: 48        PHA
FE6C: AD 0D 18  LDA $180D       ; interrupt from serial bus?
FE6F: 29 02     AND #$02
FE71: F0 03     BEQ $FE76       ; no
FE73: 20 53 E8  JSR $E853       ; serve serial bus

Jump from $FE71:

FE76: AD 0D 1C  LDA $1C0D       ; interrupt from timer 1?
FE79: 0A        ASL
FE7A: 10 03     BPL $FE7F       ; no
FE7C: 20 B0 F2  JSR $F2B0       ; IRQ routine for disk controller

Jump from $FE7A:

FE7F: 68        PLA
FE80: A8        TAY
FE81: 68        PLA             ; get registers back
FE82: AA        TAX
FE83: 68        PLA
FE84: 40        RTI



 $FE85/65157:   Constant: Directory track

FE85: 12                        ; 18, track for BAM and directory



 $FE86/65158:   Constant: Start of BAM

FE86: 04                        ; start of BAM at position 4



 $FE87/65159:   Constant: Length of BAM per track

FE87: 04                        ; 4 bytes in BAM for each track



 $FE88/65160:   Constant: End of BAM

FE88: 90                        ; $90 = 144, end of BAM, disk name



 $FE89/65161:   Table of command words

FE89: 56 49 44 4D 42 55 50 26   ; 'V', 'I', 'D', 'M', 'B', 'U', 'P', '&'
FE91: 43 52 53 4E               ; 'C', 'R', 'S', 'N'



 $FE95/65173:   Low  byte of command addresses

FE95: 84 05 C1 F8 1B 5C 07 A3
FE9D: F0 88 23 0D



 $FEA1/65185:   High byte of command addresses

FEA1: ED D0 C8 CA CC CB E2 E7
FEA9: C8 CA C8 EE



 $FEAD/65197:   Bytes for syntax check

FEAD: 51 DD 1C 9E 1C



 $FEB2/65202:   File control methods "RWAM"

FEB2: 52 57 41 4D               ; 'R', 'W', 'A', 'M'



 $FEB6/65206:   File types "DSPUL"

FEB6: 44 53 50 55 4C            ; 'D', 'S', 'P', 'U', 'L'



 $FEBB/65211:   Names of file types: 1st letter "DSPUR"

FEBB: 44 53 50 55 52            ; 1st letters 'D', 'S', 'P', 'U', 'R'



 $FEC0/65216:   Names of file types: 2nd letter "EERSE"

FEC0: 45 45 52 53 45            ; 2nd letters 'E', 'E', 'R', 'S', 'E'



 $FEC5/65221:   Names of file types: 3rd letter "LQGRL"

FEC5: 4C 51 47 52 4C            ; 3rd letters 'L', 'Q', 'G', 'R', 'L'



 $FECA/65226:   Error LED bit value

FECA: 08 00 00



 $FECD/65229:   Masks for bit command

FECD: 3F 7F BF FF



 $FED1/65233:   Number of sectors per track

FED1: 11 12 13 15               ; 17, 18, 19, 21



 $FED5/65237:   'A' marker for 1541 format

FED5: 41                        ; 'A' marker for 1541 format



 $FED6/65238:   4 track ranges

FED6: 04                        ; 4 track numbers



 $FED7/65239:   Number of tracks

FED7: 24                        ; 36, highest track number + 1



 $FED8/65240:   Tracks on which sector numbers change

FED8: 1F 19 12                  ; 31, 25, 18

 Also bit rate changes, see $1C00.




 $FEDB/65243:   Control bytes for head postion

FEDB: 01 FF FF 01 00



 $FEE0/65248:   Buffer address high bytes

FEE0: 03 04 05 06 07 07         ; high bytes



 $FEE6/65254:   ROM checksum

FEE6: 3E



 $FEE7/65255:   From UI command $EB22, to reset (Without RAM/ROM test)

Jump from $FF0B:

FEE7: 6C 65 00  JMP ($0065)



 $FEEA/65258:   Patch for diagnostic routine from $EA7A

Jump from $EA7A:

FEEA: 8D 00 1C  STA $1C00       ; turn LED on
FEED: 8D 02 1C  STA $1C02       ; port to output
FEF0: 4C 7D EA  JMP $EA7D       ; back to diagnostic routine



 $FEF3/65267:   Delay loop for serial bus in 1541 mode, from $E97D

Jump from $E97D:

FEF3: 8A        TXA
FEF4: A2 05     LDX #$05

Jump from $FEF7:

FEF6: CA        DEX             ; about 40 microseconds
FEF7: D0 FD     BNE $FEF6
FEF9: AA        TAX
FEFA: 60        RTS



 $FEFB/65275:   Patch for data output to serial bus, from $E980

Jump from $E980:

FEFB: 20 AE E9  JSR $E9AE       ; CLOCK OUT hi
FEFE: 4C 9C E9  JMP $E99C       ; DATA OUT lo



 $FF01/65281:   U9 vector, switch 1540/1541

FF01: AD 02 02  LDA $0202
FF04: C9 2D     CMP #$2D        ; '-'
FF06: F0 05     BEQ $FF0D
FF08: 38        SEC
FF09: E9 2B     SBC #$2B        ; '+'
FF0B: D0 DA     BNE $FEE7       ; indirect jump over ($0065)

Jump from $FF06:

FF0D: 85 23     STA $23
FF0F: 60        RTS



 $FF10/65296:   Patch for reset routine, from $EAA4

Jump from $EAA4:

FF10: 8E 03 18  STX $1803
FF13: A9 02     LDA #$02
FF15: 8D 00 18  STA $1800
FF18: A9 1A     LDA #$1A
FF1A: 8D 02 18  STA $1802
FF1D: 4C A7 EA  JMP $EAA7



 $FF20/65312:   Patch for listen to serial bus, from $E9DC

Jump from $FF25, $E9DC:

FF20: AD 00 18  LDA $1800
FF23: 29 01     AND #$01
FF25: D0 F9     BNE $FF20
FF27: A9 01     LDA #$01
FF29: 8D 05 18  STA $1805
FF2C: 4C DF E9  JMP $E9DF



 $FF2F/65327:   Unused

FF2F: AA AA AA AA AA AA AA AA
FF37: AA AA AA AA AA AA AA AA
FF3F: AA AA AA AA AA AA AA AA
FF47: AA AA AA AA AA AA AA AA
FF4F: AA AA AA AA AA AA AA AA
FF57: AA AA AA AA AA AA AA AA
FF5F: AA AA AA AA AA AA AA AA
FF67: AA AA AA AA AA AA AA AA
FF6F: AA AA AA AA AA AA AA AA
FF77: AA AA AA AA AA AA AA AA
FF7F: AA AA AA AA AA AA AA AA
FF87: AA AA AA AA AA AA AA AA
FF8F: AA AA AA AA AA AA AA AA
FF97: AA AA AA AA AA AA AA AA
FF9F: AA AA AA AA AA AA AA AA
FFA7: AA AA AA AA AA AA AA AA
FFAF: AA AA AA AA AA AA AA AA
FFB7: AA AA AA AA AA AA AA AA
FFBF: AA AA AA AA AA AA AA AA
FFC7: AA AA AA AA AA AA AA AA
FFCF: AA AA AA AA AA AA AA AA
FFD7: AA AA AA AA AA AA AA AA
FFDF: AA AA AA AA AA AA AA



 $FFE6/65510:   Format  [C8C6]

FFE6: C6 C8                      $C8C6



 $FFE8/65512:   Turn motor off [F98F]

FFE8: 8F F9                      $F98F



 $FFEA/65514:   USER vectors: UA, U1  [CD5F]

FFEA: 5F CD                      $CD5F



 $FFEC/65516:   USER vectors: UB, U2  [CD97]

FFEC: 97 CD                      $CD97



 $FFEE/65518:   USER vectors: UC, U3  [0500]

FFEE: 00 05                      $0500



 $FFF0/65520:   USER vectors: UD, U4  [0503]

FFF0: 03 05                      $0503



 $FFF2/65522:   USER vectors: UE, U5  [0506]

FFF2: 06 05                      $0506



 $FFF4/65524:   USER vectors: UF, U6  [0509]

FFF4: 09 05                      $0509



 $FFF6/65526:   USER vectors: UG, U7  [050C]

FFF6: 0C 05                      $050C



 $FFF8/65528:   USER vectors: UH, U8  [050F]

FFF8: 0F 05                      $050F



 $FFFA/65530:   USER vectors: UI, U9  [FF01]

FFFA: 01 FF                      $FF01



 $FFFC/65532:   Hardware vectors: RESET [EAA0]

FFFC: A0 EA                      $EAA0



 $FFFE/65534:   Hardware vectors: IRQ   [FE67]

FFFE: 67 FE                      $FE67



 1541 Job Codes:

  This table contains the addresses and the assigned buffers:

     +-------+---------+----------+---------------+
     |  JOB  |  TRACK  |  SECTOR  |     BUFFER    |
     +-------+---------+----------+---------------+
     |  $00  |   $06   |   $07    |  $0300-$03FF  |
     |  $01  |   $08   |   $09    |  $0400-$04FF  |
     |  $02  |   $0A   |   $0B    |  $0500-$05FF  |
     |  $03  |   $0C   |   $0D    |  $0600-$06FF  |
     |  $04  |   $0E   |   $0F    |  $0700-$07FF  |
     |  $05  |   $10   |   $11    |   - no RAM -  |
     +-------+---------+----------+---------------+

  If a disk controller routine is to be performed in the interrupt, one
  writes the job code and the track and sector numbers of the block to be
  processed (if necessary) in the appropriate memory locations. Now the
  job code can be passed. This job code has a value greater than 127 (the
  7th bit is set). In order to wait until the job is finished, only the
  seventh bit need be tested. If this bit is cleared, the job is completed.
  The disk controller can perform the following jobs:

     +-------+---------+-------------------------------+
     |  JOB  |  NAME   |          DESCRIPTION          |
     +-------+---------+-------------------------------+
     |  $80  | READ    | Read sector                   |
     |  $90  | WRITE   | Write sector (includes $A0)   |
     |  $A0  | VERIFY  | Verify sector                 |
     |  $B0  | SEEK    | Find sector                   |
     |  $C0  | BUMP    | Bump, Find track 1            |
     |  $D0  | JUMP    | Execute program in buffer     |
     |  $E0  | EXECUTE | Execute program, first switch |
     |       |         | drive on and find track       |
     +-------+---------+-------------------------------+

  If the job ends in an error then the memory location with job command
  code is replaced with and error code. Here is a list of the error numbers:

     +------+--------------------------------+----------------------+
     | CODE | MEANING                        | DOS ERROR MESSAGE    |
     +------+--------------------------------+----------------------+
     | $01  | Everything OK                  | 00, OK               |
     | $02  | Header block not found         | 20, READ ERROR       |
     | $03  | SYNC not found                 | 21, READ ERROR       |
     | $04  | Data block not found           | 22, READ ERROR       |
     | $05  | Checksum error in data block   | 23, READ ERROR       |
     | $07  | Verify error                   | 25, WRITE ERROR      |
     | $08  | Disk write protected           | 26, WRITE PROTECT ON |
     | $09  | Checksum error in header block | 27, READ ERROR       |
     | $0B  | Id mismatch                    | 29, DISK ID MISMATCH |
     | $0F  | Disk not inserted              | 74, DRIVE NOT READY  |
     +------+--------------------------------+----------------------+

  Error codes $06 and $0A do not occur on the 1541.


  +------------------------------------------------------------------------
  |
  |      CBM DOS V2.6 Error Messages
  |
  +------------------------------------------------------------------------
  |
  |   Error #00   OK
  |   Error #01   FILES SCRATCHED,XX (,TT,SS on error)
  |   Error #20   READ ERROR (block header not found),TT,SS
  |   Error #21   READ ERROR (no sync character),TT,SS
  |   Error #22   READ ERROR (data block not present),TT,SS
  |   Error #23   READ ERROR (checksum error in data block),TT,SS
  |   Error #24   READ ERROR (byte decoding error)
  |   Error #25   WRITE ERROR (write-verify error),TT,SS
  |   Error #26   WRITE PROTECT ON,TT,SS
  |   Error #27   READ ERROR (checksum error in header),TT,SS
  |   Error #28   WRITE ERROR (long data block)
  |   Error #29   DISK ID MISMATCH,TT,SS
  |   Error #30   SYNTAX ERROR (general syntax)
  |   Error #31   SYNTAX ERROR (invalid command)
  |   Error #32   SYNTAX ERROR (invalid command)
  |   Error #33   SYNTAX ERROR (invalid file name)
  |   Error #34   SYNTAX ERROR (no file given)
  |   Error #39   SYNTAX ERROR (invalid command)
  |   Error #50   RECORD NOT PRESENT
  |   Error #51   OVERFLOW IN RECORD
  |   Error #52   FILE TOO LARGE
  |   Error #60   WRITE FILE OPEN
  |   Error #61   FILE NOT OPEN
  |   Error #62   FILE NOT FOUND
  |   Error #63   FILE EXISTS
  |   Error #64   FILE TYPE MISMATCH
  |   Error #65   NO BLOCK,TT,SS
  |   Error #66   ILLEGAL TRACK AND SECTOR,TT,SS
  |   Error #67   ILLEGAL SYSTEM T OR S,TT,SS
  |   Error #70   NO CHANNEL (available)
  |   Error #71   DIRECTORY ERROR,TT,SS
  |   Error #72   DISK FULL
  |   Error #73   DOS MISMATCH (73, CBM DOS V2.6 1541)
  |   Error #74   DRIVE NOT READY
  |
  +------------------------------------------------------------------------


 Error #00:   OK

  Command was executed successfully.


 Error #01:   FILES SCRATCHED,XX (,TT,SS on error)

  Status message after scratching. XX is the number of deleted files.
  If an error occured, TT and SS show the block where it appeared.


 Error #20:   READ ERROR (block header not found),TT,SS

  The disk controller is unable to locate the header of the requested data
  block. Caused by an illegal block number, or the header has been destroyed.


 Error #21:   READ ERROR (no sync character),TT,SS

  The disk controller is unable to detect a sync mark on the desired track.
  Caused by misalignment of the read/writer head, no diskette is present, or
  unformatted or improperly seated diskette. Can also indicate a hardware
  failure.


 Error #22:   READ ERROR (data block not present),TT,SS

  The disk controller has been requested to read or verify a data block that
  was not properly written. This error message occurs in conjunction with the
  BLOCK commands and indicates an illegal track and/or block request.


 Error #23:   READ ERROR (checksum error in data block),TT,SS

  This error message indicates that there is an error in one or more of the
  data bytes. The data has been read into the DOS memory, but the checksum
  over the data is in error. This message may also indicate grounding
  problems.


 Error #24:   READ ERROR (byte decoding error)

  The data or header as been read into the DOS memory, but a hardware error
  has been created due to an invalid bit pattern in the data byte. This
  message may also indicate grounding problems.


 Error #25:   WRITE ERROR (write-verify error),TT,SS

  This message is generated if the controller detects a mismatch between the
  written data and the data in the DOS memory.


 Error #26:   WRITE PROTECT ON,TT,SS

  This message is generated when the controller has been requested to write a
  data block while the write protect switch is depressed. Typically, this is
  caused by using a diskette with a write a protect tab over the notch.


 Error #27:   READ ERROR (checksum error in header),TT,SS

  The controller has detected an error in the header of the requested data
  block. The block has not been read into the DOS memory. This message may
  also indicate grounding problems.


 Error #28:   WRITE ERROR (long data block)

  The controller attempts to detect the sync mark of the next header after
  writing a data block. If the sync mark does not appear within a
  predetermined time, the error message is generated. The error is caused by
  a bad diskette format (the data extends into the next block), or by
  hardware failure.


 Error #29:   DISK ID MISMATCH,TT,SS

  This message is generated when the controller has been requested to access
  a diskette which has not been initialized. The message can also occur if a
  diskette has a bad header.


 Error #30:   SYNTAX ERROR (general syntax)

  The DOS cannot interpret the command sent to the command channel.
  Typically, this is caused by an illegal number of file names, or patterns
  are illegally used. For example, two file names may appear on the left side
  of the COPY command.


 Error #31:   SYNTAX ERROR (invalid command)

  The DOS does not recognize the command. The command must start in the first
  position.


 Error #32:   SYNTAX ERROR (invalid command)

  The command sent is longer than 58 characters.


 Error #33:   SYNTAX ERROR (invalid file name)

  Pattern matching is invalidly used in the OPEN or SAVE command.


 Error #34:   SYNTAX ERROR (no file given)

  The file name was left out of a command or the DOS does not recognize it as
  such. Typically, a colon (:) has been left out of the command.


 Error #39:   SYNTAX ERROR (invalid command)

  This error may result if the command sent to command channel (secondary
  address 15) is unrecognized by the DOS.


 Error #50:   RECORD NOT PRESENT

  Result of disk reading past the last record through INPUT#, or GET#
  commands. This message will also occur after positioning to a record
  beyond end of file in a relative file.  If the intent is to expand the file
  by adding the new record (with a PRINT# command), the error message may be
  ignored. INPUT or GET should not be attempted after this error is detected
  without first repositioning.


 Error #51:   OVERFLOW IN RECORD

  PRINT# statement exceeds record boundary. Information is cut off. Since
  the carriage return is sent as a record terminator is counted in the record
  size. This message will occur if the total characters in the record
  (including the final carriage return) exceeds the defined size.


 Error #52:   FILE TOO LARGE

  Record position within a relative file indicates that disk overflow will
  result.


 Error #60:   WRITE FILE OPEN

  This message is generated when a write file that has not been closed is
  being opened for reading.


 Error #61:   FILE NOT OPEN

  This message is generated when a file is being accessed that has not been
  opened in the DOS. Sometimes, in this case, a message is not generated;
  the request is simply ignored.


 Error #62:   FILE NOT FOUND

  The requested file does not exist on the indicated drive.


 Error #63:   FILE EXISTS

  The file name of the file being created already exists on the diskette.


 Error #64:   FILE TYPE MISMATCH

  The file type does not match the file type in the directory entry for the
  requested file.


 Error #65:   NO BLOCK,TT,SS

  This message occurs in conjunction with the B-A command. It indicates that
  the block to be allocated has been previously allocated. The parameters
  indicate the track and sector available with the next highest number. If
  the parameters are zero (0), then all blocks higher in number are in use.


 Error #66:   ILLEGAL TRACK AND SECTOR,TT,SS

  The DOS has attempted to access a track or block which does not exist in
  the format being used. This may indicate a problem reading the pointer to
  the next block.


 Error #67:   ILLEGAL SYSTEM T OR S,TT,SS

  This special error message indicates an illegal system track or block.


 Error #70:   NO CHANNEL (available)

  The requested channel is not available, or all channels are in use. A
  maximum of five sequential files may be opened at one time to the DOS.
  Direct access channels may have six opened files.


 Error #71:   DIRECTORY ERROR,TT,SS

  The BAM does not match the internal count. There is a problem in the BAM
  allocation or the BAM has been overwritten in DOS memory. To correct this
  problem, reinitialize the diskette to restore the BAM in memory. Some
  active files may be terminated by the corrective action.


 Error #72:   DISK FULL

  Either the blocks on the diskette are used or the directory is at its entry
  limit. DISK FULL is sent when two blocks are available on the 1541 to allow
  the current file to be closed.


 Error #73:   DOS MISMATCH (73, CBM DOS V2.6 1541)

  DOS 1 and 2 are read compatible but not write compatible. Disks may be
  interchangeably read with either DOS, but a disk formatted on one version
  cannot be written upon with the other version because the format is
  different. This error is displayed whenever an attempt is made to write
  upon a disk which has been formatted in a non-compatible format. (A utility
  routine is available to assist in converting from one format to another.)
  This message may also appear after power up.


 Error #74:   DRIVE NOT READY

  An attempt has been made to access the 1541 without any diskettes present
  in either drive.

